<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Papyhone</title>
  
  
  <link href="https://csliujw.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://csliujw.github.io/blog/"/>
  <updated>2021-07-24T15:23:52.859Z</updated>
  <id>https://csliujw.github.io/blog/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hello hexo markdown</title>
    <link href="https://csliujw.github.io/blog/IO%E6%A8%A1%E5%9E%8B/"/>
    <id>https://csliujw.github.io/blog/IO%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-07-24T15:18:25.000Z</published>
    <updated>2021-07-24T15:23:52.859Z</updated>
    
    <content type="html"><![CDATA[<p>IO多路复用的学习笔记</p><span id="more"></span><h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li>基本Socket</li><li>多进程</li><li>多线程</li><li>I/O多路复用</li><li>select/poll</li><li>epoll</li></ul><h2 id="基本Socket模型"><a href="#基本Socket模型" class="headerlink" title="基本Socket模型"></a>基本Socket模型</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>服务端首先调用 <code>socket()</code> 函数，创建网络协议为 IPv4，以及传输协议为 TCP 的 Socket ，接着调用 <code>bind()</code> 函数，给这个 Socket 绑定一个 <strong>IP 地址和端口</strong></p><blockquote><p>绑定这两个的目的是什么？</p></blockquote><ul><li>绑定端口的目的：当内核收到 TCP 报文，通过 TCP 头里面的端口号，来找到我们的应用程序，然后把数据传递给我们。</li><li>绑定 IP 地址的目的：一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址，当绑定一个网卡时，内核在收到该网卡上的包，才会发给我们；</li></ul><p>绑定完 IP 地址和端口后，就可以调用 <code>listen()</code> 函数进行监听，此时对应 TCP 状态图中的 <code>listen</code>，如果我们要判定服务器中一个网络程序有没有启动，可以通过 <code>netstate</code> 命令查看对应的端口号是否有被监听。</p><p>服务端进入了监听状态后，通过调用 <code>accept()</code> 函数，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。</p><blockquote><p>那客户端是怎么发起连接的呢？</p></blockquote><p>客户端在创建好 Socket 后，调用 <code>connect()</code> 函数发起连接，该函数的参数要指明服务端的 IP 地址和端口号，然后万众期待的 TCP 三次握手就开始了。</p><p>在  TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：</p><ul><li>一个是还没完全建立连接的队列，称为 <strong>TCP 半连接队列</strong>，这个队列都是没有完成三次握手的连接，此时服务端处于 <code>syn_rcvd</code> 的状态；</li><li>一个是一件建立连接的队列，称为 <strong>TCP 全连接队列</strong>，这个队列都是完成了三次握手的连接，此时服务端处于 <code>established</code> 状态；</li></ul><p>当 TCP 全连接队列不为空后，服务端的 <code>accept()</code> 函数，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的  Socket 返回应用程序，后续数据传输都用这个 Socket。</p><p>注意，监听的 Socket 和真正用来传数据的 Socket 是两个：</p><ul><li>一个叫作<strong>监听 Socket</strong>；</li><li>一个叫作<strong>已连接 Socket</strong>；</li></ul><p>连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过 <code>read()</code> 和 <code>write()</code> 函数来读写数据。</p><p>至此， TCP 协议的 Socket 程序的调用过程就结束了，整个过程如下图：</p><img src="./pics/JavaStrengthen/blog/640.webp"><h3 id="Socket在内核中的表示"><a href="#Socket在内核中的表示" class="headerlink" title="Socket在内核中的表示"></a>Socket在内核中的表示</h3><p>基于 Linux 一切皆文件的理念，在内核中 Socket 也是以「文件」的形式存在的，也是有对应的文件描述符。</p><blockquote><p>文件描述符的作用是什么？</p></blockquote><p>每一个进程都有一个数据结构 <code>task_struct</code>，该结构体里有一个指向「文件描述符数组」的成员指针。该数组里列出这个进程打开的所有文件的文件描述符。数组的下标是文件描述符，是一个整数，而数组的内容是一个指针，指向内核中所有打开的文件的列表，也就是说内核可以通过文件描述符找到对应打开的文件。</p><hr><p>然后每个文件都有一个 inode，Socket 文件的 inode 指向了内核中的 Socket 结构，在这个结构体里有两个队列，分别是<strong>发送队列</strong>和<strong>接收队列</strong>，这个两个队列里面保存的是一个个 <code>struct sk_buff</code>，用链表的组织形式串起来。</p><p>sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。</p><blockquote><p>为什么全部数据包只用一个结构体来描述呢？</p></blockquote><p>协议栈采用的是分层结构，上层向下层传递数据时需要增加包头，下层向上层数据时又需要去掉包头，如果每一层都用一个结构体，那在层之间传递数据的时候，就要发生多次拷贝，这将大大降低 CPU 效率。</p><p>于是，为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 sk_buff 中 <code>data</code> 的指针，比如：</p><ul><li>当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb-&gt;data 的值，来逐步剥离协议首部。</li><li>当要发送报文时，创建 sk_buff 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb-&gt;data 的值来增加协议首部。</li></ul><h2 id="多进程模型"><a href="#多进程模型" class="headerlink" title="多进程模型"></a>多进程模型</h2><p>基于最原始的阻塞网络 I/O， 如果服务器要支持多个客户端，其中比较传统的方式，就是使用<strong>多进程模型</strong>，也就是为每个客户端分配一个进程来处理请求。</p><p>服务器的主进程负责监听客户的连接，一旦与客户端连接完成，accept() 函数就会返回一个「已连接 Socket」，这时就通过 <code>fork()</code> 函数创建一个子进程，实际上就把父进程所有相关的东西都<strong>复制</strong>一份，包括文件描述符、内存地址空间、程序计数器、执行的代码等。</p><p>这两个进程刚复制完的时候，几乎一摸一样。不过，会根据<strong>返回值</strong>来区分是父进程还是子进程，如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。</p><p>正因为子进程会<strong>复制父进程的文件描述符</strong>，于是就可以直接使用「已连接 Socket 」和客户端通信了，</p><p>可以发现，子进程不需要关心「监听 Socket」，只需要关心「已连接 Socket」；父进程则相反，将客户服务交给子进程来处理，因此父进程不需要关心「已连接 Socket」，只需要关心「监听 Socket」。</p><p>下面这张图描述了从连接请求到连接建立，父进程创建生子进程为客户服务。</p><img src="./pics/JavaStrengthen/blog/641.webp"><p>另外，当「子进程」退出时，实际上内核里还会保留该进程的一些信息，也是会占用内存的，如果不做好“回收”工作，就会变成<strong>僵尸进程</strong>，随着僵尸进程越多，会慢慢耗尽我们的系统资源。</p><p>因此，父进程要“善后”好自己的孩子，怎么善后呢？那么有两种方式可以在子进程退出后回收资源，分别是调用 <code>wait()</code> 和 <code>waitpid()</code> 函数。</p><p>这种用多个进程来应付多个客户端的方式，在应对 100 个客户端还是可行的，但是当客户端数量高达一万时，肯定扛不住的，因为每产生一个进程，必会占据一定的系统资源，而且进程间上下文切换的“包袱”是很重的，性能会大打折扣。</p><p>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</p><h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p>线程可以共享进程的部分资源的，比如文件描述符列表、进程空间、代码、全局数据、堆、共享库等，这些共享些资源在上下文切换时是不需要切换，而只需要切换线程的私有数据、寄存器等不共享的数据，因此同一个进程下的线程上下文切换的开销要比进程小得多。</p><p>当服务器与客户端 TCP 完成连接后，通过 <code>pthread_create()</code> 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。</p><p>如果每来一个连接就创建一个线程，线程运行完后，还得操作系统还得销毁线程，虽说线程切换的上写文开销不大，但是如果频繁创建和销毁线程，系统开销也是不小的。</p><p>那么，我们可以使用<strong>线程池</strong>的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出已连接 Socket 进程处理。</p><img src="./pics/JavaStrengthen/blog/642.webp"><p>需要注意的是，这个队列是全局的，每个线程都会操作，为了避免多线程竞争，线程在操作这个队列前要加锁。</p><p>上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程/线程，操作系统就算死扛也是扛不住的。</p><h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p>只使用一个进程来维护多个 Socket： <strong>I/O 多路复用</strong>技术。</p><img src="./pics/JavaStrengthen/blog/643.webp"><p>一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。</p><p>我们熟悉的 select/poll/epoll 内核提供给用户态的多路复用系统调用，<strong>进程可以通过一个系统调用函数从内核中获取多个事件</strong>。</p><p>select/poll/epoll 是如何获取网络事件的呢？在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。</p><p>select/poll/epoll 这是三个多路复用接口，都能实现 C10K 吗？接下来，我们分别说说它们。</p><h3 id="select-poll"><a href="#select-poll" class="headerlink" title="select/poll"></a>select/poll</h3><p>select 实现多路复用的方式是，将已连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用 select 函数将文件描述符集合<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生（全部都要拷贝到内核里，开销大！），检查的方式很粗暴，就是通过==遍历文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。==</p><p>所以，对于 select 这种方式，需要进行 <strong>2 次「遍历」文件描述符集合</strong>，一次是在内核态里，一个次是在用户态里 ，而且还会发生 <strong>2 次「拷贝」文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p><p>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 <code>1024</code>，只能监听 0~1023 的文件描述符。</p><p>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</p><p>但是 poll 和 select 并没有太大的本质区别，<strong>都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</strong>，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p><p>==总结：遍历开销大，用户态与内核态之间拷贝文件描述符集合开销大。==</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll 通过两个方面，很好解决了 select/poll 的问题。</p><ul><li><p>第一点，epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删查一般时间复杂度是 <code>O(logn)</code>，通过对这棵黑红树进行操作，这样就不需要像 select/poll 每次操作时都传入整个 socket 集合，只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</p></li><li><p>第二点， epoll 使用事件驱动的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p></li></ul><p>从下图你可以看到 epoll 相关的接口作用：</p><img src="./pics/JavaStrengthen/blog/644.webp"><p>epoll 的方式即使监听的 Socket 数量越多的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数。因而，<strong>epoll 被称为解决 C10K 问题的利器</strong>。</p><p>插个题外话，网上文章不少说，<code>epoll_wait</code> 返回时，对于就绪的事件，epoll使用的是共享内存的方式，即用户态和内核态都指向了就绪链表，所以就避免了内存拷贝消耗。</p><p>这是错的！看过 epoll 内核源码的都知道，<strong>压根就没有使用共享内存这个玩意</strong>。你可以从下面这份代码看到， epoll_wait 实现的内核代码中调用了 <code>__put_user</code> 函数，这个函数就是将数据从内核拷贝到用户空间。</p><img src="./pics/JavaStrengthen/blog/645.webp"><p>epoll 支持两种事件触发模式，分别是<strong>边缘触发（*edge-triggered，ET*）</strong>和<strong>水平触发（*level-triggered，LT*）</strong>。</p><p>这两个术语还挺抽象的，其实它们的区别还是很好理解的。</p><ul><li>使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；</li><li>使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong>，目的是告诉我们有数据需要读取；</li></ul><p>举个例子，你的快递被放到了一个快递箱里，如果快递箱只会通过短信通知你一次，即使你一直没有去取，它也不会再发送第二条短信提醒你，这个方式就是边缘触发；如果快递箱发现你的快递没有被取出，它就会不停地发短信通知你，直到你取出了快递，它才消停，这个就是水平触发的方式。</p><p>这就是两者的区别，水平触发的意思是只要满足事件的条件，比如内核中有数据需要读，就一直不断地把这个事件传递给用户；而边缘触发的意思是只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。</p><p>如果使用水平触发模式，当内核通知文件描述符可读写时，接下来还可以继续去检测它的状态，看它是否依然可读或可写。所以在收到通知后，没必要一次执行尽可能多的读写操作。</p><p>如果使用边缘触发模式，I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会<strong>循环</strong>从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。所以，<strong>边缘触发模式一般和非阻塞 I/O 搭配使用</strong>，程序会一直执行 I/O 操作，直到系统调用（如 <code>read</code> 和 <code>write</code>）返回错误，错误类型为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</p><p>一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。</p><p>select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。</p><p>另外，使用 I/O 多路复用时，最好搭配非阻塞 I/O 一起使用，Linux 手册关于 select 的内容中有如下说明：</p><p><strong>多路复用 API 返回的事件并不一定可读写的</strong>，如果使用阻塞 I/O， 那么在调用 read/write 时则会发生程序阻塞，因此最好搭配非阻塞 I/O，以便应对极少数的特殊情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最基础的 TCP 的 Socket 编程，它是阻塞 I/O 模型，基本上只能一对一通信，那为了服务更多的客户端，我们需要改进网络 I/O 模型。</p><p>比较传统的方式是使用多进程/线程模型，每来一个客户端连接，就分配一个进程/线程，然后后续的读写都在对应的进程/线程，这种方式处理 100 个客户端没问题，但是当客户端增大到 10000  个时，10000 个进程/线程的调度、上下文切换以及它们占用的内存，都会成为瓶颈。</p><p>为了解决上面这个问题，就出现了 I/O 的多路复用，可以只在一个进程里处理多个文件的  I/O，Linux 下有三种提供 I/O 多路复用的 API，分别是：select、poll、epoll。</p><p>select 和 poll 并没有本质区别，它们内部都是使用「线性结构」来存储进程关注的 Socket 集合。</p><p>在使用的时候，首先需要把关注的 Socket 集合通过 select/poll 系统调用从用户态拷贝到内核态，然后由内核检测事件，当有网络事件产生时，内核需要遍历进程关注 Socket 集合，找到对应的 Socket，并设置其状态为可读/可写，然后把整个 Socket 集合从内核态拷贝到用户态，用户态还要继续遍历整个 Socket 集合找到可读/可写的 Socket，然后对其处理。</p><p>很明显发现，select 和 poll 的缺陷在于，当客户端越多，也就是 Socket 集合越大，Socket 集合的遍历和拷贝会带来很大的开销，因此也很难应对 C10K。</p><p>epoll 是解决 C10K 问题的利器，通过两个方面解决了 select/poll 的问题。</p><ul><li>==epoll 在内核里使用「红黑树」来关注进程所有待检测的 Socket，红黑树是个高效的数据结构，增删查一般时间复杂度是 O(logn)，通过对这棵黑红树的管理，不需要像 select/poll 在每次操作时都传入整个 Socket 集合，减少了内核和用户空间大量的数据拷贝和内存分配。==</li><li>==epoll 使用事件驱动的机制，内核里维护了一个「链表」来记录就绪事件，只将有事件发生的 Socket 集合传递给应用程序，不需要像 select/poll 那样轮询扫描整个集合（包含有和无事件的 Socket ），大大提高了检测的效率。==</li></ul><p>而且，epoll 支持边缘触发和水平触发的方式，而 select/poll 只支持水平触发，一般而言，边缘触发的方式会比水平触发的效率高。</p><hr><h1 id="Reactor和Proactor"><a href="#Reactor和Proactor" class="headerlink" title="Reactor和Proactor"></a>Reactor和Proactor</h1><p>Redis、Nginx、Netty 等都采用了Reactor这个方案。</p><img src="./pics/JavaStrengthen/blog/651.webp">]]></content>
    
    
    <summary type="html">&lt;p&gt;IO多路复用的学习笔记&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaSE" scheme="https://csliujw.github.io/blog/tags/JavaSE/"/>
    
    <category term="IO" scheme="https://csliujw.github.io/blog/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Java8 语法学习</title>
    <link href="https://csliujw.github.io/blog/Java8/"/>
    <id>https://csliujw.github.io/blog/Java8/</id>
    <published>2021-07-24T15:18:25.000Z</published>
    <updated>2021-07-24T15:19:50.590Z</updated>
    
    <content type="html"><![CDATA[<p>Java8 的学习笔记</p><span id="more"></span><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><ul><li>大处着眼，小处着手</li><li>逆向思维、反证法</li><li>透过问题看本质</li></ul><p><strong>小不忍则乱大谋</strong></p><p><strong>识时务者为俊杰</strong></p><p><strong>适当看点经济学的书</strong></p><h1 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h1><blockquote><p><strong>并行流与串行流</strong></p></blockquote><p>把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比串行流，并行流可以很大程度上提高程序的执行效率。【要不要考虑并发安全问题？】</p><p>Java8中Stream API可以声明性地通过parallel()和sequential()在并行流与顺序流直接进行切换。</p><blockquote><p><strong>减少空指针</strong></p></blockquote><p>最大化减少空指针异常：Optional</p><blockquote><p><strong>运行JavaScript</strong></p></blockquote><p>Nashorn引擎，允许在JVM上运行JS应用。</p><h1 id="二、lambda表达式"><a href="#二、lambda表达式" class="headerlink" title="二、lambda表达式"></a>二、lambda表达式</h1><blockquote><p>语言简洁，代码紧凑。==可将其理解为是一段可以传递的代码==</p></blockquote><h2 id="2-1-入门案例使用"><a href="#2-1-入门案例使用" class="headerlink" title="2.1 入门案例使用"></a>2.1 入门案例使用</h2><blockquote><p><strong>入门案例</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;hello runnable&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    r.run();</span><br><span class="line"></span><br><span class="line">    Runnable r2 = () -&gt; System.out.println(<span class="string">&quot;hello lambda&quot;</span>);</span><br><span class="line">    r2.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>不同写法</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名内部类实现接口</span></span><br><span class="line">Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1 - o2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda表达式</span></span><br><span class="line">Comparator&lt;Integer&gt; com2 = (a, b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法引用</span></span><br><span class="line">Comparator&lt;Integer&gt; com3 = Integer::compare;</span><br></pre></td></tr></table></figure><h2 id="2-2-lambda写法简单解释"><a href="#2-2-lambda写法简单解释" class="headerlink" title="2.2 lambda写法简单解释"></a>2.2 lambda写法简单解释</h2><blockquote><p>1、举例：</p></blockquote><p>(o1, o2) -&gt; Integer.compare(o1,o2);</p><blockquote><p>2、格式：</p></blockquote><p>-&gt;:lambda操作符 或 箭头操作符</p><p>-&gt;左边：lambda形参列表（其实就是接口中的抽象方法的形参列表）</p><p>-&gt;右边：lambda体 （其实就是重写的抽象方法的方法体）</p><blockquote><p>3、lambda表达式的使用：分为六种情况介绍</p></blockquote><p>==总结：==</p><p>-&gt;左边：lambda形参列表参数类型可以省略（类型判断），只有一个形式参数时（）可以省略</p><p>-&gt;右边：lambda体应该使用{}包裹，如果只有一条执行语句（可能是return语句），则可以省略这一对{}和return关键字</p><blockquote><p>4、lambda表达式本质：</p></blockquote><p>作为接口的实例。接口中只能有一个抽象方法【不会有歧义，所以方法名称可以省略】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">lambda4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不写注解也行，但是写上会有检查，校验合法不合法！</span></span><br><span class="line"><span class="comment">// 这个就报错了，因为只能有一个抽象方法。【可以有default方法】</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">lambda4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.err.println(<span class="number">123</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是正确的</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">lambda4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>举例</strong></p></blockquote><p><strong>无参，无返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r2 = () -&gt; System.out.println(<span class="string">&quot;hello lambda&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>需要一个参数，但是无返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con1 = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;accept&quot;</span> + t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">con1.accept(<span class="string">&quot; hello&quot;</span>);</span><br><span class="line">Consumer&lt;String&gt; con2 = (String value) -&gt; &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;;</span><br><span class="line">con2.accept(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>数据类型可以省略，由编译器推断，称为类型判断</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con2 = (value) -&gt; &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;;</span><br><span class="line">con2.accept(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>只有一个参数，参数小括号可以省略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con2 = value -&gt; &#123; System.out.println(value); &#125;;</span><br></pre></td></tr></table></figure><p><strong>需要两个或以上的参数，多条执行语句，且有返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; c = (o1, o2) -&gt; &#123;</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(o2);</span><br><span class="line">        <span class="keyword">return</span> o1 - o2;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>lambda体只有一条语句，return 与大括号若有，都可省略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; c2 = (o1, o2) -&gt; o1 - o2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="三、四大函数式接口"><a href="#三、四大函数式接口" class="headerlink" title="三、四大函数式接口"></a>三、四大函数式接口</h1><blockquote><p>只包含一个抽象方法的接口，称为函数式接口。java.util.function包下定义了java8丰富的函数式接口。</p></blockquote><blockquote><p>函数式接口就是，你把这个接口当成形式参数传递过去，你在方法里用了这个接口的方法，你需要使用这个方法就需要去实现；实现可以用匿名内部类实现或者函数式实现这个方法。</p></blockquote><h2 id="3-1-四大函数式接口简介"><a href="#3-1-四大函数式接口简介" class="headerlink" title="3.1 四大函数式接口简介"></a>3.1 四大函数式接口简介</h2><ul><li>消费型接口：void Consumer<T> <ul><li>对类型为T的对象应用操作，包含方法</li><li>void accept(T t)</li></ul></li><li>供给型接口：T Supplier<T><ul><li>返回类型为T的对象，包含方法</li><li>T get()</li></ul></li><li>函数型接口：R Function&lt;T,R&gt;<ul><li>对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法</li><li>R apply(T t)</li></ul></li><li>断定型接口：boolean Predicate<T><ul><li>确定类型为T的对象是否满足某约束，并返回boolean值。包含方法</li><li>boolean test(T t)</li></ul></li></ul><blockquote><p>当发现所需要定义的接口满足以上某一个时，我们就不用自己定义接口了，用jdk给我们提供的就可以了。</p></blockquote><h3 id="3-1-1-消费型接口：Consumer"><a href="#3-1-1-消费型接口：Consumer" class="headerlink" title="3.1.1 消费型接口：Consumer"></a>3.1.1 消费型接口：Consumer</h3><blockquote><p>只需要消费对象，无需返回值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        happy(<span class="number">10.0</span>, <span class="keyword">new</span> Consumer&lt;Double&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Double t)</span> </span>&#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;I get the money = &quot;</span> + t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 函数式接口写法</span></span><br><span class="line">        happy(<span class="number">23.2</span>, money -&gt; System.out.println(<span class="string">&quot;I get the money = &quot;</span> + money));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本质con就是一个对象，我们需要传入一个对象，可以用匿名内部类实现或者lambda表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">happy</span><span class="params">(<span class="keyword">double</span> money, Consumer&lt;Double&gt; con)</span> </span>&#123;</span><br><span class="line">        con.accept(money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-断定型接口-Predicate"><a href="#3-1-2-断定型接口-Predicate" class="headerlink" title="3.1.2 断定型接口 Predicate"></a>3.1.2 断定型接口 Predicate</h3><blockquote><p>就是判断是否符合要求</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">12</span>, <span class="number">234</span>, <span class="number">56</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">54</span>, <span class="number">34</span>);</span><br><span class="line">        <span class="comment">// 匿名内部类</span></span><br><span class="line">        filterNumber(list, <span class="keyword">new</span> Predicate&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Integer t)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> t % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lambda写法 我们只用到了predicate的test方法</span></span><br><span class="line">        filterNumber(list, s -&gt; s % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据给定规则 过滤数据，方法时Predicate中的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">filterNumber</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer number : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.test(number)) &#123;</span><br><span class="line">                arrayList.add(number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="四、方法引用与构造器引用"><a href="#四、方法引用与构造器引用" class="headerlink" title="四、方法引用与构造器引用"></a>四、方法引用与构造器引用</h1><blockquote><p>当要传递给lambda体的操作，已经有实现的方法了，可以使用方法引用！本质上就是lambda表达式</p></blockquote><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p><strong>使用格式</strong></p><p>类（或对象）::方法名</p><p><strong>具体分为如下三种情况</strong></p><ul><li>对象::非静态方法</li><li>类::静态方法</li><li>类::非静态方法【居然可以这样做！】</li></ul><p><strong>方法引用的使用要求</strong></p><p>接口中的抽象方法的形參列表和返回值类型与方法引用的方法的形參列表和返回值类型相同</p><h2 id="4-2-方法引用案例"><a href="#4-2-方法引用案例" class="headerlink" title="4.2 方法引用案例"></a>4.2 方法引用案例</h2><blockquote><p>例子</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test5();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象::非静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// accept(T t)</span></span><br><span class="line">        <span class="comment">// println(T t)</span></span><br><span class="line">        <span class="comment">// 参数一致，参数都省了。。。。</span></span><br><span class="line">        Consumer&lt;String&gt; c = System.out::println;</span><br><span class="line">        c.accept(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象::非静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee(<span class="string">&quot;123&quot;</span>, <span class="number">25620</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// supplier T get()</span></span><br><span class="line">        <span class="comment">// employee T getName()</span></span><br><span class="line">        Supplier&lt;String&gt; sup1 = () -&gt; employee.getName();</span><br><span class="line">        Supplier&lt;String&gt; sup2 = employee::getName;</span><br><span class="line"></span><br><span class="line">        System.out.println(sup1.get());</span><br><span class="line">        System.out.println(sup2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类::静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Comparator&lt;Integer&gt; c1 = (a, b) -&gt; a - b;</span><br><span class="line">        Comparator&lt;Integer&gt; c2 = (a, b) -&gt; Integer.compare(a, b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int compare(T o1, T o2);</span></span><br><span class="line">        <span class="comment">// public static int compare(int x, int y)</span></span><br><span class="line">        <span class="comment">// 形参列表一致</span></span><br><span class="line">        Comparator&lt;Integer&gt; c3 = Integer::compare;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类::静态方法 T泛型，R返回值类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Function&lt;T, R&gt;中的R apply(T t)</span></span><br><span class="line">        <span class="comment">// Mathi中的Long round(Double d)</span></span><br><span class="line">        Function&lt;Double, Long&gt; fn1 = d -&gt; Math.round(d);</span><br><span class="line">        Function&lt;Double, Long&gt; fn2 = Math::round;</span><br><span class="line">        System.err.println(fn2.apply(<span class="number">15.6</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类::实例方法</span></span><br><span class="line">    <span class="comment">// Comparator 中的int comapre(T t1, T t2)</span></span><br><span class="line">    <span class="comment">// String 中的int t1.compareTo(t2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Comparator&lt;String&gt; c2 = (t1, t2) -&gt; t1.compareTo(t2);</span><br><span class="line"></span><br><span class="line">        Comparator&lt;String&gt; c1 = String::compareTo;</span><br><span class="line">        System.err.println(c1.compare(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abd&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-构造器引用案例"><a href="#4-3-构造器引用案例" class="headerlink" title="4.3 构造器引用案例"></a>4.3 构造器引用案例</h2><blockquote><p><strong>语法</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名::<span class="keyword">new</span></span><br><span class="line">数组类型[]::<span class="keyword">new</span> 把数组当成特殊的对象</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Construct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Supplier&lt;Employee&gt; sup = Employee::<span class="keyword">new</span>;</span><br><span class="line">        <span class="comment">// Employee::new;重写了get方法，所以调用get方法才会创建对象</span></span><br><span class="line">        sup.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用了一个String参数的构造方法</span></span><br><span class="line">        Function&lt;String, Employee&gt; fun = Employee::<span class="keyword">new</span>;</span><br><span class="line">        fun.apply(<span class="string">&quot;kkx&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用了两个参数的构造方法</span></span><br><span class="line">        BiFunction&lt;String, Integer, Employee&gt; bf = Employee::<span class="keyword">new</span>;</span><br><span class="line">        bf.apply(<span class="string">&quot;ljw&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组引用</span></span><br><span class="line">        Function&lt;Integer, String[]&gt; fnn1 = len -&gt; <span class="keyword">new</span> String[len];</span><br><span class="line">        Function&lt;Integer, String[]&gt; fnn2 = String[]::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、强大的Stream-API"><a href="#五、强大的Stream-API" class="headerlink" title="五、强大的Stream API"></a>五、强大的Stream API</h1><blockquote><p>Stream API对集合数据进行操作</p></blockquote><blockquote><p>Stream和Collection集合的区别。Collection是一种静态的内存数据结构，而Stream是有关计算的。前者是面向内存的，存储在内存中，后者主要是面向CPU，通过CPU实现计算。</p></blockquote><p><strong>集合讲的数据，Stream讲的计算</strong></p><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ul><li>创建Stream</li><li>中间操作</li><li>终止操作；一旦执行终止操作，就执行中间操作链，并产生结果，之后不在被使用。</li></ul><h2 id="5-2-Stream的使用"><a href="#5-2-Stream的使用" class="headerlink" title="5.2 Stream的使用"></a>5.2 Stream的使用</h2><blockquote><p><strong>特点：</strong></p></blockquote><ul><li>不会自己存储元素</li><li>不会改变元素对象</li><li>延迟执行；只有你调用了终止操作，中间的操作才会执行。</li></ul><h3 id="5-2-1-Stream实例化"><a href="#5-2-1-Stream实例化" class="headerlink" title="5.2.1 Stream实例化"></a>5.2.1 Stream实例化</h3><blockquote><p><strong>通过集合实例化</strong></p></blockquote><p>Collection集合中定义了Stream方法。可返回顺序流和并行流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        arrayList.add(<span class="string">&quot;!@3&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;!@32&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;!@233&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;!@43&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;!@543&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回顺序流</span></span><br><span class="line">        Stream&lt;String&gt; stream = arrayList.stream();</span><br><span class="line">        <span class="comment">// 返回并行流</span></span><br><span class="line">        Stream&lt;String&gt; parallelStream = arrayList.parallelStream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>通过数组实例化</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">23</span>, <span class="number">45</span>, <span class="number">56</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    IntStream stream = Arrays.stream(arr);</span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    Employee e1 = <span class="keyword">new</span> Employee();</span><br><span class="line">    Employee e2 = <span class="keyword">new</span> Employee();</span><br><span class="line">    Employee e3 = <span class="keyword">new</span> Employee();</span><br><span class="line">    Employee[] arre = <span class="keyword">new</span> Employee[] &#123; e1, e2, e3 &#125;;</span><br><span class="line">    Arrays.stream(arre).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>通过Stream的of方法</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream&lt;Integer&gt; of = Stream.of(<span class="number">123</span>, <span class="number">32</span>, <span class="number">4445</span>, <span class="number">56</span>, <span class="number">67</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">45</span>);</span><br><span class="line">    of.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>创建无限流</strong>：可用于造数据。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.iterate(<span class="number">0</span>, t -&gt; t + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.generate(Math::random).limit(<span class="number">20</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-2-Stream的中间操作"><a href="#5-2-2-Stream的中间操作" class="headerlink" title="5.2.2 Stream的中间操作"></a>5.2.2 Stream的中间操作</h3><blockquote><p><strong>筛选与切片</strong></p></blockquote><ul><li><p>filter(Predicate p)    接收lambda，从流中排除某些元素。</p></li><li><p>limit(n)    截断流，使其元素不超过给定数量。</p></li><li><p>skip(n)     跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回<strong>空</strong></p></li><li><p>distinct()   通过流所生成元素的 hashCode() 和equals（）去除重复元素。</p></li></ul><blockquote><p><strong>映射</strong></p></blockquote><table><thead><tr><th><code>方法</code></th><th><code>描述</code></th></tr></thead><tbody><tr><td><code>map(Function f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。<strong>【把某个属性整理成一个Stream】</strong></td></tr><tr><td><code>mapToDouble(ToDoubleFunction f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的<code>DoubleStream</code>。</td></tr><tr><td><code>mapToInt(ToIntFunction f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的<code>IntStream</code>。</td></tr><tr><td><code>mapToLong(ToLongFunction f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的<code>LongStream</code>。</td></tr><tr><td><code>flatMap(Function f)</code></td><td>接收一个函数作为参数，<strong>将流中的每个值都换成另一个流，然后把所有流连接成一个流</strong></td></tr></tbody></table><p><strong>map示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// map 把符合条件的数据归为一类</span></span><br><span class="line">    Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line">    <span class="comment">// 提取出对象中的某种属性</span></span><br><span class="line">    Stream&lt;Integer&gt; ageStream = stream.map(e -&gt; e.getAge());</span><br><span class="line">    <span class="comment">// 对该属性就行筛选</span></span><br><span class="line">    ageStream.filter(s -&gt; s % <span class="number">2</span> == <span class="number">0</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 筛选姓名长度大于三的人，把这些人的名字输出</span></span><br><span class="line">    list.stream().filter(s -&gt; s.getName().length() &gt; <span class="number">3</span>).forEach(s -&gt; &#123;</span><br><span class="line">        System.err.println(s.getName());</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// 或者用map做</span></span><br><span class="line">    list.stream().map(e -&gt; e.getName()).filter(s -&gt; s.length() &gt; <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>flatMap</strong></p><p>flatMap和map的区别是：map会把每个元素都当成一个流，而flatMap是把所有的元素拆分开了，在把他们当作一个整体的流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">floatMapDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// map 把符合条件的数据归为一类</span></span><br><span class="line">    Stream&lt;String&gt; stream = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>).stream();</span><br><span class="line">    Stream&lt;Character&gt; flatMap = stream.flatMap(Middle::fromStringtoChar);</span><br><span class="line">    flatMap.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title">fromStringtoChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Character&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Character&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Character character : str.toCharArray()) &#123;</span><br><span class="line">        arrayList.add(character);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrayList.stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mapToInt之类的</strong></p><p>把xx对象按指定条件转为int类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapToInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream&lt;String&gt; stream = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>).stream();</span><br><span class="line">    <span class="comment">// 首字母ASCII码大于68的转为数字99，否则为-1</span></span><br><span class="line">    stream.mapToInt(s -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(<span class="number">0</span>) &gt; <span class="number">68</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;).forEach(System.out::println);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>排序</strong></p></blockquote><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>sorted()</td><td>产生一个新流，按自然顺序排序<strong>【默认从小到大】</strong></td></tr><tr><td>sorted(Comparator com)</td><td>产生一个新流，按比较器顺序排序</td></tr></tbody></table><blockquote><p><strong>Java层面，涉及到对象的排序就要去想Comparable和Comparator</strong>。排序默认都是从小到大。比对的减法一改，就是从大到小了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Employee&gt; list = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="string">&quot;name&quot;</span>, <span class="number">123</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="string">&quot;ljw&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="string">&quot;lh&quot;</span>, <span class="number">34</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="string">&quot;ljwg&quot;</span>, <span class="number">56</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="string">&quot;lhf&quot;</span>, <span class="number">72</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="string">&quot;ai&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="string">&quot;haha&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="string">&quot;gg&quot;</span>, <span class="number">45</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">srotDemo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; asList = Arrays.asList(<span class="number">1</span>, <span class="number">23</span>, <span class="number">56</span>, <span class="number">32</span>, -<span class="number">23</span>, -<span class="number">23</span>, <span class="number">45</span>, -<span class="number">24</span>);</span><br><span class="line">        asList.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        list.stream().sorted((e1, e2) -&gt; Integer.compare(e1.getAge(), e2.getAge())).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        srotDemo1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-3-Stream的终止操作"><a href="#5-2-3-Stream的终止操作" class="headerlink" title="5.2.3 Stream的终止操作"></a>5.2.3 Stream的终止操作</h3><blockquote><p><strong>匹配与查找</strong></p></blockquote><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>allMatch(Predicate p)</code></td><td>检查是否匹配所有元素</td></tr><tr><td><code>anyMatch(Predicate p)</code></td><td>检查是否至少匹配一个元素</td></tr><tr><td><code>noneMatch(Predicate p)</code></td><td>检查是否没有匹配所有元素</td></tr><tr><td><code>findFirst</code> 返回Optional容器</td><td>返回第一个元素</td></tr><tr><td><code>findAny</code></td><td>返回流中的任意元素</td></tr><tr><td><code>count</code></td><td>返回流中元素总个数</td></tr><tr><td><code>max(Comparator c)</code></td><td>返回流中最大值</td></tr><tr><td><code>min(Comparator c)</code></td><td>返回流中最小值</td></tr><tr><td><code>forEach(Consumer c)</code></td><td>内部迭代</td></tr></tbody></table><blockquote><p><strong>归约操作</strong></p></blockquote><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>reduce(T identity, BinaryOperator)</code></td><td>将流中的元素反复结合起来，得到一个值。返回T</td></tr><tr><td><code>reduce(BinaryOperator b)</code></td><td>将流中的元素反复结合起来，得到一个值。返回Optional<T></td></tr></tbody></table><p>map和reduce的连接称为map-reduce。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReduceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">        fn1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Integer&gt; asList = Arrays.asList(<span class="number">1</span>, <span class="number">23</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">74</span>, <span class="number">234</span>, <span class="number">5</span>, <span class="number">45</span>);</span><br><span class="line">        <span class="keyword">final</span> Integer reduce = asList.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">        System.out.println(reduce);</span><br><span class="line">        Optional&lt;Integer&gt; reduce2 = asList.stream().reduce(Integer::sum);</span><br><span class="line">        System.out.println(reduce2.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>收集</strong>：如收集List，Set，Map</p></blockquote><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>collect(Collector c)</code></td><td>将流转为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法</td></tr></tbody></table><p>Collector接口中方法的实现决定了如何对流执行收集操作。</p><p>Collectors实现类提供了很多静态方法，可以方便地创建常见收集器实例。</p><table><thead><tr><th>方法</th><th>返回类型</th><th>作用</th></tr></thead><tbody><tr><td>toList</td><td>List<T></td><td>把流中元素收集到List</td></tr><tr><td>toSet</td><td>Set<T></td><td>把流中元素收集到Set</td></tr><tr><td>toCollection</td><td>Collection<T></td><td>把流中元素收集到创建的集合</td></tr><tr><td>counting</td><td>Long</td><td>计算流中元素的个数</td></tr><tr><td>summingInt</td><td>Integer</td><td>对流中元素的整数属性求和</td></tr><tr><td>averagingInt</td><td>Double</td><td>计算流中元素Integer属性的平均值</td></tr><tr><td>summarizingInt</td><td>IntSummaryStatistics</td><td>收集流中的Integer属性的统计值。如平均值！</td></tr></tbody></table><blockquote><p>示例代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Colle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Integer&gt; asList = Arrays.asList(<span class="number">1</span>, <span class="number">23</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">78</span>, <span class="number">34</span>, <span class="number">456</span>, <span class="number">678</span>, <span class="number">34456</span>, <span class="number">234</span>);</span><br><span class="line">        Stream&lt;Integer&gt; stream = asList.stream();</span><br><span class="line">        List&lt;Integer&gt; collect = stream.collect(Collectors.toList());</span><br><span class="line">        collect.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-Optional类"><a href="#5-3-Optional类" class="headerlink" title="5.3 Optional类"></a>5.3 Optional类</h2><blockquote></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java8 的学习笔记&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaSE" scheme="https://csliujw.github.io/blog/tags/JavaSE/"/>
    
    <category term="Java8" scheme="https://csliujw.github.io/blog/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE</title>
    <link href="https://csliujw.github.io/blog/JavaSE%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://csliujw.github.io/blog/JavaSE%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-07-24T15:18:25.000Z</published>
    <updated>2021-07-24T15:24:58.372Z</updated>
    
    <content type="html"><![CDATA[<p>JavaSE 的学习笔记</p><span id="more"></span><h1 id="第一部分-入门"><a href="#第一部分-入门" class="headerlink" title="第一部分 入门"></a>第一部分 入门</h1><h2 id="第二章-开发环境"><a href="#第二章-开发环境" class="headerlink" title="第二章 开发环境"></a>第二章 开发环境</h2><h3 id="2-1-Java虚拟机"><a href="#2-1-Java虚拟机" class="headerlink" title="2.1 Java虚拟机"></a>2.1 Java虚拟机</h3><ul><li>JVM：Java虚拟机。Java代码是运行在虚拟机上的。</li><li>跨平台：代码运行在虚拟机上，不同版的OS（linux，windows，mac）对应不同的虚拟机。虚拟机本身不具备跨平台功能，每个OS下都有不同版本的虚拟机。【可理解为，各个OS下的虚拟机都是采用一套编码指令集，JVM是面向操作系统的，它负责把Class字节码解释成系统所能识别的指令并执行，同时也负责程序运行时内存的管理】</li></ul><h3 id="2-2-JRE和JDK"><a href="#2-2-JRE和JDK" class="headerlink" title="2.2 JRE和JDK"></a>2.2 JRE和JDK</h3><ul><li>JRE (Java Runtime Environment):Java程序的运行时环境，包含JVM和运行时所需要的核心类库</li><li>JDK(Java Development Kit):是Java程序开发的工具包，包含JRE和开发人员使用的工具。</li><li>运行Java程序有jre就行，开发Java程序需要JDK。</li><li>Windows会把%CC% CC当作变量进行翻译</li></ul><h2 id="第三章-入门程序"><a href="#第三章-入门程序" class="headerlink" title="第三章 入门程序"></a>第三章 入门程序</h2><h3 id="3-1-程序开发步骤说明"><a href="#3-1-程序开发步骤说明" class="headerlink" title="3.1 程序开发步骤说明"></a>3.1 程序开发步骤说明</h3><ul><li>编写、编译、运行</li><li>Java源程序–&gt;Java字节码文件–&gt;JVM运行</li><li>Javac.exe 编译器 处理后 字节码</li><li>Java.exe 解释器 解释字节码的内容</li></ul><h2 id="第四章-常量"><a href="#第四章-常量" class="headerlink" title="第四章 常量"></a>第四章 常量</h2><ul><li>常量；在程序运行期间固定不变的量。</li><li>常量的分类<ul><li>字符串常量：凡是用双引号引起来的部分叫字符串常量。“asdfas”，可以是空串</li><li>整数常量：直接写上数字的，没有小数点。</li><li>浮点数常量：直接写上数字的，有小数点。</li><li>字符常量：用单引号引起来的 ‘A’，不能是空字符‘’。</li><li>布尔常量：只有量中取值。true，false</li><li>空常量：null，代表没有任何数据。不能直接用来打印。syso(null)是错的。</li></ul></li></ul><h2 id="第五章-变量-amp-数据类型"><a href="#第五章-变量-amp-数据类型" class="headerlink" title="第五章 变量&amp;数据类型"></a>第五章 变量&amp;数据类型</h2><h3 id="5-1-数据类型"><a href="#5-1-数据类型" class="headerlink" title="5.1 数据类型"></a>5.1 数据类型</h3><h4 id="5-1-1-基本数据类型"><a href="#5-1-1-基本数据类型" class="headerlink" title="5.1.1 基本数据类型"></a>5.1.1 基本数据类型</h4><ul><li>整数<ul><li>byte  1个字节</li><li>short 2个字节</li><li>int   4个字节</li><li>long  8个字节</li></ul></li><li>浮点数<ul><li>float     4个字节</li><li>double    8个字节</li></ul></li><li>字符型<ul><li>char      2个字节</li></ul></li><li>布尔型<ul><li>boolean   1个字节</li></ul></li></ul><blockquote><p><strong>Java中默认类型：整型是int，浮点类型是double</strong><br>想要精确的数字不推荐用double，用BigDemical吧。</p></blockquote><h4 id="5-1-2-引用数据类型"><a href="#5-1-2-引用数据类型" class="headerlink" title="5.1.2 引用数据类型"></a>5.1.2 引用数据类型</h4><blockquote><p><strong>字符串，数组，类，接口，Lambda</strong></p></blockquote><p>注意事项：</p><ul><li>字符串不是基本数据类型</li><li>浮点数可能是一个近似值</li><li>数据范围与字节数不一定相关。如float数据范围比long更大，但float是4字节，long是8字节</li><li>浮点数默认是double，如果一定要用float，需要加上一个后缀F(推荐大写)</li><li>如果是整数，默认为int，如果一定要用long，需要加上一个后缀L(推荐大写)</li></ul><h3 id="5-2-变量"><a href="#5-2-变量" class="headerlink" title="5.2 变量"></a>5.2 变量</h3><ul><li>变量：程序运行期间，内容可以发生改变的量</li><li>编译原理，左值与右值</li></ul><h3 id="5-3-强制数据类型转换-▲"><a href="#5-3-强制数据类型转换-▲" class="headerlink" title="5.3 强制数据类型转换 ▲"></a>5.3 强制数据类型转换 ▲</h3><ul><li>强制类型转换一般不推荐使用，因为可能发生精度损失</li><li>byte，short，char这三种数据类型可发生数学运算。</li><li>byte，short，char在运算时都会被首先提升为int类型，然后再计算。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> num1 = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">byte</span> num2 = <span class="number">50</span>;</span><br><span class="line"><span class="comment">//byte + byte --&gt; int + int</span></span><br><span class="line"><span class="keyword">int</span> result = num1 + num2;</span><br><span class="line"><span class="comment">//如果用 byte接收 需要强转</span></span><br><span class="line"><span class="keyword">byte</span> result = (<span class="keyword">byte</span>)(num1 + num2);</span><br><span class="line"><span class="keyword">short</span>同理</span><br></pre></td></tr></table></figure><h3 id="5-4-ASCII码表"><a href="#5-4-ASCII码表" class="headerlink" title="5.4 ASCII码表"></a>5.4 ASCII码表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 -- 48</span><br><span class="line">A -- 65</span><br><span class="line">a -- 97</span><br></pre></td></tr></table></figure><h3 id="5-5-数字和字符的对照关系表（编码表）"><a href="#5-5-数字和字符的对照关系表（编码表）" class="headerlink" title="5.5 数字和字符的对照关系表（编码表）"></a>5.5 数字和字符的对照关系表（编码表）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ASCII码表：American Standard Code <span class="keyword">for</span> Information Interchange</span><br><span class="line">Unicode码表：万国码。也是数字和符号对照关系，开头<span class="number">0</span>-<span class="number">127</span>部分和ASCII完全一样，但是从<span class="number">128</span>开始包含更多字符。</span><br></pre></td></tr></table></figure><h2 id="第六章-常用运算"><a href="#第六章-常用运算" class="headerlink" title="第六章 常用运算"></a>第六章 常用运算</h2><ul><li><p>一元运算符：只需要一个数据就可以进行操作的运算符。</p><ul><li>取反</li><li>自增</li><li>etc</li></ul></li><li><p>二元运算符：需要两个数据才可以进行操作的运算符。</p><ul><li>加法</li><li>减法</li><li>赋值</li></ul></li><li><p>三元运算符：需要三个数据才可以进行的运算符。</p><ul><li>变量名称 = 条件判断?表达式A : 表达式B;</li><li>int max = a &gt; b ? a : b;</li></ul></li><li><p>拓展</p><ul><li>对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么java编译器会自动隐含地为我们补上一个(byte)(short)(char).</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">short = 5 + 8;(都要是常量才行)</span><br><span class="line">等同于</span><br><span class="line">short = 13;</span><br><span class="line">先计算出的结果在进行赋值的</span><br><span class="line">称为编译器的常量优化。</span><br></pre></td></tr></table></figure></li></ul><h2 id="第七章-基本语法"><a href="#第七章-基本语法" class="headerlink" title="第七章 基本语法"></a>第七章 基本语法</h2><h3 id="7-1-switch语句使用的注意事项"><a href="#7-1-switch语句使用的注意事项" class="headerlink" title="7.1 switch语句使用的注意事项"></a>7.1 switch语句使用的注意事项</h3><ul><li>多个case后面的数值不可以重复</li><li>switch后面小括号中只能是下列数据类型<ul><li>基本数据类型 byte/short/char/int</li><li>引用数据类型 String字符串、enum枚举</li></ul></li></ul><h3 id="7-2-循环概述"><a href="#7-2-循环概述" class="headerlink" title="7.2 循环概述"></a>7.2 循环概述</h3><ul><li>for循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( 一 ; 二 ; 四 )&#123;</span><br><span class="line">    三</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(初始化表达<span class="number">1</span> ; 布尔表达式<span class="number">2</span> ; 步进表达式<span class="number">4</span>)&#123;</span><br><span class="line">    循环体<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">流程 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> --&gt; <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> --&gt; <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> --&gt;直到<span class="number">2</span>不满足为止。</span><br><span class="line">初始化语句只会执行一次。</span><br></pre></td></tr></table></figure><ul><li>增强for循环 foreach</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">float</span> x : f)&#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">将每一个f的元素赋值给x</span><br></pre></td></tr></table></figure><h3 id="7-3-方法重载与重写"><a href="#7-3-方法重载与重写" class="headerlink" title="7.3 方法重载与重写"></a>7.3 方法重载与重写</h3><ul><li>方法调用的三种格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>单独调用：方法名称(参数)</span><br><span class="line"><span class="number">2.</span>打印调用：System.out.println(方法名称(参数))</span><br><span class="line"><span class="number">3.</span>赋值调用：数据类型 变量名称 = 方法名称(参数)</span><br></pre></td></tr></table></figure><ul><li><p>方法重载 Overload ▲</p><ul><li>==方法重载== ：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。</li><li>参数列表：个数不同，数据类型不同，顺序不同。</li><li>重载方法调用：JVM通过方法的参数列表，调用不同的方法。</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">以下参数顺序不一样也是重载！</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">short</span> b)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">short</span> b,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实际上，println就是一个被重载的函数</li></ul></li><li><p>方法重写 Overrider </p><ul><li>子类中出现和父类中一模一样的方法(包括返回值类型,方法名,参数列表）</li><li>1.重写的方法必须要和父类一模一样(包括返回值类型,方法名,参数列表)</li><li>2.重写的方法可以使用@Override注解来标识</li></ul></li></ul><h4 id="7-3-1-重载的注意事项▲"><a href="#7-3-1-重载的注意事项▲" class="headerlink" title="7.3.1 重载的注意事项▲"></a>7.3.1 重载的注意事项▲</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">short</span> i)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(short)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">byte</span> i)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(byte)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(int)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">short</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">byte</span> ii = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> iii = <span class="number">7</span>;</span><br><span class="line">    f1(<span class="number">1</span>);  <span class="comment">// f1(int)</span></span><br><span class="line">    f1(<span class="number">1</span>);<span class="comment">// f1(int)</span></span><br><span class="line">    f1(<span class="number">1</span>);<span class="comment">// f1(int)</span></span><br><span class="line">    System.out.println(<span class="string">&quot;==========华丽的分割线==========&quot;</span>);</span><br><span class="line">    f1(i);<span class="comment">// f1(short)</span></span><br><span class="line">    f1(ii);<span class="comment">// f1(byte)</span></span><br><span class="line">    f1(iii);<span class="comment">// f1(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-数组"><a href="#7-4-数组" class="headerlink" title="7.4 数组"></a>7.4 数组</h3><h4 id="7-4-1-数组得初始化"><a href="#7-4-1-数组得初始化" class="headerlink" title="7.4.1 数组得初始化"></a>7.4.1 数组得初始化</h4><ul><li>动态初始化 – 指定数组长度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">300</span>];</span><br></pre></td></tr></table></figure><ul><li>静态初始化 – 指定数组内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int [] array = new int[]&#123;1,2,3,4,5,6&#125;; // 标准格式</span><br><span class="line">int [] array = &#123;1,2,3,4,5,6&#125;; // 省略格式</span><br><span class="line">静态初始化不能拆分成</span><br><span class="line">int [] array;</span><br><span class="line">array = &#123;1,2,34&#125;;</span><br><span class="line">这样是错误得</span><br></pre></td></tr></table></figure><ul><li>总结</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">动态初始化有默认值的过程，</span><br><span class="line">整型 默认为 0</span><br><span class="line">浮点 默认为 0.0</span><br><span class="line">字符 默认为 &#x27;\u0000&#x27;</span><br><span class="line">布尔 默认为 false</span><br><span class="line">引用 默认为 null</span><br><span class="line"></span><br><span class="line">静态初始化也有，不过系统自动马上将默认值替换为了大括号当中的具体数值。</span><br></pre></td></tr></table></figure><h4 id="7-4-2-数组作为参数，返回值"><a href="#7-4-2-数组作为参数，返回值" class="headerlink" title="7.4.2 数组作为参数，返回值"></a>7.4.2 数组作为参数，返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cals</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    xxxx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] calculate(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">int</span> [] array = &#123;a,b&#125;;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">数组作为参数，作为返回值其实都是数组的地址值</span><br></pre></td></tr></table></figure><h3 id="7-5-Java内存划分"><a href="#7-5-Java内存划分" class="headerlink" title="7.5 Java内存划分"></a>7.5 Java内存划分</h3><ul><li>1.栈（stack）：存放的都是方法中的局部变量。方法的运行一定要在栈中运行<ul><li>局部变量：方法的参数，或者方法{}内部的变量</li><li>作用域：一旦超出作用域，立刻从栈内存当中消失</li></ul></li><li>2.堆（heap）：凡是new出来的东西都在堆中<ul><li>堆里面的数据都有默认值。默认值同上</li></ul></li><li>3.方法区（method area）：存储.class相关信息，包含方法的信息。</li><li>4.本地方法栈（native method stack）：与操作系统相关</li><li>5.寄存器（register）：与CPU相关</li></ul><h3 id="7-6-常见异常"><a href="#7-6-常见异常" class="headerlink" title="7.6 常见异常"></a>7.6 常见异常</h3><blockquote><p>ArrayIndexOfBoundsException</p></blockquote><blockquote><p>NullPointException</p></blockquote><blockquote><p>OutOfMemmory</p></blockquote><h1 id="第二部分-基础"><a href="#第二部分-基础" class="headerlink" title="第二部分 基础"></a>第二部分 基础</h1><p>类的初始化过程？？</p><h2 id="第一章-面向对象概述"><a href="#第一章-面向对象概述" class="headerlink" title="第一章 面向对象概述"></a>第一章 面向对象概述</h2><p>类：描述相同事物的共同特征的抽象</p><p>对象：具体存在的实例，是真实地。 实例==对象。</p><p>代码层面，必须现有类，才能创建出对象。</p><p>定义类的格式：</p><p>五大成分（自己总结的！！）如果不是五大成分，那么他就不是正确的。</p><p>修饰符 class 类名{</p><p>​    //1.成员变量（Field 描述类和对象的属性信息）</p><p>​    //2.成员方法（Method：描述类或者对象的行为信息）</p><p>​    //3.构造器（Constructor：初始化一个类的对象并返回引用）</p><p>​    //4.代码块</p><p>​    //5.内部类</p><p>}</p><p>构造器的复习：</p><p>​    作用：初始化一个类的对象并返回。</p><p>​    格式：</p><p>​        修饰符 类名（形参）{</p><p>​        }</p><p>​    构造器初始化对象的格式</p><p>​    类名 对象名称 = new 构造器()</p><hr><p>this关键字的作用：</p><p>​    this代表当前对象的引用</p><p>​    this关键字可以用在实例方法和构造器中</p><p>​    this用在方法中，谁调用这个方法，this就代表谁。</p><p>​    this用在构造器，代表构造器正在初始化那个对象的引用</p><p>插件一键生成无参 有参 toString</p><hr><p>封装的作用：</p><p>​    1.可以提高安全性</p><p>​    2.可以实现代码组件化</p><p>封装的规范：</p><p>​    1.建议成员变量都私有</p><p>​    2.提供成套的getter+setter方法暴露成员变量的取值和赋值</p><p><code>小结：</code>封装的核心思想，，合理隐藏，合理暴露。</p><hr><p>static关键字（重点）</p><p>Java通过成员变量是否有static修饰来区分是类的还是属于对象的。</p><p>static == 静态 == 修饰的成员（方法和成员变量）属于类本身。</p><p>有static，静态成员变量：属于类本身。</p><p>无static，实例成员变量：属于每个实例对象，必须用类的对象来访问。</p><p>成员方法也类似：</p><p>1、静态方法</p><p>2、实例方法</p><p>static修饰，属于类本身，与类加载一次，因为只有一份所以可以被类和类的对象共享。</p><hr><p>成员变量的分类和访问内存图</p><p><img src="..%5Cpics%5CJavaStrengthen%5Cimage-20210421212413778.png" alt="image-20210421212413778"></p><h3 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h3><ul><li><strong>依赖（user-a）</strong>：一个类使用了另一个类的方法，A调用了B的方法，B出bug了，A也可能出bug，软件工程中称之为耦合。</li><li><strong>聚合（has-a）</strong>：一个对象将一个或者多个其它对象作为自己的成员</li><li><strong>继承（is-a）</strong>：</li></ul><h3 id="1-1-面向对象"><a href="#1-1-面向对象" class="headerlink" title="1.1 面向对象"></a>1.1 面向对象</h3><blockquote><p>当需要实现一个功能时，不关心具体的步骤，而是找一个已经具有该功能的人，来替我们做事。</p></blockquote><blockquote><p>什么叫面向对象：把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式【来自百度】</p></blockquote><blockquote><p>面向对象的基本特征：继承，封装，多态</p></blockquote><h3 id="1-2-类和对象"><a href="#1-2-类和对象" class="headerlink" title="1.2 类和对象"></a>1.2 类和对象</h3><ul><li>类：是一组相关 <u><em>属性和行为的集合</em></u> 。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该 类事物。现实中，描述一类事物：<ul><li>属性：就是该事物的状态信息。 </li><li>行为：就是该事物能够做什么。</li><li>举例：小猫。</li><li>属性：名字、体重、年龄、颜色。  </li><li>行为：走、跑、叫。</li></ul></li><li><strong>什么是对象</strong> <ul><li>对象：是一类事物的具体体现。对象是类的一个实例（对象并不是找个女朋友），必然具备该类事物的属性 和行为。</li><li>现实中，一类事物的一个实例：一只小猫。</li><li>属性：tom、5kg、2 years、yellow。   </li><li>行为：溜墙根走、蹦跶的跑、喵喵叫。 </li></ul></li></ul><blockquote><p>类与对象的关系 ：类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的。 类是对象的模板，对象是类的实体。</p></blockquote><h3 id="1-3-一个对象的内存图"><a href="#1-3-一个对象的内存图" class="headerlink" title="1.3 一个对象的内存图"></a>1.3 一个对象的内存图</h3><p>方法区中存放class信息。<br>class中的成员方法一直在方法区中。<br>堆中拿到成员方法的地址，通过地址对方法进行调用【回忆组成原理】。<br>堆将方法区中的成员变量拿到堆中（相当于copy一份），对其进行初始化值得操作。【不同对象的成员变量是独立的（非静态成员变量）】<br>main方法中得变量指向堆中的对象，并对对象进行赋值操作。<br>stack–栈，FIFO</p><h3 id="1-4-成员变量和局部变量"><a href="#1-4-成员变量和局部变量" class="headerlink" title="1.4 成员变量和局部变量"></a>1.4 成员变量和局部变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">局部变量和成员变量</span></span><br><span class="line"><span class="comment">1. 定义的位置不一样【重点】</span></span><br><span class="line"><span class="comment">局部变量：在方法的内部</span></span><br><span class="line"><span class="comment">成员变量：在方法的外部，直接写在类当中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 作用范围不一样【重点】</span></span><br><span class="line"><span class="comment">局部变量：只有方法当中才可以使用，出了方法就不能再用</span></span><br><span class="line"><span class="comment">成员变量：整个类全都可以通用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 默认值不一样【重点】</span></span><br><span class="line"><span class="comment">局部变量：没有默认值，如果要想使用，必须手动进行赋值</span></span><br><span class="line"><span class="comment">成员变量：如果没有赋值，会有默认值，规则和数组一样</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 内存的位置不一样（了解）</span></span><br><span class="line"><span class="comment">局部变量：位于栈内存</span></span><br><span class="line"><span class="comment">成员变量：位于堆内存</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5. 生命周期不一样（了解）[通常是这样，但是不绝对]</span></span><br><span class="line"><span class="comment">局部变量：随着方法进栈而诞生，随着方法出栈而消失</span></span><br><span class="line"><span class="comment">成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01VariableDifference</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    String name; <span class="comment">// 成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>; <span class="comment">// 局部变量</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">(<span class="keyword">int</span> param)</span> </span>&#123; <span class="comment">// 方法的参数就是局部变量</span></span><br><span class="line">        <span class="comment">// 参数在方法调用的时候，必然会被赋值的。</span></span><br><span class="line">        System.out.println(param);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> age; <span class="comment">// 局部变量</span></span><br><span class="line">        System.out.println(age); <span class="comment">// 没赋值不能用</span></span><br><span class="line"></span><br><span class="line">        System.out.println(num); <span class="comment">// 错误写法！</span></span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-访问修饰符"><a href="#1-5-访问修饰符" class="headerlink" title="1.5 访问修饰符"></a>1.5 访问修饰符</h3><blockquote><p><strong>private/protect/public/默认访问</strong></p></blockquote><h4 id="1-5-1-private访问属性"><a href="#1-5-1-private访问属性" class="headerlink" title="1.5.1 private访问属性"></a>1.5.1 private访问属性</h4><blockquote><p><strong>只有本类中可以随意访问，其他类都不行。</strong></p></blockquote><h3 id="1-6-this关键字"><a href="#1-6-this关键字" class="headerlink" title="1.6 this关键字"></a>1.6 this关键字</h3><h4 id="1-6-1-this关键字的一些概念"><a href="#1-6-1-this关键字的一些概念" class="headerlink" title="1.6.1 this关键字的一些概念"></a>1.6.1 this关键字的一些概念</h4><blockquote><p><strong>通过谁调用的方法谁就是this。</strong></p></blockquote><blockquote><p><strong>this只能在方法内部使用，且不能在静态方法中使用。为什么？看JVM。</strong></p></blockquote><blockquote><p><strong>类加载机制！静态的使用不必对类进行实例化。this指的是当前对象的引用。</strong></p></blockquote><h4 id="1-6-2-this关键字的一些作用"><a href="#1-6-2-this关键字的一些作用" class="headerlink" title="1.6.2 this关键字的一些作用"></a>1.6.2 this关键字的一些作用</h4><ul><li>在构造器中调用构造器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flower</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Flower</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Flower</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="number">12</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PS:</span><br><span class="line"><span class="keyword">this</span>只能调用一个构造器</span><br><span class="line"><span class="keyword">this</span>调用的构造器要放在最前面    </span><br></pre></td></tr></table></figure><h3 id="1-6-匿名对象"><a href="#1-6-匿名对象" class="headerlink" title="1.6 匿名对象"></a>1.6 匿名对象</h3><h2 id="第二章-API"><a href="#第二章-API" class="headerlink" title="第二章 API"></a>第二章 API</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>API(Application Programming Interface)</code>，应用程序编程接口。</p><h3 id="API使用步骤"><a href="#API使用步骤" class="headerlink" title="API使用步骤"></a><code>API</code>使用步骤</h3><ul><li>1.打开帮助文档。</li><li>2.点击显示，找到索引，看到输入框。</li><li>3.你要找谁？在输入框里输入，然后回车。</li><li>4.看包。java.lang下的类不需要导包，其他需要。</li><li>5.看类的解释和说明。</li><li>6.学习构造方法。</li></ul><h2 id="第三章-字符串"><a href="#第三章-字符串" class="headerlink" title="第三章 字符串"></a>第三章 字符串</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><blockquote><p><strong>字符串：程序中凡是所有的双引号字符串都是String类的对象【就算没有new，也照样是】</strong></p></blockquote><h4 id="3-1-1-字符串的特点"><a href="#3-1-1-字符串的特点" class="headerlink" title="3.1.1 字符串的特点"></a>3.1.1 字符串的特点</h4><ul><li>字符串的内容永不可变。【常量池？】</li><li>因字符串不可变，故字符串可共享使用【不可变，不会出现线程安全问题】</li><li>字符串效果相当于char[]字符数组，但底层原理是byte[]字节数组</li><li>String str = “Hello” 也是字符串对象</li></ul><h4 id="3-1-2-字符串常量池"><a href="#3-1-2-字符串常量池" class="headerlink" title="3.1.2 字符串常量池"></a>3.1.2 字符串常量池</h4><blockquote><p><strong>字符串常量池</strong>：程序中直接写上双引号的字符串，就在字符串常量池中。从jdk1.7开始，字符串常量在堆中。【方便gc嘛？】</p></blockquote><blockquote><p>对于基本类型来说， == 是进行数值比较</p></blockquote><blockquote><p>对应用类型来说，==是进行【地址值】的比较</p></blockquote><p>就算不new 字符串直接双引号也是一个对象。故String str1 是一个对象。</p><p>字符串常量池中的对象保持的其实是byte数组的地址值。</p><p>而直接new出来的，是不在常量池中的。【具体过程看图。用new String(char型数组)有一个中转过程】<br>    char[] –&gt; byte[] –&gt; 字符串对象<br>    字符串对象再指向byte数组</p><p><strong>总结：双引号直接写的在常量池中，new的不在池中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] charArray = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">    String str3 = <span class="keyword">new</span> String(charArray);</span><br><span class="line"></span><br><span class="line">    System.out.println(str1 == str2);<span class="comment">// true</span></span><br><span class="line">    System.out.println(str1 == str3);<span class="comment">// false</span></span><br><span class="line">    System.out.println(str2 == str3);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    String str4 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    String str5 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    System.out.println(str1 == str4); <span class="comment">// false</span></span><br><span class="line">    System.out.println(str4 == str5); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-字符串常用API"><a href="#3-2-字符串常用API" class="headerlink" title="3.2 字符串常用API"></a>3.2 字符串常用API</h3><h4 id="3-2-1-字符串的比较▲"><a href="#3-2-1-字符串的比较▲" class="headerlink" title="3.2.1 字符串的比较▲"></a>3.2.1 字符串的比较▲</h4><blockquote><p><strong>== 是进行对象的地址值比较。如果确实需要比较字符串的内容，可以使用如下的方法</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testEqual</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str1 = <span class="keyword">new</span> String(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">    String str2 = <span class="keyword">new</span> String(<span class="string">&quot;11&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String str3 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">    System.out.println(str1.equals(str2)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(str1.equals(str3)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(str1.equals(<span class="string">&quot;11&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String 对equals进行了重写！</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意事项</strong></p></blockquote><ul><li>如果比较双方一个常量一个变量，推荐把常量写在前面。【避免NullPointerException】</li><li><strong>equalsIgnoreCase</strong>忽略大小写进行比较。</li></ul><h4 id="3-2-2-字符串获取相关方法"><a href="#3-2-2-字符串获取相关方法" class="headerlink" title="3.2.2 字符串获取相关方法"></a>3.2.2 字符串获取相关方法</h4><ul><li>```java<ul><li>length</li><li>concat(String str) 拼接会产生新的字符串</li><li>charAt(int index)</li><li>indexOf(String str) 查找首次出现的位置，没有返回-1</li></ul>public static void testGetStr(){<pre><code>String str1 = &quot;abc&quot;;String str2 = &quot;df&quot;;System.out.println(str1.length()); // 3System.out.println(str1.charAt(0)); // aSystem.out.println(str1.concat(str2)); // abcdfSystem.out.println(str1.indexOf(&quot;ab&quot;)); // 0System.out.println(str2.indexOf(&#39;d&#39;)); // 0</code></pre>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- concat的测试▲</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public void testConcat()&#123;</span><br><span class="line">      String str1 = &quot;abc&quot;;</span><br><span class="line">      String str2 = &quot;df&quot;;</span><br><span class="line">      String concat = str1.concat(str2);</span><br><span class="line">      String concat2 = &quot;abcdf&quot;;</span><br><span class="line">      String concat3 = &quot;abcdf&quot;;</span><br><span class="line">      System.out.println(concat == concat2); // false</span><br><span class="line">      System.out.println(concat2 == concat3);// true</span><br><span class="line">  &#125;</span><br><span class="line">  concat内部返回的字符串是使用的new。故会有上述结果！</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-3-字符串截取、转换、分割"><a href="#3-2-3-字符串截取、转换、分割" class="headerlink" title="3.2.3 字符串截取、转换、分割"></a>3.2.3 字符串截取、转换、分割</h4><blockquote><p><strong>截取指定索引的数据</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSubstring</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str1 = <span class="string">&quot;abcefghig&quot;</span>;</span><br><span class="line"><span class="comment">// beginIndex</span></span><br><span class="line">    System.out.println(str1.substring(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// beginIndex, endIndex 左闭右开</span></span><br><span class="line">    System.out.println(str1.substring(<span class="number">1</span>,str1.length()));</span><br><span class="line">    <span class="comment">// false</span></span><br><span class="line">    System.out.println(str1.substring(<span class="number">1</span>) == str1.substring(<span class="number">1</span>,str1.length()));</span><br><span class="line">&#125;</span><br><span class="line">查看源码可知 返回的是<span class="keyword">new</span> String</span><br></pre></td></tr></table></figure><blockquote><p><strong>字符串转换字符数组，字节数组</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConvert</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray(); <span class="comment">// 转化为字符数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = str.getBytes(); <span class="comment">// 转化为字节数组</span></span><br><span class="line">    String replace = str.replace(<span class="string">&quot;o&quot;</span>, <span class="string">&quot;liu&quot;</span>); <span class="comment">// 把所有的o替换成liu</span></span><br><span class="line">    System.out.println(replace); <span class="comment">//hellliu wliurld</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>分割</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;aa,bb,cc&quot;</span>;</span><br><span class="line">    String[] split = str.split(<span class="string">&quot;,&quot;</span>); <span class="comment">// 里面是正则表达式</span></span><br><span class="line">    <span class="keyword">for</span> (String s : split ) &#123;</span><br><span class="line">        System.out.println(s);<span class="comment">// aa bb cc</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplit2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;aa.b.cc&quot;</span>;</span><br><span class="line">    String[] split = str.split(<span class="string">&quot;\\.&quot;</span>); <span class="comment">//用.作为划分</span></span><br><span class="line">    <span class="keyword">for</span> (String s : split ) &#123;</span><br><span class="line">        System.out.println(s);<span class="comment">// aa bb cc</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四章-静态关键字"><a href="#第四章-静态关键字" class="headerlink" title="第四章 静态关键字"></a>第四章 静态关键字</h2><blockquote><p><strong>可实现数据共享。static修饰的内容不再属于对象自己，而是属于类的，所以凡是本类的对象，都共享同一份。</strong></p></blockquote><h3 id="4-1-静态概述"><a href="#4-1-静态概述" class="headerlink" title="4.1 静态概述"></a>4.1 静态概述</h3><ul><li><p>static修饰的成员方法是静态方法，静态方法不属于对象，而是属于类。</p></li><li><p>PS： 静态不能直接访问非静态。</p><ul><li>因为内存中是【先】有静态内容，【后】有非静态内容</li></ul></li><li><p>PS：静态中不能使用this。</p><ul><li><p>因为this代表当前对象，通过谁调用的方法就是当前对象。但是静态与对象无关。静态是【类名称.静态方法】</p></li><li><p>```java<br>new Object().staticMethod(); 最终会翻译成ClassName.staticMethod();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 4.1 静态代码块</span><br><span class="line"></span><br><span class="line">&gt; 格式</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class ClassName&#123;</span><br><span class="line">static&#123;</span><br><span class="line">静态代码块执行。</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 特点：当第一次用到本类时，静态代码块执行唯一的一次【静态代码块只执行一次】</span><br><span class="line">// 用到类就行。就是只是类名称.staticMethod()调用也是用到了类，static会被执行。</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="4-1-1-静态代码块的注意事项"><a href="#4-1-1-静态代码块的注意事项" class="headerlink" title="4.1.1 静态代码块的注意事项"></a>4.1.1 静态代码块的注意事项</h4><ul><li>静态代码块的执行顺序与定义的顺序有关。先定义的先执行。</li><li>静态代码块的执行顺序优于静态方法，构造方法！【先有静态，再有堆中的对象。静态总是优于非静态。】</li></ul><h4 id="4-1-2-静态工具类Arrays"><a href="#4-1-2-静态工具类Arrays" class="headerlink" title="4.1.2 静态工具类Arrays"></a>4.1.2 静态工具类Arrays</h4><blockquote><p>常用方法如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Integer []array = &#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    String str = Arrays.toString(array); <span class="comment">// 转成String 可以是基本类型 如int</span></span><br><span class="line">    Arrays.sort(array); <span class="comment">// 排序 ascending 升序 可以是基本类型 如int</span></span><br><span class="line">    Arrays.sort(array, Collections.reverseOrder()); <span class="comment">// 反转，变成了降序。注意这个方法要用引用类型</span></span><br><span class="line">    System.out.println(array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>自定义类型的排序，那么这个定义的类需要有<strong>Comparable或者Comparator接口支持</strong>。</p></li><li><p><span style="color:red">拓展看下Comparable和Comparator的区别和应用</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 挖坑</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-1-3-静态工具类Math"><a href="#4-1-3-静态工具类Math" class="headerlink" title="4.1.3 静态工具类Math"></a>4.1.3 静态工具类Math</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> abs = Math.abs(-<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">double</span> ceil = Math.ceil(<span class="number">12.3</span>); <span class="comment">// 向上取整 13</span></span><br><span class="line">    <span class="keyword">double</span> floor = Math.floor(<span class="number">12.4</span>); <span class="comment">// 向下取整 12</span></span><br><span class="line">    <span class="keyword">long</span> round = Math.round(<span class="number">12.6</span>); <span class="comment">// 13 四舍五入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第五章-继承"><a href="#第五章-继承" class="headerlink" title="第五章 继承"></a>第五章 继承</h2><blockquote><p>继承是多态的前提，没有继承就没有多态！</p></blockquote><blockquote><p>继承主要解决的问题是：<strong>共性抽取</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">父类也称为基类、超类</span><br><span class="line">子类也称为：派生类</span><br><span class="line">在继承关系中：“子类就是一个父类”。也就是说，子类可以被当成父类看待</span><br><span class="line">例如父类是员工，子类是讲师，那么讲师就是一个员工。 关系 is-a。</span><br><span class="line">父类是抽象的，子类是具体的。</span><br></pre></td></tr></table></figure><p>被继承的类：父类/超类</p><p>继承父类的类：子类</p><p>继承的作用？</p><ul><li>提高代码复用</li><li>功能增强</li></ul><p>继承的特点：</p><ul><li>子类继承了一个父类，子类可以直机得到父类的属性和方法。（私有的好像无法得到？）</li></ul><hr><p>继承是 is a</p><p>组合是 hava a</p><hr><p><img src="..%5Cpics%5CJavaStrengthen%5Coop_extend_lianxi.png" alt="image-20210422125216087"></p><hr><p><code>继承后子类不能继承的成员★★</code></p><p>引入：</p><p>​    子类继承父类，子类就得到了父类的属性和行为</p><p>​    但是并非所有的父类的属性和行为等子类都可继承</p><p>子类不能继承父类的东西</p><p>​    【无争议的观点】子类不能继承父类的构造器</p><p>​    【有争议的观点】子类能否继承父类的私有成员？</p><p>​    【有争议的观点】子类能否继承父类的静态成员？</p><h3 id="5-1-继承中成员变量的访问特点"><a href="#5-1-继承中成员变量的访问特点" class="headerlink" title="5.1 继承中成员变量的访问特点"></a>5.1 继承中成员变量的访问特点</h3><blockquote><p>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoExtends</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//运行时看左边。这里就是看Fu类。没有就一级一级向上找。</span></span><br><span class="line">        Fu de = <span class="keyword">new</span> DemoExtends();</span><br><span class="line">        System.out.println(de.a); <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>区分子类方法中重名的三种变量</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">局部变量 直接写</span><br><span class="line">本类的成员变量 <span class="keyword">this</span>.变量名</span><br><span class="line">父类的成员变量 <span class="keyword">super</span>.成员变量</span><br></pre></td></tr></table></figure><h3 id="5-2-重写和重载"><a href="#5-2-重写和重载" class="headerlink" title="5.2 重写和重载"></a>5.2 重写和重载</h3><ul><li>重写：在继承关系中，<strong>方法名称一样，参数列表【也一样】</strong>。覆盖、覆写 === 【没说返回值！】</li><li>重载：方法名称一样，参数列表【不一样】</li></ul><blockquote><p><strong>方法覆盖重写的特点</strong>：创建的是子类对象，则优先用子类方法</p></blockquote><ul><li><p>方法覆盖重写的注意事项</p><ul><li><p>1，必须保证父子类之间方法名相同，参数列表也相同</p></li><li><p>2，子类方法的返回值必须【小于等于】父类方法的返回值范围。</p></li><li><p>简而言之，参数必须要一样，且返回类型必须要兼容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类的返回类型小于等于父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为什么？ 是因为向上转型安全，向下转型不安全吗？ 百度的，不确定!</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>不管父类使用了那种参数，覆盖此方法的子类也一定要使用相同的参数。而不论父类声明的返回类型是声明，<strong>子类必须要声明返回一样的类型或该类型的子类</strong>。要记得，子类对象得保证能够执行父类得一切。</p></li><li><p>3，子类方法的权限必须【大于等于】父类方法的权限修饰符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &gt; <span class="keyword">protected</span> &gt; (<span class="keyword">default</span>) &gt; <span class="keyword">private</span></span><br><span class="line">PS : (<span class="keyword">default</span>)不是关键字<span class="keyword">default</span>，而是什么都不写，留空！</span><br></pre></td></tr></table></figure></li><li><p>方法重写的应用场景</p><ul><li><p><strong>设计原则</strong>：</p><blockquote><p>对于已经投入使用的类，尽量不要进行修改。推荐定义一个新的类，来重复利用其中共性内容，并且添加改动新内容。</p></blockquote></li></ul></li></ul><h3 id="5-3-继承中构造方法的访问特点"><a href="#5-3-继承中构造方法的访问特点" class="headerlink" title="5.3 继承中构造方法的访问特点"></a>5.3 继承中构造方法的访问特点</h3><p>子类构造方法中默认隐含有一个super()调用，所以一定是先调用父类构造</p><p>只有<strong>子类构造方法才能调用父类构造方法</strong>且只能调用一个构造方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是错误的，因为只能调用一个父类的构造。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">super</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用普通方法没问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.method();</span><br><span class="line">    <span class="keyword">super</span>.qq();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this调用构造也是只能调用一个，不能循环调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Zi(int x)&#123;</span><br><span class="line">    this();</span><br><span class="line">    System.out.println(&quot;int x&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this不能循环调用【循环引用？Spring循环依赖？】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样是错误的！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;我是无参&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;int x&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super和this不能同时显式调用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错 因为 super or this都需要放在第一行！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;我是无参&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没问题， 父类的构造也是会执行的。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;我是无参&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-继承中-this和super的内存图"><a href="#5-4-继承中-this和super的内存图" class="headerlink" title="5.4 继承中 this和super的内存图"></a>5.4 继承中 this和super的内存图</h3><h2 id="第六章-抽象"><a href="#第六章-抽象" class="headerlink" title="第六章 抽象"></a>第六章 抽象</h2><blockquote><p><strong>若父类中的方法不能确定如何进行{}方法体实现，那么这就应该是一个抽象方法。</strong></p></blockquote><h3 id="6-1-抽象概述"><a href="#6-1-抽象概述" class="headerlink" title="6.1 抽象概述"></a>6.1 抽象概述</h3><ul><li>抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束</li><li>抽象类：抽象方法所在的类，必须是抽象类才行！在class之前写上abstract即可</li><li>default关键字</li></ul><h3 id="6-2-如何使用抽象类和抽象方法"><a href="#6-2-如何使用抽象类和抽象方法" class="headerlink" title="6.2 如何使用抽象类和抽象方法"></a>6.2 如何使用抽象类和抽象方法</h3><ul><li><p>不能直接创建new抽象类对象。</p></li><li><p>必须用一个子类来继承抽象父类。</p></li><li><p><strong>子类必须覆盖重写抽象父类当中所有的抽象方法。</strong></p><ul><li>子类重写时，去掉抽象方法的abstract关键字，然后补上方法体。</li></ul></li><li><p>创建子类对象进行使用。</p></li><li><p><strong>PS：Please attention</strong></p><ul><li><p>抽象类可以自己写构造函数</p></li><li><p>如果抽象类只有 有参构造，那么子类的构造函数一定要显示调用这个有参构造！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;:walk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Cat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象类可以实例化，但是不能直接实例化。只能在子类被实例化的过程中，间接实例化。因为实例化子类的时候抽象类也会被实例化。【用的是extends关键字。父类的super会被隐式调用】</p><p><a href="https://zhuanlan.zhihu.com/p/95406830">建议看这篇博文</a></p></li></ul></li></ul><h2 id="第七章-接口"><a href="#第七章-接口" class="headerlink" title="第七章 接口"></a>第七章 接口</h2><blockquote><p><strong>一种公共的规范标准。【定义规范】【多个类的公共规范】</strong></p></blockquote><blockquote><p><strong>结构是一种引用数据类型，最重要的内容就是其中的：抽象方法</strong></p></blockquote><blockquote><p>接口中定义的方法<strong>默认使用public abstract修饰</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Name</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意！Notice!</strong></p></blockquote><ul><li>如果是<strong>Java 7</strong>那么接口中可以包含有<ul><li>常量</li><li>抽象方法</li></ul></li><li>如果是<strong>Java 8</strong>还可以额外包含有<ul><li>默认方法 public default 返回值类型 方法名称( 参数列表 ){  方法体 }</li><li>静态方法</li></ul></li><li>如果是<strong>Java 9</strong>还可以额外包含有<ul><li>私有方法</li></ul></li></ul><h3 id="7-1-代码示例"><a href="#7-1-代码示例" class="headerlink" title="7.1 代码示例"></a>7.1 代码示例</h3><blockquote><p>在任何版本的Java中，接口都能定义抽象方法。<br>格式：public abstract 返回值类型 方法名称(参数列表);</p></blockquote><ul><li>注意事项：<ul><li>接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract</li><li>这两个关键字修饰符，可以选择性地省略。（今天刚学，所以不推荐。）</li><li>方法的三要素，可以随意定义。</li><li><strong>如果接口的实现类没有覆盖重写接口中所有的抽象方法，那么这个类必须是抽象类！</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这也是抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这也是抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这也是抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodAbs4</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Java 8开始，接口中允许定义默认方法【<strong>接口当中的默认方法，可以解决接口升级问题。</strong>】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口当中的默认方法，可以解决接口升级问题。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">syso(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体解释：接口中的default可以不用被重写。如果我们要扩充接口，但是又不想更改其他已经实现接口的类，可采用default。</span></span><br></pre></td></tr></table></figure><p>Java 8开始，接口中允许定义静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可直接通过【接口名.staticMethod】调用！且只能用接口名调用！不能用实现类调用！</span><br></pre></td></tr></table></figure><p><strong>Java 9开始</strong>，接口中允许定义私有方法</p><p>普通私有方法，解决多个默认方法之间重复代码问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态私有方法，解决多个静态方法之间重复代码问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口中可定义常量,且可省略public static final，默认就是他！</strong>【接口中的常量必须赋值！因为有final修饰！】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">接口名.num调用！</span><br></pre></td></tr></table></figure><h3 id="7-2-总结"><a href="#7-2-总结" class="headerlink" title="7.2 总结"></a>7.2 总结</h3><blockquote><p><strong>在Java 9+版本中，接口的内容可以有：</strong></p></blockquote><ol><li><ul><li>成员变量其实是常量，格式：<br>[public] [static] [final] 数据类型 常量名称 = 数据值;<br> 注意：<br>常量必须进行赋值，而且一旦赋值不能改变。<br>常量名称完全大写，用下划线进行分隔。</li></ul></li><li><ul><li>接口中最重要的就是抽象方法，格式：<br>[public] [abstract] 返回值类型 方法名称(参数列表);<br> 注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。</li></ul></li><li><ul><li>从Java 8开始，接口里允许定义默认方法，格式：<br>[public] default 返回值类型 方法名称(参数列表) { 方法体 }<br> 注意：默认方法也可以被覆盖重写</li></ul></li><li><ul><li>从Java 8开始，接口里允许定义静态方法，格式：<br>[public] static 返回值类型 方法名称(参数列表) { 方法体 }<br> 注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法</li></ul></li><li><ul><li>从Java 9开始，接口里允许定义私有很乏，格式：<br>普通私有方法：private 返回值类型 方法名称(参数列表) { 方法体 }<br> 静态私有方法：private static 返回值类型 方法名称(参数列表) { 方法体 }<br> 注意：private的方法只有接口自己才能调用，不能被实现类或别人使用。</li></ul></li></ol><h3 id="7-3-接口的注意事项"><a href="#7-3-接口的注意事项" class="headerlink" title="7.3 接口的注意事项"></a>7.3 接口的注意事项</h3><ul><li>接口中不能有构造方法，不能有静态代码块</li><li>一个类的直接父类只有一个，但是可同时实现多个接口</li><li><strong>如果实现类所实现的多个接口中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</strong></li><li><strong>一个类如果直接父类当中的方法和接口中的默认方法产生了冲突，优先用父类当中的方法！</strong></li></ul><h2 id="第八章-多态"><a href="#第八章-多态" class="headerlink" title="第八章 多态"></a>第八章 多态</h2><blockquote><p><strong>extends继承或implements实现是多态性的前提！</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">多态写法，父类引用指向子类对象</span><br><span class="line">Fu obj = <span class="keyword">new</span> Zi();</span><br><span class="line">obj.method();</span><br><span class="line">obj.methodFu();</span><br></pre></td></tr></table></figure><h3 id="8-1-访问成员变量的两种方式"><a href="#8-1-访问成员变量的两种方式" class="headerlink" title="8.1 访问成员变量的两种方式"></a>8.1 访问成员变量的两种方式</h3><ul><li>直接通过对象名称访问成员变量：看等号左边是谁，优先使用谁，没有则向上找</li><li>间接通过成员方法访问</li><li>老毕在讲到多态执行问题时，结合下面的例子，给我们总结了一套口诀：“成员变量，静态方法看左边；非静态方法：编译看左边，运行看右边。”意思是：当父类变量引用子类对象时（Fu f = new Zi();），在这个引用变量f指向的对象中，他的成员变量和静态方法与父类是一致的，他的非静态方法，在编译时是与父类一致的，运行时却与子类一致（发生了复写）。</li><li>简而言之<ul><li><strong>成员变量：编译看左边，运行还看左边</strong></li><li><strong>成员方法：编译看左边，运行看右边</strong></li></ul></li></ul><h3 id="8-2-多态的好处"><a href="#8-2-多态的好处" class="headerlink" title="8.2 多态的好处"></a>8.2 多态的好处</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Employee one = <span class="keyword">new</span> Teacher();</span><br><span class="line">Employee two = <span class="keyword">new</span> Assistant();</span><br></pre></td></tr></table></figure><p><strong>无论右边new的时候换成那个子类对象，等号左边调用方法都不会变化！</strong></p><h3 id="8-3-对象的向上、下转型"><a href="#8-3-对象的向上、下转型" class="headerlink" title="8.3 对象的向上、下转型"></a>8.3 对象的向上、下转型</h3><ul><li><p>向上转型一定是安全的，没有问题的，正确的。弊端在于，对象一旦向上转型为父类，就无法调用子类原本持有的内容。</p></li><li><p>向下转型是不安全的，使用时一定要保证他本来是猫才能向下转型变成猫</p></li><li><p>instanceof进行类型判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( animal <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">syso(<span class="string">&quot;是狗&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">一般先判断是否是该类，是才进行向下转型！</span><br></pre></td></tr></table></figure></li></ul><h2 id="第九章-final"><a href="#第九章-final" class="headerlink" title="第九章 final"></a>第九章 final</h2><h3 id="9-1-final修饰类"><a href="#9-1-final修饰类" class="headerlink" title="9.1 final修饰类"></a>9.1 final修饰类</h3><p>final修饰的类是没有子孙的，但是有父亲（太监类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法被继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-final修饰方法"><a href="#9-2-final修饰方法" class="headerlink" title="9.2 final修饰方法"></a>9.2 final修饰方法</h3><p>final修饰的方法是最终方法，不能覆盖重写（override）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void method()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：对于类和方法来说，abstract关键字和final关键字不能被同时使用，因为矛盾。</p><ul><li>因为子类是一定要覆盖重写抽象方法的！</li></ul><h3 id="9-3-final修饰局部变量"><a href="#9-3-final修饰局部变量" class="headerlink" title="9.3 final修饰局部变量"></a>9.3 final修饰局部变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">3</span>; <span class="comment">// 可以</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num;</span><br><span class="line">num = <span class="number">3</span>; <span class="comment">//可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> num2;java</span><br><span class="line">    num2 = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>正确写法：只要保证有唯一一次赋值即可</strong></li><li><strong>对于基本类型，不可变局势变量中的数据不可变</strong></li><li><strong>对于引用类型，不可以就是变量中的地址值不可变</strong></li></ul><h3 id="9-4-final修饰成员变量"><a href="#9-4-final修饰成员变量" class="headerlink" title="9.4 final修饰成员变量"></a>9.4 final修饰成员变量</h3><blockquote><p><strong>对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变</strong></p></blockquote><ul><li>由于成员变量具有默认值，所以<strong>用了final之后必须手动赋值，不会再给默认值！</strong></li><li><strong>对于final成员变量，要么直接赋值，要用使用构造方法赋值，二者择其一。</strong></li></ul><h3 id="PS-权限修饰符"><a href="#PS-权限修饰符" class="headerlink" title="PS 权限修饰符"></a>PS 权限修饰符</h3><p><strong>default 只能同一个类，或同一个包下的进行访问。不同包的，即便是子类也不能访问！</strong></p><h2 id="第十章-内部类"><a href="#第十章-内部类" class="headerlink" title="第十章 内部类"></a>第十章 内部类</h2><blockquote><p><strong>分为成员内部类和匿名内部类</strong></p></blockquote><h3 id="10-1-如何使用成员内部类"><a href="#10-1-如何使用成员内部类" class="headerlink" title="10.1 如何使用成员内部类"></a>10.1 如何使用成员内部类</h3><blockquote><p>内用外，随便访问；外用内，需要内部类对象。</p></blockquote><p>外部类定义一个方法，通过这个方法获取内部类的实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InClass <span class="title">getInClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接new出内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutClass.InClass inClass = <span class="keyword">new</span> OutClass().<span class="function">new <span class="title">InClass</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>内部类 外部类的成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Inner</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">syso(num);<span class="comment">// 内部类方法局部变量</span></span><br><span class="line">syso(<span class="keyword">this</span>.num);<span class="comment">// 内部类成员变量</span></span><br><span class="line">syso(Outer.<span class="keyword">this</span>.num);<span class="comment">//外部类成员变量 区分重名</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-如何使用局部内部类"><a href="#10-2-如何使用局部内部类" class="headerlink" title="10.2 如何使用局部内部类"></a>10.2 如何使用局部内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerSay</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;inner to say hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inner n = <span class="keyword">new</span> inner();</span><br><span class="line">    n.innerSay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>局部内部类访问所在方法的局部变量，那么这个局部变量必须是【有效final的】</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这样写是可以的。因为保证了num确实是不变的，final关键字是可以省略的【java8开始】。如果class前面加了一句num = 29，那就不对了，因为num改变了。*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么要这样做？</span></span><br><span class="line"><span class="comment">这是害怕类还在，局部变量缺消失了，导致局部内部类无法访问局部变量！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerSay</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;inner to say hello&quot;</span>+num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inner n = <span class="keyword">new</span> inner();</span><br><span class="line">    n.innerSay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原因：</span></span><br><span class="line"><span class="comment">    1.new出来的对象在堆内存中</span></span><br><span class="line"><span class="comment">    2.局部变量是跟着方法走的，在栈内存中</span></span><br><span class="line"><span class="comment">    3.方法运行结束后，立刻出栈，局部变量就会立刻消失</span></span><br><span class="line"><span class="comment">    4.但是new出来的对象会在堆中持续存在，直到垃圾回收消失。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerSay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;inner to say hello&quot;</span> + num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object test = test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>局部内部类的使用场景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当隐式的构造函数不能满足我们的需求，需要显示的构造函数时，使用局部内部类而非匿名内部类！</span></span><br><span class="line"><span class="comment">// 如果不考虑构造函数的问题，两者的功能是一样的。</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 局部内部类实现</span></span><br><span class="line">    <span class="function">Counter <span class="title">getCounter</span><span class="params">(<span class="keyword">final</span> String name)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LocalCounter</span> <span class="keyword">implements</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">LocalCounter</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">&quot;LocalCounter&quot;</span>); &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                <span class="keyword">return</span> count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalCounter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名内部类实现</span></span><br><span class="line">    <span class="function">Counter <span class="title">getCounter2</span><span class="params">(<span class="keyword">final</span> String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Counter() &#123;</span><br><span class="line">            <span class="comment">//只有一个默认的构造器。不能自行定义</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                <span class="keyword">return</span> count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalInnerClass in = <span class="keyword">new</span> LocalInnerClass();</span><br><span class="line">        Counter lucy = in.getCounter(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        Counter lucy2 = in.getCounter2(<span class="string">&quot;lucy2&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">            System.out.println(lucy.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">            System.out.println(lucy2.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-小结"><a href="#10-3-小结" class="headerlink" title="10.3 小结"></a>10.3 小结</h3><p>定义一个类的时候，权限修饰符规则</p><ul><li><strong>外部类： public or default</strong></li><li><strong>成员内部类： public protected default private</strong></li><li><strong>局部内部类： 什么都不能写！</strong></li></ul><h3 id="10-4-匿名内部类"><a href="#10-4-匿名内部类" class="headerlink" title="10.4 匿名内部类"></a>10.4 匿名内部类</h3><blockquote><p><strong>类只需要使用一次，那么可省略其定义！改而使用【匿名内部类】</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyInterface some = <span class="keyword">new</span> MyInterface()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">syso();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体例子</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoInnerPart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">testObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Object()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Override toString&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyInterface <span class="title">testObject2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;say hello!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>匿名内部类的注意事项</strong></p><ul><li>匿名内部类在创建对象的时候，只能使用唯一一次。</li><li>如果希望多次创建对象，而且类的内容一样的话，那么必须使用单独定义的实现类！</li></ul></li><li><p><strong>匿名内部类的使用场景</strong></p><ul><li>情况一： 接口、抽象类使用：相当于不用特意去写一个类去实现这个接口的方法，直接在实例化的时候就写好这个方法（接口、抽象类不能实例化，所以采用匿名内部类的方式来写）</li><li>情况二：当接口作为参数放在方法体里的时候，用new 接口()的方式来实例独享，则匿名内部类必须要实现这两个方法。</li></ul></li><li><p><strong>为什么需要内部类</strong></p></li></ul><blockquote><p>一般来说，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。</p></blockquote><blockquote><p>内部类最吸引人的原因是，每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。内部类允许继承多个非接口类型（类或抽象类）</p></blockquote><blockquote><p>个人认为允许多重继承的意思是，内部类对某个类进行重写再调用它的方法。让一个类可以同时使用两个类的特性。【继承一个类，内部类继承其他类，对必要方法进行重写！可以一个类为载体，内部使用多个内部类，从而实现多继承！】</p></blockquote><h4 id="10-5-内部类的继承"><a href="#10-5-内部类的继承" class="headerlink" title="10.5 内部类的继承"></a>10.5 内部类的继承</h4><p><strong>外部类继承另一个外部类的内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendInnerClass</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="comment">// public ExtendInnerClass()&#123;&#125; won&#x27;t compile  写这个构造会导致编译不成功</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtendInnerClass</span><span class="params">(WithInner w)</span></span>&#123;</span><br><span class="line">        w.<span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">        WithInner wi = <span class="keyword">new</span> WithInner();</span><br><span class="line">        ExtendInnerClass c = <span class="keyword">new</span> ExtendInnerClass(wi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内部类的覆盖</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">&quot;I am say1&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">&quot;I am walk&quot;</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendInnerClass2</span> <span class="keyword">extends</span> <span class="title">WithInner2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner2</span> <span class="keyword">extends</span> <span class="title">WithInner2</span>.<span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">&quot;I am say2&quot;</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExtendInnerClass2 class2 = <span class="keyword">new</span> ExtendInnerClass2();</span><br><span class="line">        Inner inner2 = <span class="keyword">new</span> ExtendInnerClass2().<span class="function">new <span class="title">Inner2</span><span class="params">()</span></span>;</span><br><span class="line">        inner2.say();   <span class="comment">// I am say2</span></span><br><span class="line">        inner2.walk(); <span class="comment">// I am walk</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h2><h3 id="11-1-Object"><a href="#11-1-Object" class="headerlink" title="11.1 Object"></a>11.1 Object</h3><ul><li><code>toString()方法</code></li><li><code>equals()方法</code><ul><li>注意，当需要比较对象时，覆写equals方法，以便于比较对象的大小。</li><li>当需要使用Arrays工具类进行大小比较时，需要继承Comparable。</li></ul></li></ul><h3 id="11-2-日期相关"><a href="#11-2-日期相关" class="headerlink" title="11.2 日期相关"></a>11.2 日期相关</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar采用了枚举，见名知意。可避免不必要的错误。似乎不常用，不学</span><br></pre></td></tr></table></figure><ul><li>日期类都采用单例模式？保证所有时间的一致？</li><li>不要求掌握的一些</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Calendar instance = Calendar.getInstance();</span><br><span class="line">    DateFormat dateInstance = DateFormat.getDateInstance(DateFormat.FULL);</span><br><span class="line">    System.out.println(dateInstance.format(<span class="keyword">new</span> Date())); <span class="comment">// 地理位置的判断？输出的中文？</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Testjava</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// G表示公元  字母大小写不能错，不知道为什么，无责任猜测，解析了字符串，提取的ascill码？</span></span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;Gyyyy MM dd&quot;</span>); <span class="comment">// 日期格式</span></span><br><span class="line">    System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Java8 提供的日期类 <strong>都是final修饰的</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Instant——它代表的是时间戳</span><br><span class="line"></span><br><span class="line">LocalDate——不包含具体时间的日期，比如2014-01-14。它可以用来存储生日，周年纪念日，入职日期等。</span><br><span class="line"></span><br><span class="line">LocalTime——它代表的是不含日期的时间</span><br><span class="line"></span><br><span class="line">LocalDateTime——它包含了日期及时间，不过还是没有偏移信息或者说时区。</span><br><span class="line"></span><br><span class="line">ZonedDateTime——这是一个包含时区的完整的日期时间，偏移量是以UTC/格林威治时间为基准的</span><br></pre></td></tr></table></figure><ul><li>Date仅仅含日期。不包含具体时间，有time的才有具体的时间（精确到时分秒）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//无时区</span></span><br><span class="line">    LocalDate now = LocalDate.now();</span><br><span class="line">    System.out.println(now); <span class="comment">// 2020-02-06</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> year = now.getYear();</span><br><span class="line">    <span class="keyword">int</span> month = now.getMonthValue();</span><br><span class="line">    Month monthE = now.getMonth();</span><br><span class="line">    <span class="keyword">int</span> day = now.getDayOfMonth();</span><br><span class="line">    System.out.println(<span class="string">&quot;year:&quot;</span>+year+<span class="string">&quot; month:&quot;</span>+month+<span class="string">&quot; day:&quot;</span>+day);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dayOfYear = now.getDayOfYear();</span><br><span class="line">    System.out.println(<span class="string">&quot;2020年的第&quot;</span>+dayOfYear+<span class="string">&quot;天&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    System.out.println(now);</span><br><span class="line">    LocalDateTime now2 = now.plusDays(<span class="number">10</span>);</span><br><span class="line">    System.out.println(now2);</span><br><span class="line"></span><br><span class="line">    LocalDateTime plus = now.plus(<span class="number">1</span>, ChronoUnit.YEARS);java</span><br><span class="line">    System.out.println(plus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>要用再查API</li><li>System类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Properties properties = System.getProperties(); <span class="comment">// 获取System的properties对象</span></span><br><span class="line">    Enumeration&lt;?&gt; enumeration = properties.propertyNames();<span class="comment">// 获得所有的key</span></span><br><span class="line">    <span class="keyword">while</span>(enumeration.hasMoreElements())&#123; <span class="comment">//是否还有元素</span></span><br><span class="line">        <span class="comment">// 安全的强转</span></span><br><span class="line">        Object c= enumeration.nextElement();</span><br><span class="line">        <span class="keyword">if</span>(c <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key:&quot;</span>+(String)c+<span class="string">&quot; ---value:&quot;</span>+System.getProperty((String)c));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object cc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>((cc = enumeration.nextElement()) <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key:&quot;</span>+(String)cc+<span class="string">&quot; ---javavalue:&quot;</span>+System.getProperty((String)cc));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">**回忆迭代器的元素遍历，回忆为什么迭代器遍历元素时可以进行元素移除的操作不会发生异常！**</span><br></pre></td></tr></table></figure><ul><li>arraycopy的使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] fromArray = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] toArray = &#123;<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      src      源数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      srcPos   源数组的其实位置 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      dest     目标数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      destPos  目标数组的开始位置</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      length   拷贝的长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    System.arraycopy(fromArray,<span class="number">1</span>,toArray,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;toArray.length ; i++) &#123;</span><br><span class="line">        System.out.println(toArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第十二章-集合框架"><a href="#第十二章-集合框架" class="headerlink" title="第十二章 集合框架"></a>第十二章 集合框架</h2><h3 id="0-引言（Think-in-Java-第11章-持有对象）"><a href="#0-引言（Think-in-Java-第11章-持有对象）" class="headerlink" title="0 引言（Think in Java 第11章 持有对象）"></a>0 引言（Think in Java 第11章 持有对象）</h3><blockquote><p><strong>Java容器类类库的用途是“保存对象”。可细分为单列集合，双列集合！</strong></p></blockquote><ul><li><p>Collection。一个独立元素序列</p></li><li><p>Map。一组成队的“键值对”对象，允许使用键来查找值</p></li><li><p>添加一组元素的 </p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; c = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>));</span><br><span class="line">    Integer []arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 这里需要Integer类型的数组！</span></span><br><span class="line">    Collection&lt;Integer&gt; c1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(arr)); </span><br><span class="line">    <span class="keyword">for</span> (Integer i: c)</span><br><span class="line">        System.out.print(i+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> ( Integer i: c1)</span><br><span class="line">        System.out.print(i+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Integer []array = &#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    Collection&lt;Integer&gt; coll = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(array));</span><br><span class="line">    System.out.println(coll.size());</span><br><span class="line">    coll.addAll(Arrays.asList(array));</span><br><span class="line">    System.out.println(coll.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可变长参数 自动装箱拆箱</span></span><br><span class="line">    Collections.addAll(coll,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">    System.out.println(coll.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Integer []array = &#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    Collection&lt;Integer&gt; coll = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(array));</span><br><span class="line">    Iterator&lt;Integer&gt; iterator = coll.iterator();</span><br><span class="line">    <span class="comment">//迭代器遍历</span></span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123; <span class="comment">// hasNext仅仅判断是否有元素</span></span><br><span class="line">        Integer next = iterator.next(); <span class="comment">// 依稀记得有指针后移的操作 后面补充</span></span><br><span class="line">        System.out.println(next);</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这节就一个核心观点，使用泛型，安全！强制类型转换时使用instanceof进行检测！</li></ul><h3 id="12-1-List集合"><a href="#12-1-List集合" class="headerlink" title="12.1 List集合"></a>12.1 List集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 不使用多态，便于测试特有的实现方法</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ArrayList初始化时有容量。默认10.当用到了一定比例的空间会自行进行扩充</span></span><br><span class="line"><span class="comment">         * 简而言之：可变长数组！</span></span><br><span class="line"><span class="comment">         * 如果存储空间不足，会扩大至原来大小的2倍</span></span><br><span class="line"><span class="comment">         * int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span></span><br><span class="line"><span class="comment">         * 看remove方法的代码，似乎没有发现明显的当用的空间不多时，对数组大小进行缩减！</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 可变长数组代码的策略</span></span><br><span class="line"><span class="comment">         *      长度不够时进行数组长度的扩充，创建一个新的，大小时原来2-3倍的，把数组copy进行曲</span></span><br><span class="line"><span class="comment">         *      所用的空间不多时，对数组长度进行缩减。创建一个新的长度小的数组，把oldValue复制进去</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      度的把握：用了2/3时就进行数组的扩充</span></span><br><span class="line"><span class="comment">         *               元素只剩1/3（好像是1/2）时才进行数组的缩减.缩减的策略比较保守</span></span><br><span class="line"><span class="comment">         *               主要是因为程序的局部性原理！</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">        list.add(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Integer i = <span class="number">10</span>;</span><br><span class="line">    list.remove(i);<span class="comment">// remove(Object o)  这个是对象。</span></span><br><span class="line">    <span class="comment">// list.remove(10); 这个识别成了 index 所以报错</span></span><br><span class="line">    System.out.println(list.size()); <span class="comment">// 0</span></span><br><span class="line">    list.set(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">    System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">    System.out.println(list.lastIndexOf(<span class="number">10</span>));</span><br><span class="line">    <span class="comment">// list.forEach(); 函数式编程 后期补充</span></span><br><span class="line">    <span class="comment">// list.equals() 对象比较时 记得按需求考虑是否重写对象的equals方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 可充当 队列 / 栈？</span></span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    list.offer(<span class="number">100</span>);</span><br><span class="line">    System.out.println(list.getLast()); <span class="comment">// 记单词 tail 尾部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">        <span class="comment">// 插入 begin stack后进先出FIFO</span></span><br><span class="line">        list.addFirst(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后进入的在head 故获取First</span></span><br><span class="line">    System.out.println(list.getFirst());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-2-Set集合"><a href="#12-2-Set集合" class="headerlink" title="12.2 Set集合"></a>12.2 Set集合</h3><blockquote><p><strong>set无重复元素</strong></p></blockquote><ul><li><code>TreeSet</code> 有序，红黑树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部使用的红黑树，我也不知道红黑树是啥</span></span><br><span class="line"><span class="comment">     * 二叉排序树 --&gt; AVL --&gt; 红黑树</span></span><br><span class="line"><span class="comment">     * 应该都满足，中序遍历结果是有序的！</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">        set.add((<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(set.size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : set)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>HashSet</code> 散列表，无序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">        <span class="comment">// 看不懂代码。不看了。知道散列表的基本写法就算了.</span></span><br><span class="line">        set.add((<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(set.size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : set)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对象之间用Set</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bbxx.list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类大小比较</span></span><br><span class="line"><span class="comment"> * 依据年龄 姓名进行比较</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Student&gt; set = <span class="keyword">new</span> TreeSet&lt;Student&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            set.add(<span class="keyword">new</span> Student(i+<span class="number">5</span>,i+<span class="string">&quot;s&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(<span class="keyword">new</span> Student(<span class="number">6</span>,<span class="keyword">null</span>));</span><br><span class="line">        <span class="keyword">for</span>(Student ss : set)&#123;</span><br><span class="line">            System.out.println(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 总结</span></span><br><span class="line"><span class="comment">         * TreeSet采用的红黑树。其应该是符合二叉排序树的性质。中序遍历是有序的。</span></span><br><span class="line"><span class="comment">         * 中序遍历为从小到大的顺序。所以是从小到大来输出。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * comparable的compareTo方法返回值的解释。</span></span><br><span class="line"><span class="comment">         * 返回正数表示大于。返回0等于，返回负数表示小于!</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 查看TreeSet add的源码试试 发现 看不懂！</span></span><br><span class="line"><span class="comment">         * 采取代码测试</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Student obj1 = <span class="keyword">new</span> Student(<span class="number">6</span>, <span class="string">&quot;kkx&quot;</span>);</span><br><span class="line">        Student obj2 = <span class="keyword">new</span> Student(<span class="number">6</span>, <span class="string">&quot;kkx1&quot;</span>);</span><br><span class="line">        Student obj3 = <span class="keyword">new</span> Student(<span class="number">7</span>, <span class="string">&quot;kkx3&quot;</span>);</span><br><span class="line">        Student obj4 = <span class="keyword">new</span> Student(<span class="number">8</span>, <span class="string">&quot;kkx1&quot;</span>);</span><br><span class="line">        <span class="comment">// -1 如果是表示小于那么set集合的输出顺序是obj1在前</span></span><br><span class="line">        System.out.println(obj1.compareTo(obj2));</span><br><span class="line">        set.clear();</span><br><span class="line">        set.add(obj1);</span><br><span class="line">        set.add(obj2);</span><br><span class="line">        <span class="comment">//测试结果表明 的确是小于。</span></span><br><span class="line">        <span class="keyword">for</span>(Student ss : set)&#123;</span><br><span class="line">            System.out.println(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 总结：</span></span><br><span class="line"><span class="comment">         *  comparable的compareTo方法返回值的解释。</span></span><br><span class="line"><span class="comment">         *   返回正数表示大于。返回0等于，返回负数表示小于!</span></span><br><span class="line"><span class="comment">         *   obj1.compareTo(obj2) 比较1 和 2的大小。返回正数则 obj1大</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方便操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(age, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Object obj;</span><br><span class="line">        <span class="comment">// 不属于该类</span></span><br><span class="line">        <span class="keyword">if</span> (!((obj = o) <span class="keyword">instanceof</span> Student)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对象错误&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        o = (Student) o;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.equals(o)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 优先通过年龄判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; ((Student) o).age) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 其次通过姓名判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age == ((Student) o).age) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.name==<span class="keyword">null</span> &amp;&amp; ((Student) o).name==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.name == <span class="keyword">null</span> &amp;&amp; ((Student) o).name!=<span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="keyword">this</span>.name.compareTo(((Student) o).name);</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-3-Map集合"><a href="#12-3-Map集合" class="headerlink" title="12.3 Map集合"></a>12.3 Map集合</h3><blockquote><p><strong>常用的有 <code>HashMap</code>和<code>TreeMap</code></strong></p></blockquote><ul><li><p><code>HashMap</code>相关</p><ul><li>基本原理：<code>Java1.8</code>后是 红黑树+散列表。最开始是散列表的拉链法，链长度超过八是链转为红黑树！</li><li><code>HashMap</code>的key可以存入null**</li><li>基本操作：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// map的存储 遍历  指定泛型，安全</span></span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>,<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    map.put(<span class="number">12</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    map.put(<span class="number">13</span>,<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    map.put(<span class="number">1</span>,<span class="string">&quot;DD&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map的基本遍历有两种方式</span></span><br><span class="line">    <span class="comment">// 先获取所有的key  @return a set view of the keys contained in this map</span></span><br><span class="line">    Set set = map.keySet();</span><br><span class="line">    Iterator iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(map.get(iterator.next()));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;*************华丽的分割线*************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @return a set view of the mappings contained in this map</span></span><br><span class="line">    <span class="comment">// 记不清就点进去看他的返回值回忆具体操作</span></span><br><span class="line">    Set set1 = map.entrySet();</span><br><span class="line">    Iterator iterator1 = set1.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator1.hasNext())&#123;</span><br><span class="line">        <span class="comment">// Map.Entry&lt;Integer, String&gt; 内部接口</span></span><br><span class="line">        Map.Entry&lt;Integer, String&gt; next = (Map.Entry&lt;Integer, String&gt;)iterator1.next();</span><br><span class="line">        System.out.println(next.getKey()+<span class="string">&quot;==&quot;</span>+next.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>PS</strong>：开始没必要学太细，第17章有深入理解集合的内容！</p><p><strong><code>HashMap</code>对象的key、value值均可为null。且<code>HashMap</code>是线程不安全的</strong></p><p><strong><code>HahTable</code>对象的key、value值均不可为null。且<code>HashTable</code>是线程安全的</strong>，put方法用synchronized锁了！好多方法也用synchronized锁了。如remove这些方法！</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Hashtable&lt;Integer, String&gt; table = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="comment">// 测试时 发现 key也不能为null，key为null时，没有对应的处理策略</span></span><br><span class="line">    table.put(<span class="keyword">null</span>,<span class="string">&quot;ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map的存储 遍历  指定泛型，安全</span></span><br><span class="line">    HashMap map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>,<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    map.put(<span class="number">12</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    map.put(<span class="number">13</span>,<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    map.put(<span class="number">1</span>,<span class="string">&quot;DD&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果key为null时有处理策略的 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span></span><br><span class="line">    map.put(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>TreeMap</code>基本内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 盲猜 TreeMap的key有二叉排序树的性质 中序遍历为从小到大 内部采用的红黑树。</span></span><br><span class="line">    <span class="comment">// 暂时用二叉排的性质去理解。</span></span><br><span class="line">    <span class="comment">// String 内部的排序 比较的时ASCII码值 Unicode包含ASCII的所有码值</span></span><br><span class="line">    TreeMap&lt;String, String&gt; map = <span class="keyword">new</span> TreeMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;B123B&quot;</span>,<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;23BB&quot;</span>,<span class="string">&quot;DD&quot;</span>);</span><br><span class="line">    Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = entries.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, String&gt; next = iterator.next();</span><br><span class="line">        <span class="comment">// 有时候不用泛型 代码返回值就是舒服</span></span><br><span class="line">   System.out.println(next.getKey()+<span class="string">&quot;:&quot;</span>+next.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Properties集合</p><blockquote><p><code>HashTable</code>的子类。常用于存储一些配置信息。回忆<code>properties</code>文件，好像是的。还有一个properties流？果不其然，有load方法传入的对象是输入流！</p></blockquote><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">// 仅仅可以为String，应该是专门为配置文件所产生的一个map</span></span><br><span class="line">    properties.setProperty(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;kkx&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    Set&lt;Map.Entry&lt;Object, Object&gt;&gt; entries = properties.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;Object, Object&gt;&gt; iterator = entries.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;Object, Object&gt; next = iterator.next();</span><br><span class="line">        System.out.println(next.getKey()+<span class="string">&quot;:&quot;</span>+next.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    Runtime runtime = Runtime.getRuntime();java</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="12-4-集合工具类"><a href="#12-4-集合工具类" class="headerlink" title="12.4 集合工具类"></a>12.4 集合工具类</h3><p>集合工具类 Collections：排序、复制、翻转等操作</p><p>数据工具类 Arrays：排序、复制、翻转等操作，Arrays.sort(数组)</p><p>排序默认是字典顺序，从小到大。</p><blockquote><p><strong>Collections</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collections.max(list);</span><br><span class="line">Collections.min(list);</span><br><span class="line">Collections.binarySearch(list,find_value);</span><br><span class="line">Collections.shuffle(list); <span class="comment">// 洗牌，打乱数据的顺序</span></span><br><span class="line">Collections.reverse(list); <span class="comment">// 反转</span></span><br><span class="line">Collections.swap(list,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">// 2  3 位置的数据交换</span></span><br><span class="line">Collections.replaceAll(list,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;A&quot;</span>); <span class="comment">// 所有小写a替换成大写A</span></span><br><span class="line">Collections.fill(list,<span class="string">&quot;h&quot;</span>); <span class="comment">// 全部填充为h</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Arrays</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与Collections没什么区别</span></span><br></pre></td></tr></table></figure><h3 id="12-5-比较器"><a href="#12-5-比较器" class="headerlink" title="12.5 比较器"></a>12.5 比较器</h3><p>用户自定义对象需要排序的话就需要比较器了~</p><p>自定义比较器：</p><ul><li>Comparable：内部比较器，需要修改被比较的对象Person</li><li>Comparator：外部比较器，不需要修改被比较的对象Person</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部比较器</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回值</span></span><br><span class="line"><span class="comment">    1  正数 当前对象大 [降序，怎么理解，，，]</span></span><br><span class="line"><span class="comment">    0  一样大</span></span><br><span class="line"><span class="comment">    -1 负数 当前对象小，传入的对象大</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    这样记忆吧。假设当前对象位置是0。</span></span><br><span class="line"><span class="comment">    当前对象大，返回1，新对象就在1了，降序，就是大--&gt;小</span></span><br><span class="line"><span class="comment">    当前对象小，返回-1，那么新对象就插在-1处，就是：小--&gt;大</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>思路：将比较的对象（Person）实现Comparable接口，重写compareTo方法，在该方法内写比较的逻辑。重点返回值是：-1，0，1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部比较器，无侵入性，传给集合</span></span><br><span class="line"><span class="comment">// 这种没必要记，写个demo测一下就可以了~~~</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myxx</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1,Object o2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 强转</span></span><br><span class="line">        <span class="keyword">return</span> s1.age - s2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第十三章-异常"><a href="#第十三章-异常" class="headerlink" title="第十三章 异常"></a>第十三章 异常</h2><h2 id="第十四章-注解"><a href="#第十四章-注解" class="headerlink" title="第十四章 注解"></a>第十四章 注解</h2><h2 id="第十五章-IO流"><a href="#第十五章-IO流" class="headerlink" title="第十五章 IO流"></a>第十五章 IO流</h2><blockquote><p>IO流可大致分为字节流和字符流。字节是按字节进行输入输出的，适用于各种文件。字符流是按字符进行输入输出的，适用于文本文件。</p></blockquote><blockquote><p><strong>IO流文件的创建读取，采用相对路径是以当前项目为基准的！</strong></p></blockquote><ul><li>输入流：其他地方向内存中输入。     xx—&gt;内存</li><li>输出流：从内存中输出到其他地方。 内存—&gt;其他</li></ul><h3 id="15-1-字节流"><a href="#15-1-字节流" class="headerlink" title="15.1 字节流"></a>15.1 字节流</h3><p>无论何种文件，都是以二进制（字节）的形式存储在计算机中。可操作Computer中的任何文件。</p><p><strong>字节流通常以<code>InputStream</code>或<code>OutputStream</code>结尾</strong></p><h4 id="15-1-1-文件的输入（读取文件）"><a href="#15-1-1-文件的输入（读取文件）" class="headerlink" title="15.1.1 文件的输入（读取文件）"></a>15.1.1 文件的输入（读取文件）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 通过类加载器获得classpath下的文件（就是src目录下的文件）</span></span><br><span class="line">    InputStream in1 = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    InputStream in2 = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\xx\\JavaDay08( IO )\\src\\test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 断言是否为空 不为空 说明找到了文件</span></span><br><span class="line">    Assert.assertNotNull(in2);</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((b = in1.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>)b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关于文件的路径问题</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、对于File类构造方法，他需要的传入的是一个“路径名字符串”，而并不是一个单纯的文件名，对吧兄弟。</span><br><span class="line"></span><br><span class="line">2、对于jvm来说，在classloader加载时候，你所以存放的d.txt也会随classloader进行加载，因此他们属于同级目录。</span><br><span class="line"></span><br><span class="line">3、如果楼主真心想采用d.txt来读取的话。可以使用classloader加载原理来读取。</span><br><span class="line"></span><br><span class="line">此方法需要注意，静态方法（通过当前的classloader加载的类来获取当前d.txt被加载的路径）</span><br></pre></td></tr></table></figure><h4 id="15-1-2-文件的输出（写入）"><a href="#15-1-2-文件的输出（写入）" class="headerlink" title="15.1.2 文件的输出（写入）"></a>15.1.2 文件的输出（写入）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 只写文件是默认创建在与src同级目录。就是a.txt的目录和src同级</span></span><br><span class="line">    FileOutputStream fos1 = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 写绝对路径的话</span></span><br><span class="line">    FileOutputStream fos2 = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E://a.txt&quot;</span>);</span><br><span class="line">    String str = <span class="string">&quot;!23&quot;</span>;</span><br><span class="line">    <span class="comment">// 直接写一个字节数组</span></span><br><span class="line">    fos1.write(str.getBytes());</span><br><span class="line">    <span class="comment">// 一个一个字节写</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">        fos2.write(bytes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 追加写入</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn3</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// public FileOutputStream(String name, boolean append) append = true 追加写入</span></span><br><span class="line">    FileOutputStream fio = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;aaaa.txt&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    fio.write(<span class="string">&quot;liujiawei&quot;</span>.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-1-3-文件的复制"><a href="#15-1-3-文件的复制" class="headerlink" title="15.1.3 文件的复制"></a>15.1.3 文件的复制</h4><ul><li>获取输入流，将内容读入内存</li><li>获取输出流，将读入的内容写到磁盘</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn4</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建输入流 准备读入文件</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E://note.docx&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 创建输出流 准备写文件到外存</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copyNote.docx&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 逐步将读到的文件 写到外存</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((b = fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">        fos.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">    fis.close();</span><br><span class="line">    fos.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn5</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 加强版，依次读一串。</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E://note.docx&quot;</span>);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copy2Note.docx&quot;</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> read = fis.read(bytes);</span><br><span class="line">    <span class="keyword">while</span>((read = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        fos.write(bytes,<span class="number">0</span>,bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line">    fis.close();</span><br><span class="line">    fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-1-4-字节缓冲流"><a href="#15-1-4-字节缓冲流" class="headerlink" title="15.1.4 字节缓冲流"></a>15.1.4 字节缓冲流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn6</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 字节缓冲流 看源码可以知道 bf默认有一个8192的字节数组。</span></span><br><span class="line">    <span class="comment">// bis读取时一次读取8192字节</span></span><br><span class="line">    <span class="comment">// bos 写入时 write(len) 写入指定长度的数据。 bis的buff字节数组用volatile修饰了，应该是给当前线程的xx</span></span><br><span class="line">    <span class="comment">// 查看资源用的，bos写入时好获得要写入的字节数组</span></span><br><span class="line">    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E://note.docx&quot;</span>));</span><br><span class="line">    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;note3.docx&quot;</span>));</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len = bis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">        bos.write(len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-2-字符流"><a href="#15-2-字符流" class="headerlink" title="15.2 字符流"></a>15.2 字符流</h3><ul><li>为什么出现字符流？</li></ul><blockquote><p>有些是好几个字节组成一个字符，一个一个字节读，输出的数据可能不对！文件的复制时，由于是连续的操作，所以没出现问题！（同时，一个一个字节的读取，写入，频繁的进行系统调用，在申请调用上太费时了。）</p></blockquote><ul><li>小例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn7</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Properties properties = System.getProperties();</span><br><span class="line">    Enumeration&lt;?&gt; enumeration = properties.propertyNames();</span><br><span class="line">    <span class="keyword">while</span> (enumeration.hasMoreElements())&#123;</span><br><span class="line">        String o = (String) enumeration.nextElement();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到当前系统的默认编码格式 得到的是UTF-8</span></span><br><span class="line">    System.out.println(System.getProperty(<span class="string">&quot;file.encoding&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn8</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;详细信息显示&quot;</span>;</span><br><span class="line">    <span class="comment">//using the platform&#x27;s default charset</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line">    <span class="keyword">byte</span>[] bytess = str.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    <span class="comment">// U8</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;bytes.length ; i++) &#123;</span><br><span class="line">        System.out.print(bytes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;\r\n&quot;</span>+<span class="string">&quot;*****************&quot;</span>);</span><br><span class="line">    <span class="comment">// GBK</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;bytess.length ; i++) &#123;</span><br><span class="line">        System.out.print(bytess[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>字符流 = 字节流 + 编码表</strong></p></blockquote><blockquote><p>用字节流复制文本文件时，文本文件的中文没有问题。原因是最终底层操作会自动进行字节拼接成中文，如何识别中文呢？</p></blockquote><blockquote><p>汉字在存储时，无论时那种编码存储，第一个字节都是负数！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码验证</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn9</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\Eclipse_javaee_workspace\\JavaSE\\JavaDay08( IO )\\src\\test.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fisRead = fis.read();</span><br><span class="line">    fis.close();</span><br><span class="line">    System.out.println((<span class="keyword">char</span>)fisRead+<span class="string">&quot;:&quot;</span>+fisRead); <span class="comment">// 乱码 ä:228</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;**************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\Eclipse_javaee_workspace\\JavaSE\\JavaDay08( IO )\\src\\test.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">int</span> readerRead = reader.read();</span><br><span class="line">    System.out.println((<span class="keyword">char</span>)readerRead+<span class="string">&quot;:&quot;</span>+readerRead);<span class="comment">// 不乱码 中:20013</span></span><br><span class="line"></span><br><span class="line">    reader.close();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">20013</span>; <span class="comment">//</span></span><br><span class="line">    System.out.println((<span class="keyword">char</span>)i);<span class="comment">// 输出“中”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>汉字的码值很大！字节流的返回值在-1到255直接，无法正确识别大的数值。</li></ul><h4 id="15-2-1-字符流的输出（写入文本文件）"><a href="#15-2-1-字符流的输出（写入文本文件）" class="headerlink" title="15.2.1 字符流的输出（写入文本文件）"></a>15.2.1 字符流的输出（写入文本文件）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;charTest.txt&quot;</span>));</span><br><span class="line">    osw.write(<span class="number">97</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  cbuf  Buffer of characters</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  off   Offset from which to start writing characters</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  len   Number of characters to write 写入的数据的数目 写len个</span></span><br><span class="line"><span class="comment">     * 其他的大同小异 不赘述</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">char</span>[] ch = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>&#125;;</span><br><span class="line">    osw.write(ch,<span class="number">5</span>,<span class="number">2</span>);</span><br><span class="line">    osw.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn9</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    String absolutePath = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>).getAbsolutePath();</span><br><span class="line">    System.out.println(absolutePath);<span class="comment">//</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * E:\Eclipse_javaee_workspace\JavaSE\JavaDay08(IO)\. 打印当前文件的路径。</span></span><br><span class="line"><span class="comment">     * 如果用 new FileInputStream(&quot;test.txt&quot;) 他是从    E:\Eclipse_javaee_workspace\JavaSE\JavaDay08(IO)\.这里找！</span></span><br><span class="line"><span class="comment">     * 而test.txt实际在E:\Eclipse_javaee_workspace\JavaSE\JavaDay08(IO)\src\test.txt</span></span><br><span class="line"><span class="comment">     * 路径不一致，所以找部分指定文件！</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\Eclipse_javaee_workspace\\JavaSE\\JavaDay08(IO)\\src\\test.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fisRead = fis.read();</span><br><span class="line">    fis.close();</span><br><span class="line">    System.out.println((<span class="keyword">char</span>)fisRead+<span class="string">&quot;:&quot;</span>+fisRead); <span class="comment">// 乱码 ä:228</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;**************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\Eclipse_javaee_workspace\\JavaSE\\JavaDay08(IO)\\src\\test.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">int</span> readerRead = reader.read();</span><br><span class="line">    System.out.println((<span class="keyword">char</span>)readerRead+<span class="string">&quot;:&quot;</span>+readerRead);<span class="comment">// 不乱码 中:20013</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>获取src下的文件请用类加载器进行加载！</strong></p></blockquote><h4 id="15-2-2-字符流的输入（读取到内存）"><a href="#15-2-2-字符流的输入（读取到内存）" class="headerlink" title="15.2.2 字符流的输入（读取到内存）"></a>15.2.2 字符流的输入（读取到内存）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn3</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    FileReader r = <span class="keyword">new</span> FileReader(<span class="string">&quot;charTest.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> read = r.read();</span><br><span class="line">    System.out.println(read);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-3-字符缓冲流的使用"><a href="#15-3-字符缓冲流的使用" class="headerlink" title="15.3 字符缓冲流的使用"></a>15.3 字符缓冲流的使用</h4><blockquote><p><strong>与字节缓冲流类似，也是用到了装饰模式，且内部有一个8192大小的数组（不过是char数组）</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 读文本到内存中</span></span><br><span class="line">    BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;bw.txt&quot;</span>));</span><br><span class="line">    bw.write(<span class="string">&quot;hwllo woafasdfs&quot;</span>);</span><br><span class="line">    bw.newLine();</span><br><span class="line">    bw.write(<span class="string">&quot;asfhashfasfhoihasff&quot;</span>);</span><br><span class="line">    bw.newLine();</span><br><span class="line">    bw.flush();</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;bw.txt&quot;</span>));</span><br><span class="line">    System.out.println(br.readLine());</span><br><span class="line">    bw.close();</span><br><span class="line">    br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-3-File类概述"><a href="#15-3-File类概述" class="headerlink" title="15.3 File类概述"></a>15.3 File类概述</h3><h4 id="15-3-1-概述"><a href="#15-3-1-概述" class="headerlink" title="15.3.1 概述"></a>15.3.1 概述</h4><blockquote><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 </p></blockquote><p><strong>注意：</strong></p><p><strong>一个点 . 表示当前目录</strong></p><p><strong>两个点  .. 表示上一级目录</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File fil = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">System.out.println(fil.isDirectory() + <span class="string">&quot;:&quot;</span>+fil.getAbsolutePath());</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">System.out.println(file.isDirectory()+<span class="string">&quot;:&quot;</span>+file.getAbsolutePath());</span><br></pre></td></tr></table></figure><ul><li>要求<ul><li>梳理File的基本操作</li><li>遍历指定目录的所有文件（单级）</li><li>遍历指定目录的所有文件（多级）</li><li>复制单级目录文件</li><li>复制多级目录文件</li><li><code>JDK7</code>的异常处理</li></ul></li><li>File的基本操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* File概述 及其基本操作</span></span><br><span class="line"><span class="comment">* Java文件类以抽象的方式代表文件名和目录路径名。该类主要用于文件和目录的创建、文件的查找和文件的删除等。</span></span><br><span class="line"><span class="comment">* File对象代表磁盘中实际存在的文件和目录。OS中文件和目录似乎是一个性质。Linux中将目录看作一种特殊的文件</span></span><br><span class="line"><span class="comment">*      回忆FCB 及其处理策略（OS）</span></span><br><span class="line"><span class="comment">*      回忆文件的存储方式（OS）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 与IO流一致，默认为相对路径。</span></span><br><span class="line">    File file= <span class="keyword">new</span> File(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists()) file.createNewFile();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// E:\Eclipse_javaee_workspace\JavaSE\JavaDay08( IO )\file.txt</span></span><br><span class="line">    System.out.println(file.getAbsolutePath()); </span><br><span class="line">    System.out.println(file.isAbsolute()); <span class="comment">// false</span></span><br><span class="line">    System.out.println(file.isDirectory()); <span class="comment">// false</span></span><br><span class="line">    System.out.println(file.isFile());  <span class="comment">// true</span></span><br><span class="line">    System.out.println(file.toString());<span class="comment">// file.txt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历指定目录的所有文件（单级别目录）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历单级文件夹下的所有文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// E:\Eclipse_javaee_workspace\JavaSE\JavaDay08( IO )</span></span><br><span class="line">    System.out.println(file.getAbsolutePath());</span><br><span class="line">    System.out.println(file.isDirectory());<span class="comment">// false</span></span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="comment">// E:\Eclipse_javaee_workspace\JavaSE\JavaDay08( IO )\.</span></span><br><span class="line">    System.out.println(file2.getAbsolutePath());</span><br><span class="line">    System.out.println(file2.isDirectory());<span class="comment">// true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">    String[] list = file2.list();</span><br><span class="line">    <span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历指定目录的所有文件（多级）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 遍历指定文件夹下的所有文件。仅输出文件名称+文件绝对路径</span></span><br><span class="line"><span class="comment">* 递归</span></span><br><span class="line"><span class="comment">* 遇到目录就继续访问</span></span><br><span class="line"><span class="comment">* 遇到文件就打印输出</span></span><br><span class="line"><span class="comment">* 递归的判断条件是是否为目录</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得单曲目录 即项目名的目录 xxx\JavaSE\JavaDay08( IO )\.</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    getAllFile(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(file == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">if</span>(files == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (File tempFile : files) &#123;</span><br><span class="line">        <span class="comment">// 不存在传入null</span></span><br><span class="line">        <span class="keyword">if</span> (tempFile.isDirectory()) &#123;</span><br><span class="line">            getAllFile(tempFile);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;fileName = &quot;</span> + tempFile.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复制单级目录文件<ul><li>找到源文件</li><li>找到目的地，目的地不存在则创建</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    File dest = <span class="keyword">new</span> File(<span class="string">&quot;E:\\copyTemp&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!dest.exists()) dest.mkdirs();</span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">for</span> (File tempFile : files) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tempFile.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// 执行复制操作</span></span><br><span class="line">            copyFile(<span class="keyword">new</span> File(file,tempFile.getName()), <span class="keyword">new</span> File(dest, tempFile.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src  源文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest 目的文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(File src, File dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(src));</span><br><span class="line">         BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(dest));) &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b);</span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复制多级目录<ul><li>递归遍历源文件夹</li><li>当遇到文件时则进行复制</li><li>遇到文件夹时则继续遍历</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1.遍历源文件。</span></span><br><span class="line"><span class="comment">*      遍历过程中，如果遇到的是文件夹，则在dest创建对应的文件夹</span></span><br><span class="line"><span class="comment">*      遇到的是文件，则在dest创建对应的文件。</span></span><br><span class="line"><span class="comment">*      注意路径的保存</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn7</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;E://copy2&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file1.exists()) file1.mkdirs();</span><br><span class="line">    copy(file,file1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(File src, File dest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File[] files = src.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (files == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (File temp : files) &#123;</span><br><span class="line">        String curName = temp.getName();</span><br><span class="line">        <span class="keyword">if</span> (temp.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// 如果是目录 则创建 创建后递归遍历</span></span><br><span class="line">            File file = copyDirectory(dest, curName);</span><br><span class="line">            copy(<span class="keyword">new</span> File(src,curName),file);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 是文件则复制文件，该层递归结束</span></span><br><span class="line">            copyFile(<span class="keyword">new</span> File(src, curName), <span class="keyword">new</span> File(dest, curName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> File <span class="title">copyDirectory</span><span class="params">(File dest, String curName)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(dest, curName);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists()) file.mkdir();</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>jdk7</code>的异常处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(File src, File dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(src));</span><br><span class="line">         BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(dest));) &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b);</span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-4-标准输入输出流"><a href="#15-4-标准输入输出流" class="headerlink" title="15.4 标准输入输出流"></a>15.4 标准输入输出流</h3><h4 id="15-4-1-标准输入流"><a href="#15-4-1-标准输入流" class="headerlink" title="15.4.1 标准输入流"></a>15.4.1 标准输入流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = System.in;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 模拟Scanner读入一个char 读入String</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 只能安全键盘录入字节</span></span><br><span class="line">    InputStream in = System.in;</span><br><span class="line">    <span class="comment">// 转换流 装饰模式</span></span><br><span class="line">    InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">    <span class="comment">// -1 到 0xFFFF</span></span><br><span class="line">    <span class="keyword">int</span> read = isr.read();</span><br><span class="line">    <span class="comment">// 可以安全地读入一个中文</span></span><br><span class="line">    System.out.println((<span class="keyword">char</span>)read);</span><br><span class="line">    <span class="comment">// 读一个串地话，自己设置char数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-4-2-标准输出流"><a href="#15-4-2-标准输出流" class="headerlink" title="15.4.2 标准输出流"></a>15.4.2 标准输出流</h4><blockquote><p><strong>客户端的输入内容，直接写入文本？？！！重定向牛批</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PrintStream out = System.out;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 标准输入流的重定向</span></span><br><span class="line"><span class="comment">* 从键盘输入 打印到文本中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    PrintStream printStream = <span class="keyword">new</span> PrintStream(<span class="string">&quot;target.txt&quot;</span>);</span><br><span class="line">    System.setOut(printStream);</span><br><span class="line">    String str = <span class="string">&quot;999&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(!str.equals(<span class="string">&quot;exit&quot;</span>))&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        str = sc.next();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-4-打印流-用于写入数字，写入对象哈希值什么的"><a href="#15-4-打印流-用于写入数字，写入对象哈希值什么的" class="headerlink" title="15.4 打印流====用于写入数字，写入对象哈希值什么的"></a>15.4 打印流====用于写入数字，写入对象哈希值什么的</h3><h4 id="15-4-1-字节打印流"><a href="#15-4-1-字节打印流" class="headerlink" title="15.4.1 字节打印流"></a>15.4.1 字节打印流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PrintStream</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn6</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xxx.txt&quot;</span>),<span class="keyword">true</span>);</span><br><span class="line">    ps.println(<span class="number">99</span>);</span><br><span class="line">    ps.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-4-2-字符打印流"><a href="#15-4-2-字符打印流" class="headerlink" title="15.4.2 字符打印流"></a>15.4.2 字符打印流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 字符打印流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn4</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;a.x&quot;</span>));</span><br><span class="line">    printWriter.write(<span class="number">99</span>);</span><br><span class="line">    printWriter.close();</span><br><span class="line">    <span class="comment">// 不刷新看一看</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn5</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// true 调用 print println时自动刷新 而且写入的时99 不进行转型（char）99 也可以写入对象？</span></span><br><span class="line">    PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;a.txt&quot;</span>),<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 写入数字</span></span><br><span class="line">    printWriter.println(<span class="number">99</span>);</span><br><span class="line">    <span class="comment">// 写入对象的哈希值</span></span><br><span class="line">    printWriter.println(<span class="keyword">new</span> Object());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-5-其他流对象"><a href="#15-5-其他流对象" class="headerlink" title="15.5 其他流对象"></a>15.5 其他流对象</h3><h4 id="15-5-1-对象序列化"><a href="#15-5-1-对象序列化" class="headerlink" title="15.5.1 对象序列化"></a>15.5.1 对象序列化</h4><ul><li>用于将不常用的又不能销毁的对象存入文本，要用时在从文本读取。可以节约内存？</li><li>类想要被序列化需要实现**<code>Serializable</code>**接口</li><li>类的个别字段不想被序列化的话使用<strong>transient</strong>关键字</li><li>若因为类进行了更改导致反序列化失败，如何解决？<ul><li>定义一个<code>private static final long serialVersionUID = -6849794470754660L;</code>进行是否是同一个类的判断</li><li>无责任猜测：应该是计算了类的信息指纹，用信息指纹的比较来判断是否是同一个类。【密码学】</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 测试序列化流的基本方法</span></span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;objectDemo.txt&quot;</span>));</span><br><span class="line">    oos.writeObject(<span class="keyword">new</span> Student(<span class="string">&quot;hello1&quot;</span>,<span class="number">52</span>));</span><br><span class="line">    oos.writeObject(<span class="keyword">new</span> Student(<span class="string">&quot;hello2&quot;</span>,<span class="number">52</span>));</span><br><span class="line">    oos.writeObject(<span class="keyword">new</span> Student(<span class="string">&quot;hello3&quot;</span>,<span class="number">52</span>));</span><br><span class="line">    oos.flush();</span><br><span class="line">    oos.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取序列化对象</span></span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;objectDemo.txt&quot;</span>));</span><br><span class="line">    Student o = (Student) ois.readObject();</span><br><span class="line">    System.out.println(o.toString());</span><br><span class="line">    ois.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果对象被更改了，能否再次正确读出？ 无法正确读出！！</span></span><br><span class="line"><span class="comment">// 怎么办？ 使用private static final long serialVersionUID = -6849794470754660L; 标识是否是同一个对象</span></span><br><span class="line"><span class="comment">// 不仅识别了，多余的方法还可以调用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;objectDemo.txt&quot;</span>));</span><br><span class="line">    Student o = (Student) ois.readObject();</span><br><span class="line">    Object o1 = ois.readObject();</span><br><span class="line">    Object o2 = ois.readObject();java</span><br><span class="line">        <span class="comment">// 应该报错吧</span></span><br><span class="line">        Object o3 = ois.readObject();</span><br><span class="line">    o.say();</span><br><span class="line">    System.out.println(o.toString());</span><br><span class="line">    ois.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754660L</span>;</span><br><span class="line">    <span class="comment">// 不想被序列化的字段用transient</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是多余的方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-5-2-Properties与IO流的结合"><a href="#15-5-2-Properties与IO流的结合" class="headerlink" title="15.5.2 Properties与IO流的结合"></a>15.5.2 Properties与IO流的结合</h4><ul><li>用于配置文件，防止硬编码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Properties与IO流的结合使用</span></span><br><span class="line"><span class="comment"> *  之前看他的方法 发现有传入IO对象的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 存入数据！  想一想数据库连接池的配置文件，就是这么个意思。防止硬编码。</span></span><br><span class="line">        <span class="comment">// 我真是个小天才</span></span><br><span class="line">        Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">        p.setProperty(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line">        p.setProperty(<span class="string">&quot;jdbc&quot;</span>,<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        p.store(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;PropertiesDemo.properties&quot;</span>),<span class="string">&quot;无备注&quot;</span>);</span><br><span class="line"></span><br><span class="line">        p.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;PropertiesDemo.properties&quot;</span>));</span><br><span class="line">        String name = p.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第十六章-线程"><a href="#第十六章-线程" class="headerlink" title="第十六章 线程"></a>第十六章 线程</h2><blockquote><p><strong>进程与线程的概念，看操作系统课本！看以前做的笔记，画的思维导图。</strong></p></blockquote><ul><li><p>多线程的实现方式</p><ul><li>继承Thread类</li><li>实现Runnable接口</li></ul></li><li><p>线程调度模型</p><ul><li>分时调度模型：所有线程轮流使用CPU使用权，平均分配每个线程占用CPU的时间（RR）</li><li>抢占式调度模型：优先让优先级高的线程使用CPU，优先级相同则随机选取一个。优先级高的线程获取CPU的时间更多。</li><li>我记得操作系统里有一个调度模型：<strong>找书看一下 “多级反馈队列”</strong> <strong>汤子瀛 P94</strong></li></ul></li><li><p>线程优先级的设置</p><ul><li><code>getPriority()</code>获得此线程的优先级</li><li><code>setPriority()</code>更改此线程的优先级</li><li>优先级高，仅仅代表获取<code>cpu</code>的几率高！回忆OS防止进程饥饿！</li></ul></li><li><p>线程控制</p><ul><li><code>sleep(long millis)</code>：使当前正在执行的线程暂停<code>millis</code>毫秒</li><li>join()：等待这个线程死亡。<code>A.join(),</code>只有A这个线程执行完毕后，后面的代码/线程才会执行</li><li><strong><code>setDaemon(boolean on)</code>：将线程标记为守护线程，当运行的线程为守护线程是，Java虚拟机将退出【其他线程执行完毕后，如果剩下的都是守护线程，则<code>jvm</code>不会等待守护线程执行完，会直接退出！】</strong></li></ul></li><li><p>线程同步</p><ul><li>回忆OS的<code>pv</code>操作！</li><li>线程同步案例</li><li>线程同步的关键字synchronized锁，volatile保证数据可见但是不保证数据的准确性【回忆os磁盘的延迟写，cache的写回法什么的】</li></ul></li><li><p>线程安全类 </p><ul><li><code>StringBuffer</code>【字符串的拼接，编译器会自动优化！我测试过！】</li><li>Vector</li><li><code>Hashtable</code>===键值都不能为null。【Properties也是线程安全的】</li></ul></li><li><p>Lock锁 <code>jdk5</code>提供</p><ul><li><code>ReentrantLock()</code></li></ul></li><li><p><code>ThreadLocal</code>===Java线程本地存储</p></li></ul><h3 id="16-1-线程的运行"><a href="#16-1-线程的运行" class="headerlink" title="16.1 线程的运行"></a>16.1 线程的运行</h3><p>方式一：继承Thread类</p><ul><li>为什么要重写run方法？<ul><li>因为run方法是用来封装被线程执行的代码</li></ul></li><li>run方法和start方法的区别<ul><li>run封装线程执行的代码，直接调用，相当于普通方法调用</li><li>start，启动线程，然后由<code>jvm</code>调用此线程的run方法</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程抢夺CPU权限，交替执行。回忆CPU是如何分配的？ FIFS SJF RR</span></span><br><span class="line">        MyThread myThread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread myThread2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread1.start();</span><br><span class="line">        myThread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：实现Runnable接口</p><ul><li>相比于继承Thread，实现Runnable接口的优势<ul><li>避免了Java单继承的局限性【多继承可以用内部类实现】</li><li>适合多个相同程序的代码去处理同一个资源。【Thread用静态定义资源也可以】，把线程和程序的代码，数据，进行了有效分类，较好体现了面向对象的设计思想！<ul><li>数据，代码分离体现在哪里？？？</li></ul></li></ul></li></ul><h3 id="16-2-线程的控制"><a href="#16-2-线程的控制" class="headerlink" title="16.2 线程的控制"></a>16.2 线程的控制</h3><h4 id="16-2-1-join"><a href="#16-2-1-join" class="headerlink" title="16.2.1 join()"></a>16.2.1 join()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyThread m1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    MyThread m2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    MyThread m3 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    m1.setName(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    m2.setName(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    m3.setName(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    m1.start();</span><br><span class="line">    m2.start();</span><br><span class="line">    m3.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    MyThread m1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    MyThread m2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    MyThread m3 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    m1.setName(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    m2.setName(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    m3.setName(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    m1.start();</span><br><span class="line">    m1.join();</span><br><span class="line">    System.out.println(<span class="string">&quot;hello  world&quot;</span>);</span><br><span class="line">    m2.start();</span><br><span class="line">    m3.start();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.getPriority());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="16-2-2-daemon"><a href="#16-2-2-daemon" class="headerlink" title="16.2.2 daemon()"></a>16.2.2 daemon()</h4><blockquote><p>设置当前线程为守护线程！当只剩守护线程时，jvm会退出，不会等待守护线程执行完毕</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非守护线程全部执行后 守护线程不一定能执行完毕，可能会被jvm直接终止</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyThread m1 = <span class="keyword">new</span> MyThread();<span class="comment">// for 10</span></span><br><span class="line">    MyThread2 m2 = <span class="keyword">new</span> MyThread2();<span class="comment">// for 100</span></span><br><span class="line">    MyThread2 m3 = <span class="keyword">new</span> MyThread2();<span class="comment">// for 100</span></span><br><span class="line">    m1.setName(<span class="string">&quot;大哥&quot;</span>);</span><br><span class="line">    m2.setName(<span class="string">&quot;守护大哥一号&quot;</span>);</span><br><span class="line">    m3.setName(<span class="string">&quot;守护大哥二号&quot;</span>);</span><br><span class="line">    m2.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    m3.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    m1.start();</span><br><span class="line">    m2.start();</span><br><span class="line">    m3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-3-线程的同步"><a href="#16-3-线程的同步" class="headerlink" title="16.3 线程的同步"></a>16.3 线程的同步</h3><h4 id="16-3-1-使用synchronized"><a href="#16-3-1-使用synchronized" class="headerlink" title="16.3.1 使用synchronized"></a>16.3.1 使用synchronized</h4><ul><li>synchronize（）中的应该就是充当信号量的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SaleTicket sale = <span class="keyword">new</span> SaleTicket();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(sale, <span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(sale, <span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(sale, <span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * OS中所谓的管程</span></span><br><span class="line"><span class="comment">         * OS中pv操作心得：pv中包裹的不影响同步的代码尽可能地少，多了影响程序性能。</span></span><br><span class="line"><span class="comment">         * java多线程应该也是如此！</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;出售了一张，还有&quot;</span> + (--ticket) + <span class="string">&quot;张&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="16-3-2-同步代码块与同步方法"><a href="#16-3-2-同步代码块与同步方法" class="headerlink" title="16.3.2 同步代码块与同步方法"></a>16.3.2 同步代码块与同步方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 同步方法！ 看视频！</span></span><br></pre></td></tr></table></figure><p>同步方法默认用this或者当前类class对象作为锁；<br>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；<br>同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用 synchronized（object）{代码内容}进行修饰；</p><hr><h3 id="16-4-Lock锁"><a href="#16-4-Lock锁" class="headerlink" title="16.4 Lock锁"></a>16.4 Lock锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// PV 细想-</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;出售了一张，还有&quot;</span> + (--ticket) + <span class="string">&quot;张&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-5-生产者-消费者"><a href="#16-5-生产者-消费者" class="headerlink" title="16.5 生产者 消费者"></a>16.5 生产者 消费者</h3><blockquote><p><strong>生产者生产，消费者消费。有同步有互斥。</strong></p></blockquote><ul><li>empty 告诉生产者还可以放多少</li><li>full 告诉消费者还可以拿多少</li><li>同时只能一个拿或一个放</li><li>不能拿/放则等待 用wait()</li><li>有东西了，可以拿了就notify() == 【应该是随机唤醒一个等待的线程，可以指定唤醒某个吗？】</li></ul><h2 id="第十七章-网络编程"><a href="#第十七章-网络编程" class="headerlink" title="第十七章 网络编程"></a>第十七章 网络编程</h2><h3 id="17-1-网络编程入门"><a href="#17-1-网络编程入门" class="headerlink" title="17.1 网络编程入门"></a>17.1 网络编程入门</h3><ul><li>网络编程<ul><li>在网络通信写一下，实现网络互连的不同计算机上，进行数据交换。</li></ul></li><li>网络编程三要素<ul><li>IP地址。为计算机指定标识（即IP地址）</li><li>端口。用于区分一台计算机的不同程序。如：A程序网络通信就用xx端口。</li><li>协议。网络通信需要遵从的通信规则【常见协议有 UDP协议和TCP协议】</li></ul></li></ul><h3 id="17-2-IP地址"><a href="#17-2-IP地址" class="headerlink" title="17.2 IP地址"></a>17.2 IP地址</h3><p><code>IP地址分为 IPv4和IPv6</code></p><ul><li>IPv4 地址4字节 4*8=32位</li><li>IPv6 地址128位地址长度，每16字节一组，分成8组十六进制数</li></ul><p><code>常见命令【windows】</code></p><ul><li>ipconfig</li><li>ping IP地址</li></ul><h4 id="17-2-1-InetAddress"><a href="#17-2-1-InetAddress" class="headerlink" title="17.2.1 InetAddress"></a>17.2.1 InetAddress</h4><blockquote><p><strong>IP地址的获取和操作，InetAddress表示Internet协议（IP）地址</strong></p></blockquote><ul><li>getHostName() 获得主机名称</li><li>getHostAddress() 返回文本显示中的IP地址字符串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">    <span class="comment">// 通过计算机名称得到InetAddress对象</span></span><br><span class="line">    InetAddress byAddress = InetAddress.getByName(<span class="string">&quot;DESKTOP-R0ENAIP&quot;</span>);</span><br><span class="line">    <span class="comment">// 获得主机地址</span></span><br><span class="line">    String hostAddress = byAddress.getHostAddress();</span><br><span class="line">    System.out.println(hostAddress);</span><br><span class="line">    <span class="comment">// 获得主机名称</span></span><br><span class="line">    String hostName = byAddress.getHostName();</span><br><span class="line">    System.out.println(hostName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-3-端口"><a href="#17-3-端口" class="headerlink" title="17.3 端口"></a>17.3 端口</h3><ul><li>端口：设备上应用程序的唯一标识</li><li>端口号：用两个字节表示的整数。范围是0到65535.其中0到1023被用于一些知名的网络服务和应用。普通程序建议使用1024以上的端口号，防止端口被占用启动失败！</li></ul><h3 id="17-4-协议（UDP）"><a href="#17-4-协议（UDP）" class="headerlink" title="17.4 协议（UDP）"></a>17.4 协议（<code>UDP</code>）</h3><blockquote><p><strong>协议：计算机网络中，连接和通信的规则称之为网络通信协议</strong></p></blockquote><h4 id="17-4-1-UDP协议"><a href="#17-4-1-UDP协议" class="headerlink" title="17.4.1 UDP协议"></a>17.4.1 <code>UDP</code>协议</h4><ul><li>用户数据报协议（User Datagram Protocol）</li><li><code>UDP</code>是无连接通信协议。数据传输时发送端和接收端不建立逻辑。回忆计组和计网的相关内容。发送和接受都不确认对面有没有人。<code>UDP</code>协议资源消耗小，通信效率高，常用于音频，视频和普通数据的传输！</li><li><code>UDP</code>是无连接性，不保证数据的完整性。传输重要数据不建议使用<code>UDP</code>.</li></ul><h4 id="17-4-2-UDP通信原理"><a href="#17-4-2-UDP通信原理" class="headerlink" title="17.4.2 UDP通信原理"></a>17.4.2 UDP通信原理</h4><p>UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象因此对于基于UDP协议的通信双方而已，没有所谓的客户端，服务器的概念。</p><h4 id="17-4-3-UDP发送，接收数据的步骤"><a href="#17-4-3-UDP发送，接收数据的步骤" class="headerlink" title="17.4.3 UDP发送，接收数据的步骤"></a>17.4.3 UDP发送，接收数据的步骤</h4><blockquote><p><strong>先有接收端，再有发送端！</strong></p></blockquote><p><strong>发送数据的步骤</strong></p><ul><li>创建发送端的套接字对象（DatagramSocket）</li><li>创建数据，并把数据打包</li><li>调用DatagramSocket对象的发送方法</li><li>关闭发送端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="string">&quot;你好，我是xxx&quot;</span>.getBytes();</span><br><span class="line">    InetAddress byName = InetAddress.getByName(<span class="string">&quot;DESKTOP-R0ENAIP&quot;</span>);</span><br><span class="line">    DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bytes,<span class="number">0</span>,bytes.length,byName,<span class="number">8888</span>);</span><br><span class="line">    dp.setData(bytes,<span class="number">0</span>,bytes.length);</span><br><span class="line">    ds.send(dp);</span><br><span class="line">    ds.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接收数据的步骤</strong></p><ul><li>创建接收端的Socket对象（DatagramSocke）</li><li>创建一个数据包，用于接收数据</li><li>调用DatagramSocke的方法接收数据</li><li>解析数据包，把数据在控制台显示</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="string">&quot;你好，我是xxx&quot;</span>.getBytes();</span><br><span class="line">    InetAddress byName = InetAddress.getByName(<span class="string">&quot;DESKTOP-R0ENAIP&quot;</span>);</span><br><span class="line">    DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bytes,<span class="number">0</span>,bytes.length,byName,<span class="number">8888</span>);</span><br><span class="line">    dp.setData(bytes,<span class="number">0</span>,bytes.length);</span><br><span class="line">    ds.send(dp);</span><br><span class="line">    ds.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS : 不记得具体的xx，就点进源码去看构造方法上面的注释！！</p><h3 id="17-5-协议（TCP）"><a href="#17-5-协议（TCP）" class="headerlink" title="17.5 协议（TCP）"></a>17.5 协议（TCP）</h3><h4 id="17-5-1-TCP通信原理"><a href="#17-5-1-TCP通信原理" class="headerlink" title="17.5.1 TCP通信原理"></a>17.5.1 TCP通信原理</h4><p>TCP协议是一种可靠的网络协议，它在通信的两端各建立一个Socket对象，从而在通信的两端形成网络虚拟链路，一旦建立了虚拟的网络链路，两端的程序就可以通过虚拟链路进行通信！</p><blockquote><p><strong>Java对基于TCP协议的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流进行网络通信</strong></p></blockquote><h4 id="17-5-2-TCP发送数据"><a href="#17-5-2-TCP发送数据" class="headerlink" title="17.5.2 TCP发送数据"></a>17.5.2 TCP发送数据</h4><ul><li><p>创建客户端的Socket对象（Socket）</p><ul><li>```java<br>Socket socket = new Socket(“192.168.1.106”,8888);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 获取输出流，写数据</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    OutputStream os = socket.getOutputStream();</span><br><span class="line">    os.write(&quot;TCP我来了&quot;.getBytes());</span><br></pre></td></tr></table></figure></li></ul></li><li><p>释放资源</p><ul><li>```java<br>socket.close();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 17.5.3 TCP接收数据</span><br><span class="line"></span><br><span class="line">- 创建服务器端的Socket对象**（ServerSocket）**</span><br><span class="line">  - `ServerSocket(int port)`  指定端口即可</span><br><span class="line">- 监听客户端连接，返回一个Socket对象</span><br><span class="line">  - `Socket.accept();`</span><br><span class="line">- 获取输入流，读数据，把数据显示在控制台</span><br><span class="line">  - `InputStream getInputStream()`</span><br><span class="line">- 释放资源</span><br><span class="line">  - `void close()`</span><br><span class="line">- TCP读数据的方法是阻塞式的</span><br><span class="line">- 解决办法：自定义结束标记；使用`shutdownOutput（）`方法【推荐】</span><br><span class="line"></span><br><span class="line">**第一版代码**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class ClientDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 发送数据 内存向外 输出流</span><br><span class="line">        Socket socket = new Socket(&quot;192.168.1.106&quot;,8888);</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(&quot;TCP我来了&quot;.getBytes());</span><br><span class="line">        socket.close();</span><br><span class="line">        // 有用有三次握手的确认，所以需要客户端 服务器端都开启才行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ServerDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ServerSocket s = new ServerSocket(8888);</span><br><span class="line">        Socket accept = s.accept();</span><br><span class="line">        // 可以用xx流一次读一行！</span><br><span class="line">        InputStream is = accept.getInputStream();</span><br><span class="line">        byte[] bytes = new byte[4096];</span><br><span class="line">        int read = is.read(bytes, 0, bytes.length);</span><br><span class="line">        System.out.println(new String(bytes, 0, read));</span><br><span class="line">        accept.close();</span><br><span class="line">        s.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>第二版代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 发送数据 内存向外 输出流</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;192.168.1.106&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;TCP我来了&quot;</span>.getBytes());</span><br><span class="line">        socket.close();</span><br><span class="line">        <span class="comment">// 有用有三次握手的确认，所以需要客户端 服务器端都开启才行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket s = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket accept = s.accept();</span><br><span class="line">        <span class="comment">// 构造方法中要传入一个Reader对象,带Reader后缀的都继承了Reader</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(accept.getInputStream()));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        accept.close();</span><br><span class="line">        s.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-6-上传文件到服务器"><a href="#17-6-上传文件到服务器" class="headerlink" title="17.6 上传文件到服务器"></a>17.6 上传文件到服务器</h3><ul><li>客户端，读取文件，并逐一发送数据</li><li>服务器端，接收数据</li><li>由于网络传输，服务器端是一直在等待客户端的数据的，所以会一直等。当客户端数据传输完毕后，给出停止标记！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;192.168.1.106&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;demo5.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes, <span class="number">0</span>, bytes.length)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 停止自身的Output 这个写了，对方才知道 不要一直获取了，可以跳槽while循环</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;文件上传完毕了！要通知服务器关闭了！&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> read = socket.getInputStream().read(b, <span class="number">0</span>, b.length);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(b, <span class="number">0</span>, read));</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">        Socket accept = server.accept();</span><br><span class="line">        InputStream inputStream = accept.getInputStream();</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;Server.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes, <span class="number">0</span>, bytes.length)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            fos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        accept.shutdownInput();<span class="comment">// 停止input</span></span><br><span class="line">        System.out.println(<span class="string">&quot;文件接收完毕&quot;</span>);</span><br><span class="line">        accept.getOutputStream().write(<span class="string">&quot;完成了&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        fos.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        accept.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟Tomcat"><a href="#模拟Tomcat" class="headerlink" title="模拟Tomcat"></a>模拟Tomcat</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bbxx.tomcat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求相应html文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSDemo3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义类路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String WEB_ROOT;</span><br><span class="line">    <span class="comment">// 定义默认的读取端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String URL = <span class="string">&quot;404.html&quot;</span>;</span><br><span class="line">    <span class="comment">// 默认端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT = <span class="number">8888</span>;</span><br><span class="line">    <span class="comment">// 读取类信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InputStream INPUTSTREAM = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 读完WebContent下的静态文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> File FILE_STATIC = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 状态码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> CODE = <span class="number">404</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信息</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        WEB_ROOT = BSDemo3.class.getClassLoader().getResource(<span class="string">&quot;&quot;</span>).getPath() + <span class="string">&quot;WebContent&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            INPUTSTREAM = <span class="keyword">new</span> FileInputStream(WEB_ROOT + <span class="string">&quot;//web.properties&quot;</span>);</span><br><span class="line">            System.out.println(WEB_ROOT);</span><br><span class="line">            FILE_STATIC = <span class="keyword">new</span> File(WEB_ROOT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(PORT);</span><br><span class="line">        Socket accept = serverSocket.accept();</span><br><span class="line">        URL = getURL(accept);</span><br><span class="line">        setCodeForStatic(URL);</span><br><span class="line">        publicResponse(accept.getOutputStream(),CODE);</span><br><span class="line">        FileResponse(accept.getOutputStream());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得请求的URL;</span></span><br><span class="line"><span class="comment">     * 请求路径在这里 GET /4654 HTTP/1.1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> socket</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getURL</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">        String str = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((str = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.contains(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">                str = str.replace(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;HTTP/1.1&quot;</span>, <span class="string">&quot;&quot;</span>).trim();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code         状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publicResponse</span><span class="params">(OutputStream outputStream, <span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        String codeStr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">200</span>) codeStr = code + <span class="string">&quot; OK&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">404</span>) codeStr = code + <span class="string">&quot; Not Found&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream.write((<span class="string">&quot;HTTP/1.1 &quot;</span> + codeStr + <span class="string">&quot;OK\n&quot;</span>).getBytes());</span><br><span class="line">            outputStream.write(<span class="string">&quot;Content-Type:text/html;charset=utf-8&quot;</span>.getBytes());</span><br><span class="line">            outputStream.write(<span class="string">&quot;Server:Apache-Coyote/1.1\n&quot;</span>.getBytes());</span><br><span class="line">            outputStream.write(<span class="string">&quot;\n\n&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;公共请求头输出失败！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将文件传输到浏览器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FileResponse</span><span class="params">(OutputStream outputStream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader bf = <span class="keyword">new</span> BufferedReader</span><br><span class="line">                (<span class="keyword">new</span> InputStreamReader</span><br><span class="line">                        (<span class="keyword">new</span> FileInputStream(WEB_ROOT + File.separator + URL)));) &#123;</span><br><span class="line">            String content = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((content = bf.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                outputStream.write(content.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            bf.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据URL设置相应码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCodeForStatic</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Map&lt;String, String&gt; map = getURLMapStatic();</span><br><span class="line">            String s = map.get(url);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>) CODE = <span class="number">404</span>;</span><br><span class="line">            <span class="keyword">else</span> CODE = <span class="number">200</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得所有的静态URL， key是文件名称，value是绝对路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">getURLMapStatic</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; URLMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        File[] files = FILE_STATIC.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.getName().contains(<span class="string">&quot;html&quot;</span>)) &#123;</span><br><span class="line">                URLMap.put(f.getName(), f.getAbsolutePath());</span><br><span class="line">                System.out.println(f.getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> URLMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得所有动态URL(Java代码),key是名称，value是包全名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">getURLMapDymical</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; URLMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> URLMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载配置文件中的动态web文件信息 key是名称，value是类全名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">getProperties</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(in);</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第十八章-反射"><a href="#第十八章-反射" class="headerlink" title="第十八章 反射"></a>第十八章 反射</h2><h3 id="18-0-类加载器前置知识概述"><a href="#18-0-类加载器前置知识概述" class="headerlink" title="18.0 类加载器前置知识概述"></a>18.0 类加载器前置知识概述</h3><p><strong>类加载的时机</strong></p><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包括：</p><p>加载，验证，准备，解析，初始化，使用和卸载 七个阶段</p><h4 id="18-0-1-加载"><a href="#18-0-1-加载" class="headerlink" title="18.0.1 加载"></a><strong>18.0.1 加载</strong></h4><p>加载是类加载过程的一个阶段，加载阶段需要完成以下三件事情</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区，这个类的各种数据的访问入口。</li></ul><p>任何类被使用时，系统都会为之建立一个java.lang.Class对象</p><h4 id="18-0-2-连接"><a href="#18-0-2-连接" class="headerlink" title="18.0.2 连接"></a><strong>18.0.2 连接</strong></h4><ul><li><p>验证阶段：用于检测被加载的类是否有正确的内部结构【符合JVM规范】。【不是必要阶段，可省略】</p></li><li><p>准备阶段：负责为类的类变量分配内存，设置默认初始化值。</p><ul><li><p>这时候进行的内存分配仅包含类变量（被static修饰的变量），不包括实例变量，实例变量将会在对象实例化时随对象一起分配在Java堆中。</p></li><li><p>这里的初始值“通常情况”下时数据类型的零值</p></li><li><p>```java<br>public staatic int value = 123<br>value在准备阶段过后 初始值为0，而非123</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 解析阶段：将常量池内的符号引用替换为直接引用</span><br><span class="line"></span><br><span class="line">  - 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。与虚拟机的内存布局无关</span><br><span class="line">  - 直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。与虚拟机的内存布局有关。如果有直接引用了，那么目标一定在内存中！</span><br><span class="line"></span><br><span class="line">#### 18.0.3 初始化</span><br><span class="line"></span><br><span class="line">类加载过程的最后一步。到了初始化阶段，才开始执行类中定义的Java程序代码（或者是是字节码）</span><br><span class="line"></span><br><span class="line">**对类变量进行初始化**</span><br><span class="line"></span><br><span class="line">**类的初始化步骤**</span><br><span class="line"></span><br><span class="line">- 假如类还未被加载和连接，则程序先加载并连接该类</span><br><span class="line">- 假如该类的直接父类还未被初始化，则先初始化其直接父类</span><br><span class="line">- 假如父类中有初始化语句，则系统依次执行这些初始化语句</span><br><span class="line"></span><br><span class="line">**类的初始化时机**【视频中的】</span><br><span class="line"></span><br><span class="line">- 创建类的实例</span><br><span class="line">- 调用类的类方法</span><br><span class="line">- 访问类或接口的类的变量，或者为该类变量赋值</span><br><span class="line">- 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</span><br><span class="line">- 初始化某个类的子类</span><br><span class="line">- 直接使用java.exe命令运行某个主类</span><br><span class="line"></span><br><span class="line">### 18.1 类加载器</span><br><span class="line"></span><br><span class="line">#### **18.1.1 类加载器作用**</span><br><span class="line"></span><br><span class="line">- 负责将.class文件加载到内存中，并为之生成对应的java.lang.Class对象</span><br><span class="line"></span><br><span class="line">#### **18.1.2 JVM的类加载机制**</span><br><span class="line"></span><br><span class="line">- 全盘负责：当一个类加载器负责加载某个Class时，该Class所依赖和引用的其他Class也将由该类加载器负责载入，除非显示使用另一个类加载器来载入</span><br><span class="line">- 父类委托：当一个类加载器负责某个Class时，先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</span><br><span class="line">- 缓存机制：保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜索该Class，只有当缓存中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存储到缓存区。</span><br><span class="line"></span><br><span class="line">#### **18.1.3 ClassLoader：**</span><br><span class="line"></span><br><span class="line">- 负责加载类的对象</span><br><span class="line"></span><br><span class="line">#### **18.1.4 Java运行时的内置类加载器**</span><br><span class="line"></span><br><span class="line">- **Bootstrap class loader**：它是虚拟机的内置类加载器，通常表示为null，并且没用父</span><br><span class="line">- **Platform class loader**：平台类加载器可以看到所有平台类，平台类包括由平台类加载器或其祖先定义的JavaSE平台API，其实现类和JDK特定的运行时类</span><br><span class="line">- **System class loader**：也被称为应用程序类加载器，与平台类加载器不同，系统类加载器通常定义应用程序类路径，模块路径和JDK特定工具上的类</span><br><span class="line">- 类加载器的继承关系：System的父加载器为Platform，而Platform的父加载器为Bootstrap</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Test</span><br><span class="line">public void fn1()&#123;</span><br><span class="line">    // 获得系统加载</span><br><span class="line">    ClassLoader c = ClassLoader.getSystemClassLoader();</span><br><span class="line">    System.out.println(c);//sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line"></span><br><span class="line">    //获得父类加载</span><br><span class="line">    ClassLoader c2 = c.getParent();</span><br><span class="line">    System.out.println(c2);//sun.misc.Launcher$ExtClassLoader@4a574795</span><br><span class="line"></span><br><span class="line">    //获得父类加载</span><br><span class="line">    ClassLoader c3 = c2.getParent();</span><br><span class="line">    System.out.println(c3);// null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="18-2-反射概述"><a href="#18-2-反射概述" class="headerlink" title="18.2 反射概述"></a>18.2 反射概述</h3><p>​        Java的反射机制是指在运行时去获取一个类的变量和方法信息，然后通过获取到的信息来创建对象，从而调用方法的一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍然可以扩展。</p><h3 id="18-3-反射操作"><a href="#18-3-反射操作" class="headerlink" title="18.3 反射操作"></a>18.3 反射操作</h3><h4 id="18-3-1-获取Class类的对象"><a href="#18-3-1-获取Class类的对象" class="headerlink" title="18.3.1 获取Class类的对象"></a>18.3.1 获取Class类的对象</h4><p>要使用反射，先要获取该类的字节码文件对象</p><ul><li>使用类的class属性获取Class对象</li><li>调用对象的getClass()方法，该方法是Object类中的方法，所有Java对象都可以调用该方法</li><li>使用Class类中的静态方法forName(String className) 传入的是完整包名路径</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getClazz</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 最方便</span></span><br><span class="line">    Class&lt;Student&gt; c1 = Student.class;</span><br><span class="line">    Class&lt;Student&gt; c2 = Student.class;</span><br><span class="line">    System.out.println(c1 == c2); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    Student s = <span class="keyword">new</span> Student();</span><br><span class="line">    Class&lt;? extends Student&gt; c3 = s.getClass();</span><br><span class="line">    System.out.println(c2 == c3); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 灵活 可以把xx写在配置文件中</span></span><br><span class="line">    Class&lt;?&gt;  c4 = Class.forName(<span class="string">&quot;com.bbxx.demo1.Student&quot;</span>);</span><br><span class="line">    System.out.println(c3 == c4); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18-3-2-获取构造方法"><a href="#18-3-2-获取构造方法" class="headerlink" title="18.3.2 获取构造方法"></a>18.3.2 获取构造方法</h4><ul><li><strong>自行查看api【暴力访问时需要setAccessible（true）】</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConstructors</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;Student&gt; c1 = Student.class;</span><br><span class="line">    <span class="comment">// 获得指定的构造方法</span></span><br><span class="line">    Constructor&lt;Student&gt; con1 = c1.getConstructor(String.class,String.class,<span class="keyword">int</span>.class);</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    Student student = con1.newInstance(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;swx&quot;</span>, <span class="number">15</span>);</span><br><span class="line">    System.out.println(student);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得所有非私有构造方法</span></span><br><span class="line">    Constructor&lt;?&gt;[] con2 = c1.getConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor c: con2 )&#123;</span><br><span class="line">        System.out.println(c.getParameterTypes().length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力反射</span></span><br><span class="line">    Constructor&lt;Student&gt; c3 = c1.getDeclaredConstructor(String.class);</span><br><span class="line">    <span class="comment">// 取消访问检查</span></span><br><span class="line">    c3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Student s3 = c3.newInstance(<span class="string">&quot;xx&quot;</span>);</span><br><span class="line">    System.out.println(s3.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18-3-3-获取成员变量"><a href="#18-3-3-获取成员变量" class="headerlink" title="18.3.3  获取成员变量"></a>18.3.3  获取成员变量</h4><table><thead><tr><th align="center">方法名称</th><th align="center">方法说明</th></tr></thead><tbody><tr><td align="center"><code>getFields（）</code></td><td align="center">获得所有公共字段（public修饰的）</td></tr><tr><td align="center"><code>getDeclaredFields（）</code></td><td align="center">获得所有字段（包括protected private）</td></tr><tr><td align="center"><code>age.set(student,18);</code></td><td align="center">为student对象的age字段设置值18</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFiled</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;Student&gt; stu = Student.class;</span><br><span class="line">    <span class="comment">// 获得所有公有字段。public修饰的</span></span><br><span class="line">    Field[] fields = stu.getFields();</span><br><span class="line">    <span class="keyword">for</span> (Field f: fields) &#123;</span><br><span class="line">        System.out.println(f.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;**********&quot;</span>);</span><br><span class="line">    <span class="comment">// 获得所有字段 包括 protected private</span></span><br><span class="line">    Field[] declaredFields = stu.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field f: declaredFields) &#123;</span><br><span class="line">        System.out.println(f.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;**********&quot;</span>);</span><br><span class="line">    <span class="comment">// 给student对象的age字段赋值为18</span></span><br><span class="line">    Student student = stu.newInstance();</span><br><span class="line">    Field age = stu.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    age.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    age.set(student,<span class="number">18</span>);</span><br><span class="line">    System.out.println(student.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18-3-4-获取成员方法"><a href="#18-3-4-获取成员方法" class="headerlink" title="18.3.4 获取成员方法"></a>18.3.4 获取成员方法</h4><table><thead><tr><th align="left">方法名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>Method[] getMethods()</code></td><td align="left">返回所有公共成员方法对象的数组，包 括继承的</td></tr><tr><td align="left"><code>Method[] getDeclaredMethods()</code></td><td align="left">返回所有成员方法对象的数组，不包括 继承的</td></tr><tr><td align="left"><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></td><td align="left">返回单个公共成员方法对象</td></tr><tr><td align="left"><code>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code></td><td align="left">返回单个成员方法对象</td></tr></tbody></table><h4 id="18-3-5-反射越过泛型检查"><a href="#18-3-5-反射越过泛型检查" class="headerlink" title="18.3.5 反射越过泛型检查"></a>18.3.5 反射越过泛型检查</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refelectDemo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// list.add(&quot;123&quot;); 抱错，有泛型检查</span></span><br><span class="line">    Class&lt;? extends ArrayList&gt; clazz = list.getClass();</span><br><span class="line">    <span class="comment">// 是Object.class</span></span><br><span class="line">    Method add = clazz.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">    add.invoke(list,<span class="string">&quot;asdf&quot;</span>);</span><br><span class="line">    System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第十九章-函数式编程"><a href="#第十九章-函数式编程" class="headerlink" title="第十九章 函数式编程"></a>第十九章 函数式编程</h2><h3 id="19-1-体验Lambda表达式"><a href="#19-1-体验Lambda表达式" class="headerlink" title="19.1 体验Lambda表达式"></a>19.1 体验Lambda表达式</h3><h3 id="19-2-Lambda表达式的标准格式"><a href="#19-2-Lambda表达式的标准格式" class="headerlink" title="19.2 Lambda表达式的标准格式"></a>19.2 Lambda表达式的标准格式</h3><ul><li><p>Lambda表达式的代码分析</p><ul><li>() 里面没用内容，可以看成是方法形式参数为空！</li><li><strong>-&gt;</strong> 用箭头指向后面要做的事情！</li><li>{ } 包含一段代码，称之为代码块，可以看成是方法体中的内容！</li></ul></li><li><p>Lambda表达式的格式</p><ul><li>格式：（形式参数）-&gt; （代码）。</li><li>形式参数：如果有多个参数，参数之间用逗号隔开；如果没用参数，留空即可。</li><li><strong>-&gt;</strong> ：由英文中画线和大于符号组成，固定写法，代表指向动作。</li><li>代码块：是我们具体要做的事情，也就是以前我们写法的方法体内容。</li></ul></li></ul><h3 id="19-3-Lambda表达式的练习"><a href="#19-3-Lambda表达式的练习" class="headerlink" title="19.3 Lambda表达式的练习"></a>19.3 Lambda表达式的练习</h3><ul><li><p>使用前提</p><ul><li>有一个接口</li><li>接口中有且仅有一个抽象方法</li></ul></li><li><p>练习一</p><ul><li>定义一个接口Eatable，里面定义一个抽象方法：void eat（）；</li><li>定义一个测试类，测试类中提供两个方法<ul><li>一个是useEatable（Eatable e）</li><li>一个是主方法，在主方法中调用useEatable</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EatableImpl</span> <span class="keyword">implements</span> <span class="title">Eatable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat eat eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EatableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 常规方式</span></span><br><span class="line">        EatableImpl eatable = <span class="keyword">new</span> EatableImpl();</span><br><span class="line">        useEatable(eatable);</span><br><span class="line">        <span class="comment">// 匿名内部类写法</span></span><br><span class="line">        useEatable(<span class="keyword">new</span> Eatable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat eat eat&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 记忆方法</span></span><br><span class="line"><span class="comment">         *  因为只有一个抽象方法，所以不用写方法名称！</span></span><br><span class="line"><span class="comment">         *  （）没用参数就空着，有就写！</span></span><br><span class="line"><span class="comment">         *  -&gt;&#123;&#125;指向要执行的代码块</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        useEatable(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useEatable</span><span class="params">(Eatable e)</span> </span>&#123;</span><br><span class="line">        e.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>练习二</p><ul><li>定义一个接口Flyable，里面定义一个抽象方法：void fly（String s）；</li><li>定义一个测试类，测试类中提供两个方法<ul><li>一个是<code>useFlyable（Flyable f）</code></li><li>一个是主方法，在主方法中调用useFlyable</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyableImpl</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fly fly fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        useFlyable((String str) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            System.out.println(<span class="string">&quot;Fly&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出</span></span><br><span class="line"><span class="comment">         * 风和日丽，晴空万里123</span></span><br><span class="line"><span class="comment">         * Fly</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 风和日丽，晴空万里被赋值给了lambda表达式中的String str。两个参数的情形也是一样的 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useFlyable</span><span class="params">(Flyable e,String s)</span> </span>&#123;</span><br><span class="line">        e.fly(<span class="string">&quot;风和日丽，晴空万里&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-4-Lambda表达式的省略模式"><a href="#19-4-Lambda表达式的省略模式" class="headerlink" title="19.4 Lambda表达式的省略模式"></a>19.4 Lambda表达式的省略模式</h3><p><strong>（）中的数据类型可以省略！但是有多个参数的情况下，不能只省略一个！要省略就都省略！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （）中的数据类型可以省略！</span></span><br><span class="line">useFlyable((s) -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    System.out.println(<span class="string">&quot;Fly&quot;</span>);</span><br><span class="line">&#125;,<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>（）中如果参数只有一个，那么小括号可以省略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useFlyable(s -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;,<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>如果代码块的语句只有一条，可以省略大括号和分号</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useFlyable(s -&gt; System.out.println(s) ,<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果有return，renturn也要省略掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userAddable((x,y) -&gt; x+y);</span><br></pre></td></tr></table></figure><h3 id="19-5-Lambda-表达式的注意事项"><a href="#19-5-Lambda-表达式的注意事项" class="headerlink" title="19.5 Lambda 表达式的注意事项"></a>19.5 Lambda 表达式的注意事项</h3><ul><li><p>使用lambda必须要有接口，并且接口中有且仅有一个抽象方法</p></li><li><p>必须有上下文环境，才能推导出Lambda对于的接口</p><ul><li>根据局部变量的赋值得知Lambda对应的接口：Runnable r = () -&gt; System.out.println(“Lambda表达式”)；</li><li>根据调用方法的参数得知Lambda对应的接口：new Thread( () - &gt;System.out.println(“Lambda表达式”) ).start();</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        useInter(() -&gt; System.out.println(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">        <span class="comment">// 直接写没用上下文环境 直接生成本地变量是Runnable</span></span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">                System.out.println(<span class="string">&quot;hello world 2&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useInter</span><span class="params">(Inter i)</span> </span>&#123;</span><br><span class="line">        i.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-6-Lambda表达式和你们内部类的区别"><a href="#19-6-Lambda表达式和你们内部类的区别" class="headerlink" title="19.6 Lambda表达式和你们内部类的区别"></a>19.6 Lambda表达式和你们内部类的区别</h3><ul><li>匿名内部类调用方法的形参可以是：类，抽象类，接口</li><li>Lambda调用方法的形参必须是接口</li><li>匿名内部类编译时会生成一个单独的class文件。lambda表达式不会，它对应的字节码会在运行时动态生成。</li></ul><h2 id="第二十章-接口组成更新"><a href="#第二十章-接口组成更新" class="headerlink" title="第二十章 接口组成更新"></a>第二十章 接口组成更新</h2><h4 id="概述：接口的组成"><a href="#概述：接口的组成" class="headerlink" title="概述：接口的组成"></a><strong>概述：接口的组成</strong></h4><ul><li><p>常量</p><ul><li>```<br>public static final<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 抽象方法</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    public abstract</span><br></pre></td></tr></table></figure></li></ul></li><li><p>默认方法（jdk 8）</p><ul><li>```<br> public default void walk(){ System.out.println(“hello”); }<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  -  **default可以不被重写。方便在不影响已有接口的情况下更新接口**</span><br><span class="line"></span><br><span class="line">- 静态方法（jdk 8）</span><br><span class="line"></span><br><span class="line">- 私有方法（jdk 9）</span><br><span class="line"></span><br><span class="line">### 20.1 方法引用</span><br><span class="line"></span><br><span class="line">在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿参数做操作</span><br><span class="line"></span><br><span class="line">若在Lambda中所指的的操作方案，已经有地方存在相同的方案，这时候是没用必要再写重复逻辑的。</span><br><span class="line"></span><br><span class="line">那如何使用已经存在的方案？</span><br><span class="line"></span><br><span class="line">使用方法引用来使用已经存在的方案！</span><br><span class="line"></span><br><span class="line">- 方法引用符号</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public interface Animal &#123;</span><br><span class="line">    void say(Object o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Printable &#123;</span><br><span class="line">    void printString(String s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PrintableDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 常规写法</span><br><span class="line">        userPrintable(s -&gt; System.out.println(s));</span><br><span class="line">        // 方法引用符 ，：：   其实方法应用是直接把参数传给了这个方法【print】</span><br><span class="line">        userPrintable(System.out::print);</span><br><span class="line">        // 可推导的就是可省略的</span><br><span class="line">        useAnimal(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 我要打印数据</span><br><span class="line">    private static void userPrintable(Printable p) &#123;</span><br><span class="line">        p.printString(&quot;hehahhh&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void useAnimal(Animal a)&#123;</span><br><span class="line">        a.say(new Object());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h5><ul><li><p>格式：类名：：静态方法</p></li><li><p>示例：Integer::parseInt（）</p></li></ul></li><li><p>练习</p><ul><li>定义一个接口（Converter），定义抽象方法int convert(String s)</li><li>定义测试类</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Convert</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">convert</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        useConver(Integer::parseInt,<span class="string">&quot;105&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// lambda表达式被类方法替代的时候，它的形式参数全部传递给静态方法作为参数！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useConver</span><span class="params">(Convert c,String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> convert = c.convert(str);</span><br><span class="line">        System.out.println(convert*<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>特定对象的实例方法引用</strong></p><ul><li>格式：对象：：成员方法</li><li>示例：“HelloWorld”.toUpperCase</li></ul></li><li><h5 id="类的任意对象的实例方法引用"><a href="#类的任意对象的实例方法引用" class="headerlink" title="类的任意对象的实例方法引用"></a>类的任意对象的实例方法引用</h5><ul><li><p>格式：类名：：成员方法</p></li><li><p>示例：String::substring</p></li><li><p>格式：类名：：成员方法</p></li><li><p>示例：String::substring</p></li></ul></li><li><h5 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h5><ul><li><p>格式：<strong>类名::new</strong> ，</p></li><li><p>示例： () -&gt; new ArrayList<String>() 等价于 ArrayList<String>::new，代码示例：</p></li><li><p>```java<br>Supplier&lt;List<String>&gt; supplier1= () -&gt; new  ArrayList<String>();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 20.1 函数式接口</span><br><span class="line"></span><br><span class="line">有且仅有一个抽象方法的接口</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface MyInterface &#123;</span><br><span class="line">    void say();</span><br><span class="line">    default void saa()&#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以不写注解，但是写注解可以检测到是否只有一个抽象方法，安全些。</span><br><span class="line">// 如果接口时函数式接口，编译通过！</span><br><span class="line">// 建议加上这个注解</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="20-1-1-函数式接口作为返回值"><a href="#20-1-1-函数式接口作为返回值" class="headerlink" title="20.1.1 函数式接口作为返回值"></a>20.1.1 函数式接口作为返回值</h4><p><strong>return 推到式就可以了</strong></p><h4 id="20-1-2-常用的函数式接口"><a href="#20-1-2-常用的函数式接口" class="headerlink" title="20.1.2 常用的函数式接口"></a>20.1.2 常用的函数式接口</h4><ul><li><p><code>Java8</code>在<code>java.util.function</code>包下预定义了大量的函数式接口</p></li><li><p><strong>Supplier接口</strong></p><ul><li>Supplier<T>：包含一个无参的方法</li><li>T get（）：获得结果</li><li>该方法不需要参数，它会按照某种实现逻辑（由Lambda表达式实现）返回一个数据</li><li>Supplier<T>接口也被称为生产型接口，如果我们指定了接口的泛型式是什么类型，那么接口中的get（）方法就会产生什么类型的数据供我们使用！</li><li><strong>简单说来，他就是一个容易，用来存Lambda表达式生成的数据的。可用get方法得到这个生成的数据</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupplierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String string = getString(() -&gt; <span class="string">&quot;lqx&quot;</span>);<span class="comment">// 生成String</span></span><br><span class="line">        Integer integer = getInteger(() -&gt; <span class="number">20</span> + <span class="number">50</span>);<span class="comment">// 生成int</span></span><br><span class="line">        System.out.println(string);</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成Supplier示例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Supplier&lt;Student&gt; s1 = Student::<span class="keyword">new</span>; <span class="comment">// 生成 对象放进去</span></span><br><span class="line">        Student student = s1.get(); <span class="comment">// 获得这个对象</span></span><br><span class="line">        System.out.println(student.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回integer</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title">getInteger</span><span class="params">(Supplier&lt;Integer&gt; sup)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回String</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(Supplier&lt;String&gt; sup)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>Consumer接口</strong></p><ul><li>Consumer<T>：包含两个方法</li><li>void accept(T t)：对给的的参数执行此操作</li><li>default Consumer<T>andThen(Consumer after)：返回一个组合的Consumer，依次执行此操作，然后执行after操作</li><li>Consumer<T>接口也被称为消费型接口，它消费数据的数据类型由泛型指定</li><li><strong>大概意思就是，你定义消费规则。然后调用它的消费方法，他会按这个消费规则进行消费</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Consumer&lt;Integer&gt; c = x -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        c.accept(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>Predicate接口</strong></p><ul><li><p>Predicate 接口是一个谓词型接口，其实，这个就是一个类似于 bool 类型的判断的接口。</p></li><li><p>Predicate常用的四个方法</p><ul><li><p>```java<br>boolean test(T t) 对给定参数进行逻辑判断，判断表达式由Lambda实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  default Predicate&lt;T&gt;negate(); 返回一个逻辑的否定， 对应逻辑非</span><br></pre></td></tr></table></figure></li><li><p>```java<br>default Predicate<T>and(Predicate other) 返回一个组合逻辑判断，对应短路与</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  default Predicate&lt;T&gt;or(Predicate other) 返回一个组合判断，对应短路或</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Predicate常用于判断参数是否满足xx条件</strong></p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Predicate&lt;String&gt; pre = (s) -&gt;  s .equals(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">        System.out.println(pre.test(<span class="string">&quot;ss&quot;</span>));</span><br><span class="line">        System.out.println(pre.negate().test(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Predicate&lt;String&gt; pre1 = (s) -&gt;  s .equals(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">        Predicate&lt;String&gt; pre2 = (s) -&gt;  s .equals(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">        <span class="comment">// test(参数) 这个参数是赋值给s的 pre1 和 pre2 是否都等于hello</span></span><br><span class="line">        System.out.println(pre1.and(pre2).test(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Predicate&lt;String&gt; pre1 = (s) -&gt;  s .equals(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">        Predicate&lt;String&gt; pre2 = (s) -&gt;  s .equals(<span class="string">&quot;123&quot;</span>) ;</span><br><span class="line">        <span class="comment">// 把hello 赋值给s pre1 和 pre2 是否满足他们的比较关系</span></span><br><span class="line">        System.out.println(pre1.or(pre2).test(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用lambda筛选数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] strArray = &#123;<span class="string">&quot;理解,30&quot;</span>, <span class="string">&quot;wul123i,20&quot;</span>,<span class="string">&quot;wui,20&quot;</span>&#125;;</span><br><span class="line">    ArrayList&lt;String&gt; strings = myFilter(strArray, s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>].length() &gt;= <span class="number">2</span>, s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt; <span class="number">23</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;ss&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s : strings)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">myFilter</span><span class="params">(String[] strArray, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : strArray) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre1.and(pre2).test(s)) &#123;</span><br><span class="line">            list.add(s);</span><br><span class="line">            System.out.println(<span class="string">&quot;asfs&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>Function接口</strong></p><ul><li><p>Function 接口是一个功能型接口，是一个转换数据的作用。</p></li><li><p>Function 接口实现 <code>apply</code> 方法来做转换。</p></li><li><p>常用方法</p><ul><li>R apply（T t）将此函数应用于给定的参数</li><li>default<V> Function andThen(Function after) ：返回一个组合函数，首先将函数应用于输入，然后将after函数应用于结果</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        convert(<span class="string">&quot;132&quot;</span>, Integer::parseInt);</span><br><span class="line">        convert(<span class="string">&quot;132&quot;</span>, Integer::parseInt);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接使用 String是传入数据的类型，Integer是apply处理后返回的数据类型</span></span><br><span class="line">        Function&lt;String,Integer&gt; fn = (s)-&gt;Integer.parseInt(s)*<span class="number">10</span>;</span><br><span class="line">        Integer apply = fn.apply(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">        System.out.println(apply);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要求 把一个字符串转换为int类型并乘以10输出</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">convert</span><span class="params">(String s, Function&lt;String,Integer&gt; fun)</span></span>&#123;</span><br><span class="line">        Integer apply = fun.apply(s);</span><br><span class="line">        System.out.println(apply*<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="20-3-体验Stream流"><a href="#20-3-体验Stream流" class="headerlink" title="20.3 体验Stream流"></a>20.3 体验Stream流</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;兆三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;科学三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;学习三&quot;</span>);</span><br><span class="line">        <span class="comment">// stream 筛选出符合条件的数据进行输出</span></span><br><span class="line">        list.stream().filter((ss) -&gt; ss.length() == <span class="number">3</span>).forEach(ss -&gt; System.out.println(ss));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-4-Stream流的简单Demo"><a href="#20-4-Stream流的简单Demo" class="headerlink" title="20.4 Stream流的简单Demo"></a>20.4 Stream流的简单Demo</h3><p><strong>Stream流的使用</strong></p><ul><li><p>生成流</p><ul><li>通过数据源（集合，数组等）生成流</li><li><code>list.stream();</code></li></ul></li><li><p>中间操作</p><ul><li>一个流后面可以跟0个或多个中间操作，其主要是打开流，然后返回一个新的流，交给下一个操作使用</li><li><code>filter()</code></li></ul></li><li><p>终结操作</p><ul><li><p><strong>一个流只能有一个终结操作，当这个操作执行后流会被关闭</strong>【forEach是void，无返回值的意思】</p></li><li><p>```java<br>public class StreamDemo {</p><pre><code>@Testpublic void fn1() &#123;    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();    list.add(&quot;张三&quot;);    list.add(&quot;李三&quot;);    list.add(&quot;兆三&quot;);    list.add(&quot;科学三&quot;);    list.add(&quot;学习三&quot;);    // stream 筛选出符合条件的数据进行输出    list.stream().filter((ss) -&gt; ss.length() == 3).forEach(ss -&gt; System.out.println(ss));    Stream&lt;String&gt; stringStream = list.stream().filter((ss) -&gt; ss.length() == 3);    Assert.assertNotNull(stringStream);// 通过测试，不为空    stringStream.forEach(System.out::print);    Assert.assertNotNull(stringStream);// 通过测试，不为空&#125;@Testpublic void fn4() &#123;    ArrayList&lt;String&gt; arr = new ArrayList&lt;&gt;();    arr.add(&quot;1111&quot;);    arr.add(&quot;2222&quot;);    arr.add(&quot;3333&quot;);    arr.add(&quot;4444&quot;);    arr.add(&quot;5555&quot;);    arr.add(&quot;6666&quot;);    arr.add(&quot;7777&quot;);    Stream&lt;String&gt; limit = arr.stream().limit(5);    Stream&lt;String&gt; skip = arr.stream().skip(3);    Stream&lt;String&gt; concat = Stream.concat(limit, skip);    // stream has already been operated upon or closed    // concat.forEach(System.out::println);    System.out.println(&quot;***********&quot;);    concat.distinct().forEach(System.out::println);&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 20.5 Stream流的生成方式</span><br><span class="line"></span><br><span class="line">#### **20.5.1 Stream流的常见生成方式**</span><br><span class="line"></span><br><span class="line">- Collection体系的集合可以使用默认方法stream（）生成流</span><br><span class="line">  - default Stream&lt;E&gt;() stream()</span><br><span class="line">- Map体系的集合间接生成流</span><br><span class="line">- 数组可以通过Stream接口的静态方法of(T ...value)生成流</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Test</span><br><span class="line">public void fn1() &#123;</span><br><span class="line">    // Collection的 直接生成流</span><br><span class="line">    ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();</span><br><span class="line">    Stream&lt;String&gt; arrStream = arr.stream();</span><br><span class="line"></span><br><span class="line">    HashSet&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">    Stream&lt;String&gt; setStream = set.stream();</span><br><span class="line"></span><br><span class="line">    // Map体系间接的生成流</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; mapStream = map.entrySet().stream();</span><br><span class="line">    mapStream.filter(s -&gt; s.getKey().length() &gt; 2).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    // 数组变为Stream流</span><br><span class="line">    String[] str = &#123;&quot;12313&quot;, &quot;asda&quot;&#125;;</span><br><span class="line">    Stream&lt;String&gt; strSteam1 = Stream.of(str);</span><br><span class="line">    Stream&lt;String&gt; strSteam2 = Stream.of(&quot;123&quot;, &quot;!231&quot;, &quot;!!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="20-5-2-中间流操作"><a href="#20-5-2-中间流操作" class="headerlink" title="20.5.2 中间流操作"></a>20.5.2 中间流操作</h4><ul><li><p><strong>filter</strong>：过滤，满足条件的保留，不满足的不保留。传入的是Predicate</p></li><li><p><strong>limit</strong>：取前xx个元素</p></li><li><p><strong>skip</strong>：跳过前xx个元素</p></li><li><p><strong>concat</strong>：<code>concat(Steam a,Stream b)</code> 合并a，b两个流</p></li><li><p><strong>distinct</strong>：基于<code>hashCode（）</code>和<code>equals（）</code>去重</p></li><li><p><strong>sorted</strong>：<strong>按照指的规则排序，无参数按照自然排序，有参数按照指的排序规则</strong></p><ul><li>```java<br>sorted(Comparator&lt;? super T&gt; comparator)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **mapToInt**：将xx转为intStream</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>forEach</strong>：遍历元素</p><ul><li><p>属于终结方法</p></li><li><p>```java<br>void forEach(Consumer&lt;? super T&gt; action);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **count**：返回元素总和</span><br><span class="line">  </span><br><span class="line">  - 属于终结方法</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">// filter操作</span><br><span class="line">@Test</span><br><span class="line">public void fn2()&#123;</span><br><span class="line">    ArrayList&lt;Object&gt; arr = new ArrayList&lt;Object&gt;();</span><br><span class="line">    arr.add(new Object());</span><br><span class="line">    arr.add(new Object());</span><br><span class="line">    arr.add(&quot;!@#123&quot;);</span><br><span class="line">    //  Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</span><br><span class="line">    // 进行布尔判断，为真就保存？</span><br><span class="line">    arr.stream().filter(s-&gt;(s instanceof String)).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// limit和skip操作</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        arr.add(<span class="string">&quot;qeasfsa&quot;</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;789&quot;</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;/45662*&quot;</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;/asfg*&quot;</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;/阿斯弗*&quot;</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;/撒法发*&quot;</span>);</span><br><span class="line">        <span class="comment">// limit 取前三个元素</span></span><br><span class="line">        arr.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        <span class="comment">// skip 跳过前3个元素</span></span><br><span class="line">        arr.stream().skip(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;**********&quot;</span>);</span><br><span class="line">        <span class="comment">// 跳过两个，剩下的前三个输出</span></span><br><span class="line">        arr.stream().skip(<span class="number">2</span>).limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concat 和 distinct</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arr.add(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;2222&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;3333&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;4444&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;5555&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;6666&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;7777&quot;</span>);java</span><br><span class="line">        Stream&lt;String&gt; limit = arr.stream().limit(<span class="number">5</span>);</span><br><span class="line">    Stream&lt;String&gt; skip = arr.stream().skip(<span class="number">3</span>);</span><br><span class="line">    Stream&lt;String&gt; concat = Stream.concat(limit, skip);</span><br><span class="line">    <span class="comment">// stream has already been operated upon or closed</span></span><br><span class="line">    <span class="comment">// concat.forEach(System.out::println);</span></span><br><span class="line">    System.out.println(<span class="string">&quot;***********&quot;</span>);</span><br><span class="line">    concat.distinct().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sorted</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arr.add(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;22122&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;3332333&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;4123444&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;a5555&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;6dsf666&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;7ds777&quot;</span>);</span><br><span class="line">    <span class="comment">//在测试一次</span></span><br><span class="line">    <span class="comment">// arr.stream().sorted().forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认从小到大排序。返回正数代表大！</span></span><br><span class="line">    arr.stream().sorted((s1, s2) -&gt; s1.length() - s2.length()).forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;***&quot;</span>);</span><br><span class="line">    <span class="comment">// 反过来就是从大到小</span></span><br><span class="line">    arr.stream().sorted((s1,s2)-&gt; s2.length()-s1.length()).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mapToInt</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;12&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;32&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;45&quot;</span>);</span><br><span class="line">    IntStream intStream = list.stream().mapToInt(Integer::parseInt);</span><br><span class="line">    <span class="keyword">int</span> sum = intStream.sum();</span><br><span class="line">    intStream.forEach(System.out::println);</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="20-5-3-Stream流的收集操作"><a href="#20-5-3-Stream流的收集操作" class="headerlink" title="20.5.3 Stream流的收集操作"></a>20.5.3 Stream流的收集操作</h4><p>对数据使用Stream流的方式进行操作后，把流中的数据收集到集合中</p><ul><li>R collect（Collector c）</li><li>参数是一个Collector接口</li><li>常用方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;12&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;32&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;45&quot;</span>);</span><br><span class="line">    <span class="comment">// 收集到List中</span></span><br><span class="line">    Stream&lt;String&gt; stream = list.stream().filter(s -&gt; s.length() &gt; <span class="number">3</span>);</span><br><span class="line">    List&lt;String&gt; collect = stream.collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集到Set中</span></span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    set.add(<span class="string">&quot;!2312313&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;!13&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;!453&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;!231&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;!412&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; Setstream = set.stream().filter(s -&gt; s.length() &gt; <span class="number">5</span>);</span><br><span class="line">    Setstream.collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集到Map中</span></span><br><span class="line">    <span class="comment">// 定义一个字符串数组，每一个字符串数据由姓名数据和年龄数据组合而成</span></span><br><span class="line">    String[] arra = &#123;<span class="string">&quot;xx,18&quot;</span>, <span class="string">&quot;ljw,20&quot;</span>, <span class="string">&quot;lh,23&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 得到年龄大于等于20的</span></span><br><span class="line">    Stream&lt;String&gt; age = Stream.of(arra).filter(s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt; <span class="number">19</span>);</span><br><span class="line">    <span class="comment">// 姓名作为key 年龄作为value</span></span><br><span class="line">    <span class="comment">// age.collect(key,value);</span></span><br><span class="line">    <span class="comment">// 年龄大于等于20的被封装成了map</span></span><br><span class="line">    Map&lt;String, String&gt; collect1 = age.collect(Collectors.toMap(s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>], s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]));</span><br><span class="line">    Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream1 = collect1.entrySet().stream();</span><br><span class="line">    stream1.forEach( s -&gt; System.out.println(s.getKey() + <span class="string">&quot;:&quot;</span> + s.getValue()) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二十一-JDBC"><a href="#二十一-JDBC" class="headerlink" title="二十一 JDBC"></a>二十一 JDBC</h2><h3 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h3><p>在 src 下放配置文件 <code>c3p0-config.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/jdbc_demo<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用 C3P0 获取数据库连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C3P0Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection connection = dataSource.getConnection();</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(<span class="string">&quot;select * from student&quot;</span>);</span><br><span class="line">        ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">            System.err.println(resultSet.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Druid"><a href="#使用-Druid" class="headerlink" title="使用 Druid"></a>使用 Druid</h3><p>配置文件 druid.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql:///jdbc_demo</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure><p>用 Druid 获取数据库连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">        properties.load(is);</span><br><span class="line">        DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        Connection connection = dataSource.getConnection();</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(<span class="string">&quot;select * from student&quot;</span>);</span><br><span class="line">        ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            System.out.println(resultSet.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resultSet == <span class="keyword">null</span>) resultSet.close();</span><br><span class="line">        <span class="keyword">if</span> (preparedStatement == <span class="keyword">null</span>) preparedStatement.close();</span><br><span class="line">        <span class="keyword">if</span> (connection == <span class="keyword">null</span>) connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"><span class="keyword">import</span> com.bbxx.nature.Student;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spring的jdbc模板操作</span></span><br><span class="line"><span class="comment"> * 需要依赖一个数据源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SprintJDBCTemplate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(DataSourceUtils.getDataSource());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> update = jdbcTemplate.update(<span class="string">&quot;update student set name=&#x27;xxx&#x27; where id=4&quot;</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> update = jdbcTemplate.update(<span class="string">&quot;insert into student(name,phone,address) values(?,?,?)&quot;</span>, <span class="string">&quot;liuj&quot;</span>, <span class="string">&quot;11112312&quot;</span>, <span class="string">&quot;aor you kou&quot;</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> liuj = jdbcTemplate.update(<span class="string">&quot;delete from student where name=?&quot;</span>, <span class="string">&quot;liuj&quot;</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>, liuj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只能是单个数据。封装为map集合。key为字段名，value为字段值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">querySingleForMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = jdbcTemplate.queryForMap(<span class="string">&quot;select * from student where id=?&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(map.keySet().size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多条结果集</span></span><br><span class="line"><span class="comment">     * 每天结果都封装为map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryListMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(<span class="string">&quot;select * from student&quot;</span>);</span><br><span class="line">        maps.stream().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Student&gt; query = jdbcTemplate.query(<span class="string">&quot;select * from student&quot;</span>, <span class="keyword">new</span> RowMapper&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Student <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                Student student = <span class="keyword">new</span> Student();</span><br><span class="line">                student.setId(resultSet.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                student.setAddress(resultSet.getString(<span class="string">&quot;address&quot;</span>));</span><br><span class="line">                student.setPhone(resultSet.getString(<span class="string">&quot;phone&quot;</span>));</span><br><span class="line">                student.setName(resultSet.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span> student;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 函数式编程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;Student&gt; query1 = jdbcTemplate.query(<span class="string">&quot;select * from student&quot;</span>, (resultSet,i)-&gt;&#123;</span><br><span class="line">            Student student = <span class="keyword">new</span> Student();</span><br><span class="line">            student.setId(resultSet.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">            student.setName(resultSet.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            student.setPhone(resultSet.getString(<span class="string">&quot;phone&quot;</span>));</span><br><span class="line">            student.setAddress(resultSet.getString(<span class="string">&quot;address&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> student;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        query1.stream().forEach(s-&gt;&#123;</span><br><span class="line">            System.out.println(s.getName()+s.getPhone());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String sql, RowMapper&lt;T&gt; rowMapper</span></span><br><span class="line"><span class="comment">     * 也可以传这个BeanPropertyRowMapper 用反射进行映射。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryList2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Student&gt; query = jdbcTemplate.query(<span class="string">&quot;select * from student&quot;</span>, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Student&gt;(Student.class));</span><br><span class="line">        query.stream().forEach(s-&gt;&#123;</span><br><span class="line">            System.out.println(s.getName());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryForObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Integer integer = jdbcTemplate.queryForObject(<span class="string">&quot;select count(1) from student&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataSourceUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties properties = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        InputStream is = DataSourceUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(is);</span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>) is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">            DataSource dataSource = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第三部分-加强"><a href="#第三部分-加强" class="headerlink" title="第三部分 加强"></a>第三部分 加强</h1><h2 id="第一章-枚举"><a href="#第一章-枚举" class="headerlink" title="第一章 枚举"></a>第一章 枚举</h2><h3 id="1-1-枚举的使用Demo"><a href="#1-1-枚举的使用Demo" class="headerlink" title="1.1 枚举的使用Demo"></a>1.1 枚举的使用Demo</h3><p>下面看一段骚气的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">judge</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;AAA&quot;</span>.equals(str))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AAA&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;BBB&quot;</span>.equals(str))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BBB&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;CCC&quot;</span>.equals(str))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CCC&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;DDD&quot;</span>.equals(str))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DDD&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>条件一多 就要该源码【扩展性弱】，有没有解决办法</li><li>代码看起来不优雅，有没有解决办法</li></ul><p><strong>枚举！</strong></p><blockquote><p><strong>第一版，用枚举替代if else</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接用枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RoleOperation1</span> </span>&#123;</span><br><span class="line">    ADMIN_POWER,</span><br><span class="line">    NORMAL_POWER,</span><br><span class="line">    SUPER_POWER</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为有返回值 所以这样定义</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RoleOperation2</span> </span>&#123;</span><br><span class="line">    ADMIN_POWER() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Admin power&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    NORMAL_POWER() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Normal power&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUPER_POWER() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Super power&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为有统一的方法，所以用接口定义规则</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">op</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  漂亮的枚举代码，虽然看起来长，复杂，但是拓展性特别强！</span></span><br><span class="line"><span class="comment">// 下面就是见证奇迹的时刻，优雅地用枚举替代if else。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RoleOperation</span> <span class="keyword">implements</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    ADMIN_POWER() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">op</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Admin power&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    NORMAL_POWER() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">op</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Normal power&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUPER_POWER() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">op</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Super power&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如此优雅的代码！！</span></span><br><span class="line">    <span class="comment">// 还有用工厂模式 策略模式的。感觉都不如枚举来的优雅。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">judge</span><span class="params">(String role)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RoleOperation.valueOf(role).op();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-枚举的常用方法"><a href="#1-2-枚举的常用方法" class="headerlink" title="1.2 枚举的常用方法"></a>1.2 枚举的常用方法</h3><table><thead><tr><th>values()</th><th>以数组形式返回枚举类型的所有成员</th></tr></thead><tbody><tr><td>valueOf()</td><td>将普通字符串转换为枚举实例</td></tr><tr><td>compareTo()</td><td>比较两个枚举成员在定义时的顺序</td></tr><tr><td>ordinal()</td><td>获取枚举成员的索引位置</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举中一些常用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeFunc</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Color[] values = Color.values();</span><br><span class="line">        <span class="keyword">for</span> (Color c : values) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  将普通字符串实例转换为枚举</span></span><br><span class="line">        Color blue = Color.valueOf(<span class="string">&quot;BLUE&quot;</span>);</span><br><span class="line">        System.out.println(blue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Color.BLUE.ordinal());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     public final int compareTo(E o) &#123;</span></span><br><span class="line"><span class="comment">     *         Enum&lt;?&gt; other = (Enum&lt;?&gt;)o;</span></span><br><span class="line"><span class="comment">     *         Enum&lt;E&gt; self = this;</span></span><br><span class="line"><span class="comment">     *         if (self.getClass() != other.getClass() &amp;&amp; // optimization</span></span><br><span class="line"><span class="comment">     *             self.getDeclaringClass() != other.getDeclaringClass())</span></span><br><span class="line"><span class="comment">     *             throw new ClassCastException();</span></span><br><span class="line"><span class="comment">     *         return self.ordinal - other.ordinal;</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// RED 和 BLUE比较， RED小于BLUE 返回负数 ；equals返回0；大于返回 正数</span></span><br><span class="line">        System.out.println(Color.RED.compareTo(Color.BLUE)); <span class="comment">// -1</span></span><br><span class="line">        System.out.println(Color.RED.compareTo(Color.GREEN));<span class="comment">// -2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Color.RED);</span><br><span class="line">        <span class="comment">// output RED</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    RED, BLUE, GREEN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二章-比较对象"><a href="#第二章-比较对象" class="headerlink" title="第二章 比较对象"></a>第二章 比较对象</h2><p><strong>Comparator和Comparable</strong></p><p>Comparable接口/ Comparator接口</p><ul><li>Comparator  函数式接口 jdk1.8引入</li><li>Comparable 普通接口</li></ul><h2 id="第三章-单元测试"><a href="#第三章-单元测试" class="headerlink" title="第三章 单元测试"></a>第三章 单元测试</h2><h3 id="3-1-单元测试的优点"><a href="#3-1-单元测试的优点" class="headerlink" title="3.1 单元测试的优点"></a>3.1 单元测试的优点</h3><p>保证的程序代码的正确性【语法上了逻辑上】。</p><h3 id="3-2单元测试的使用"><a href="#3-2单元测试的使用" class="headerlink" title="3.2单元测试的使用"></a>3.2单元测试的使用</h3><p>@Test</p><ul><li>@Before 无论Test是否出现异常，都会执行 【初始化资源】</li><li>@After 无论Test是否出现异常，都会执行 【销毁资源】</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JunitDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OutputStream outputStream;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO 流初始化完毕了&quot;</span>);</span><br><span class="line">        outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;junit.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单元测试判断数据的正确性</span></span><br><span class="line"><span class="comment">     * 一般用Assert里面的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 断言不为null  不是null则成功</span></span><br><span class="line">        Assert.assertNotNull(outputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO 流关闭了&quot;</span>);</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-单元测试原理"><a href="#3-3-单元测试原理" class="headerlink" title="3.3 单元测试原理"></a>3.3 单元测试原理</h3><h2 id="第四章-反射"><a href="#第四章-反射" class="headerlink" title="第四章 反射"></a>第四章 反射</h2><h3 id="4-1-反射概述"><a href="#4-1-反射概述" class="headerlink" title="4.1 反射概述"></a>4.1 反射概述</h3><p>反射可以把类的各个组成部分封装为其他对象。</p><p>反射，Java的高级特性，流行的框架基本都是基于反射的思想写成的。</p><p>Java反射机制是在程序的运行过程中，对于任何一个类，都能够知道它的所有属性和方法；对于任意一个对象，都能够知道它的所有属性和方法，**<span style="color:green">这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。</span>**</p><p>Java反射机制主要提供了以下这几个功能：</p><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所有的成员变量和方法</li><li>在运行时调用任意一个对象的方法</li></ul><h3 id="4-2-反射的基本操作"><a href="#4-2-反射的基本操作" class="headerlink" title="4.2 反射的基本操作"></a>4.2 反射的基本操作</h3><h4 id="4-2-1-获取成员变量"><a href="#4-2-1-获取成员变量" class="headerlink" title="4.2.1 获取成员变量"></a>4.2.1 获取成员变量</h4><ul><li><code>File[] getFileds()</code> // <strong>获得所有公有字段，包括继承的</strong></li><li><code>Filed getFiled(String name)</code> // 获取指定name的</li><li><code>Filed[] getDeclaredFileds() </code>// 获取该类自己声明的，包括私有</li><li><code>Filed[] getDeclaredFileds(String name)</code> // 获取指定名称的</li></ul><h4 id="4-2-2-获取构造方法"><a href="#4-2-2-获取构造方法" class="headerlink" title="4.2.2 获取构造方法"></a>4.2.2 获取构造方法</h4><ul><li><p><code>Constructor&lt;?&gt;[] getConstructors()</code> // 获得所有公有构造器</p></li><li><p><code>Constructor&lt;?&gt; getConstructor(Class&lt;?&gt;...parameterTypes)</code> //获得指定参数的公有构造器</p></li><li><p><code>Constructor&lt;?&gt;[]getDeclaredConstructors()</code>// 获得所有私有构造器</p></li><li><p><code>Constructor&lt;T&gt;[]getDeclaredConstructors()</code>//  得指定参数的构造器【包括public~~~private 】</p></li></ul><h4 id="4-2-3-获取成员方法"><a href="#4-2-3-获取成员方法" class="headerlink" title="4.2.3 获取成员方法"></a>4.2.3 获取成员方法</h4><ul><li><p><code>Method[] getMethods()</code> // <strong>获得所有public修饰的方法，包括继承的</strong></p></li><li><p><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code> // 获得指定名称和参数类型的public修饰的方法</p></li><li><p><code>Method[] getDeclaredMethods()</code> //获得所有的私有方法</p></li><li><p><code>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code> // 获得指定名称和参数类型的方法</p></li></ul><h4 id="4-2-4-获取类名"><a href="#4-2-4-获取类名" class="headerlink" title="4.2.4 获取类名"></a>4.2.4 获取类名</h4><ul><li><code>String getName()</code> // 获得类全名<code>com.bbxx.junits.Son</code></li></ul><h4 id="4-2-5-几个重要的类"><a href="#4-2-5-几个重要的类" class="headerlink" title="4.2.5 几个重要的类"></a>4.2.5 几个重要的类</h4><blockquote><p><strong>Class类</strong></p></blockquote><p>每定义一个<code>java</code> <code>class</code> 实体都会产生一个Class对象。我们编写一个类，编译完成后，在生成的 <code>.class</code>文件中，就会产生一个Class对象，这个Class对象用于表示这个类的类型信息。Class中没有公共构造器，即Class对象不能被实例化。</p><blockquote><p><strong>Field类</strong></p></blockquote><p>Field类提供类或接口中单独字段的信息，以及对单独字段的动态访问。</p><blockquote><p><strong>Method类</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke(Object obj, Object... args)</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>ClassLoader</code>类</strong></p></blockquote><p><strong><span style="color:green">ClassLoader类加载器！类加载器用来把类（class）装载进JVM的。ClassLoader使用的双亲委派模型来搜索加载类的，这个模型也就是双亲委派模型。</span></strong></p><p><strong><code>ClassLoader</code>的类继承图如下：</strong></p><img src="D:\69546\Documents\pics\JavaStrengthen\classLoader.png" style="float:left"><h3 id="4-3-动态代理"><a href="#4-3-动态代理" class="headerlink" title="4.3 动态代理"></a>4.3 动态代理</h3><h4 id="4-3-1-作用"><a href="#4-3-1-作用" class="headerlink" title="4.3.1 作用"></a>4.3.1 作用</h4><p>运行时，动态创建一组指定的接口的实现类对象！（在运行时，创建实现了指定的一组接口的对象）</p><p>动态代理对比其他方法增强方式</p><img src="D:\69546\Documents\pics\JavaStrengthen\proxy.png" style="float:left"><h4 id="4-3-2-基本Demo"><a href="#4-3-2-基本Demo" class="headerlink" title="4.3.2 基本Demo"></a>4.3.2 基本Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Object o = 方法(<span class="keyword">new</span> Class[]&#123; A.class, B.class &#125;)</span><br><span class="line">o 它实现了A和B两个接口！</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object proxyObject = Proxy.newProxyInstance(ClassLoader classLoader, Class[] interfaces, InvocationHandler h);</span><br></pre></td></tr></table></figure><ul><li>方法的作用：动态创建实现了interfaces数组中所有指定接口的实现类对象！</li><li><code>ClassLoader</code>：类加载器！<ul><li>它是用来加载器的，把.class文件加载到内存，形成Class对象！</li></ul></li><li><code>Class[ ] interfaces</code>：指定要实现的接口们。</li><li><code>InvocationHandler</code>：代理对象的所有方法（个别不执行，一般<code>nativate</code>方法不会执行，但是<code>hashCode</code>却会执行，好奇怪）都会调用<code>InvocationHadnler</code>的<code>invoke()</code>方法</li><li>动态代理的作用<ul><li>最终是学习<code>AOP</code>（面向切面编程），它与装饰者模式有点相似，它比装饰者模式更灵活（潜在含义，动态代理更难！）</li></ul></li></ul><p><strong>动态代理基本Demo</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">IBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;getName&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 获得类加载器</span></span><br><span class="line">        ClassLoader classLoader = person.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 获得被代理对象实现的接口</span></span><br><span class="line">        Class[] interfaces = person.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 实例化一个处理器 用于增强方法用的</span></span><br><span class="line">        InvocationHandler h = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                method.invoke(person, args);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        IBase p = (IBase) Proxy.newProxyInstance(classLoader, interfaces, h);</span><br><span class="line">        <span class="comment">// 获得代理类的名称 com.sun.proxy.$Proxy0</span></span><br><span class="line">        System.out.println(p.getClass().getName());</span><br><span class="line">        p.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-3-invoke解释"><a href="#4-3-3-invoke解释" class="headerlink" title="4.3.3 invoke解释"></a>4.3.3 invoke解释</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br></pre></td></tr></table></figure><p><strong>这个invoke什么时候被调用？</strong></p><ul><li>在调用代理对象所实现接口中的方法时被调用！</li></ul><p><strong>参数解释</strong></p><ul><li><code>Object proxy</code>：当前对象，即代理对象！在调用谁的方法！</li><li><code>Method method</code>：当前被调用的方法（目标方法）</li><li><code>Object [ ] args</code>：实参</li><li>返回的是方法的返回值。</li></ul><img src="D:\69546\Documents\pics\JavaStrengthen\invoke_explain.png" style="float:left"><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        ClassLoader classLoader = person.getClass().getClassLoader();</span><br><span class="line">        Class[] interfaces = person.getClass().getInterfaces();</span><br><span class="line">        System.out.println(interfaces.length);</span><br><span class="line">        InvocationHandler h = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Object retVal = method.invoke(person, args);</span><br><span class="line">                 <span class="comment">// 这个返回了，方法才有返回值 </span></span><br><span class="line">                <span class="keyword">return</span> retVal; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        IBase p = (IBase) Proxy.newProxyInstance(classLoader, interfaces, h);</span><br><span class="line">        p.say();</span><br><span class="line">        <span class="comment">// invoke返回null的话，这里的输出就是null</span></span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-模拟AOP"><a href="#4-4-模拟AOP" class="headerlink" title="4.4 模拟AOP"></a>4.4 模拟<code>AOP</code></h3><p><code>Spring AOP</code>，感受一下什么叫增强内容可变！</p><ul><li><code>ProxyFactory</code> 代理工厂</li><li><code>IBeforeAdvice</code> 前置通知接口【方法执行前调用前置】</li><li><code>IAfterAdvice</code> 后置通知接口【方法执行后调用后置】</li><li><code>IWaiter</code> 服务员类接口</li><li><code>ManWaiterImple</code> 具体的服务员类【对他进行增强】</li></ul><h2 id="第五章-注解"><a href="#第五章-注解" class="headerlink" title="第五章 注解"></a>第五章 注解</h2><p><strong>注解也叫元数据</strong>。是一种代码级别的说明，JDK1.5引入的特性，与类，接口，枚举是在同一层次。<strong>可声明在包，类，字段，方法，局部变量，方法参数等的前面</strong>，对这些元素进行说明。</p><p><strong>作用分类：</strong></p><p>1.代码分析，通过代码里标识的元数据对代码进行分析【结合反射技术】</p><p>2.编译检查，通过代码里标识的元数据让编译器能够实现机泵的编译检查【Override】</p><p>3.编写文档，通过代码里标识的元数据生成文档【生成文档doc文档】</p><h3 id="5-1-内置注解"><a href="#5-1-内置注解" class="headerlink" title="5.1 内置注解"></a>5.1 内置注解</h3><ul><li><code>Override</code>：检测被标注的是否继承自父类</li><li><code>Deprecated</code>：表示方法过时</li><li><code>SuppressWarnings</code>：压制警告<ul><li>一般传递参数all</li></ul></li></ul><h3 id="5-2-自定义注解"><a href="#5-2-自定义注解" class="headerlink" title="5.2 自定义注解"></a>5.2 自定义注解</h3><blockquote><p><strong>元注解<code>public @interface annotationName&#123;&#125;</code></strong></p></blockquote><p>反编译发现，本质就是一个接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> <span class="keyword">extends</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-1-属性的返回值"><a href="#5-2-1-属性的返回值" class="headerlink" title="5.2.1 属性的返回值"></a>5.2.1 属性的返回值</h4><p><strong>基本数据类型    String    枚举    注解    以上类型的数组</strong></p><h4 id="5-2-2-赋值问题"><a href="#5-2-2-赋值问题" class="headerlink" title="5.2.2 赋值问题"></a>5.2.2 赋值问题</h4><p>设置默认值<code>String sex() default &quot;1&quot;;</code></p><p>使用注解，数组类型的赋值 <code>str=&#123;xx,xx,xx&#125;</code>，若数组中只有一个，大括号可省略。回忆Spring中注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 基本数据类型</span><br><span class="line">* String</span><br><span class="line">* 枚举</span><br><span class="line">* 注解</span><br><span class="line">* 以上类型的数组</span><br></pre></td></tr></table></figure><h3 id="5-3-元注解"><a href="#5-3-元注解" class="headerlink" title="5.3 元注解"></a>5.3 元注解</h3><blockquote><p><strong>用于描述注解的注解</strong></p></blockquote><p><code>@Target</code>：描述注解的位置</p><ul><li><code>ElementType</code>取值<ul><li>TYPE：可以作用于类上</li><li>METHOD：可以作用于方法上</li><li>FIELD：可以作用于成员变量上</li></ul></li></ul><p><code>@Retention</code>：描述注解是被保留的阶段</p><p><code>@Retention(RetentionPolicy.RUNTIME)</code>：当前被描述的注解，会保留到class字节码文件中，并被<code>JVM</code>读取到</p><p><code>@Documented</code>：描述注解是否被抽取到api文档中</p><p><code>@Inherited</code>：描述注解是否被子类继承</p><h3 id="5-4-注解的解析"><a href="#5-4-注解的解析" class="headerlink" title="5.4 注解的解析"></a>5.4 注解的解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Pro &#123;</span><br><span class="line">    <span class="function">String <span class="title">className</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">methodName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pro(className = &quot;com.bbxx.Demo1&quot;,methodName = &quot;show1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefelectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解析注解</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;RefelectDemo&gt; refelectDemoClass = RefelectDemo.class;</span><br><span class="line">        Pro annotation = refelectDemoClass.getAnnotation(Pro.class);</span><br><span class="line">        String s = annotation.className();</span><br><span class="line">        String s1 = annotation.methodName();</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(s);</span><br><span class="line">        Object o = aClass.newInstance();</span><br><span class="line">        Method declaredMethod = aClass.getDeclaredMethod(s1);</span><br><span class="line">        declaredMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        declaredMethod.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第六章-类加载器"><a href="#第六章-类加载器" class="headerlink" title="第六章 类加载器"></a>第六章 类加载器</h2><h3 id="6-1-分类"><a href="#6-1-分类" class="headerlink" title="6.1 分类"></a>6.1 分类</h3><p><code>ClassLoad</code>分类</p><ul><li>引导 类加载器—–&gt;负责加载类库 rt中的jar 【最高，Bootstrap】</li><li>扩展 类加载器—–&gt;负责加载扩展jar包  ext下的都是扩展jar</li><li>系统 类加载器—–&gt;应用下的类，包含开发人员写的类和三方jar包【最低】</li></ul><p><code>ClassLoad</code>有个双亲委派模型，会先问父   类加载器/上级类加载器，向上级委托，没有就自己加载，没找到就抛出<code>ClassNotFound</code>。永远不会出现类库中的类被系统加载器加载，应用下的类 被引导加载。</p><p>委托父加载器加载，父可以加载就让父加载。父无法加载时再自己加载。</p><ul><li>可避免类的重复加载，父类加载器已经加载了该类时，就没必要子<code>ClassLoader</code>再加载一次了/</li><li>考虑到安全因素，<code>java</code>核心<code>api</code>中定义类型不会被随意替换。</li></ul><h3 id="6-2-类加载的顺序"><a href="#6-2-类加载的顺序" class="headerlink" title="6.2 类加载的顺序"></a>6.2 类加载的顺序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123; <span class="comment">// 系统加载</span></span><br><span class="line">        <span class="comment">// 也由系统加载</span></span><br><span class="line">        A a = <span class="keyword">new</span> A(); </span><br><span class="line">        <span class="comment">// 也由系统加载 （从系统开始匹配，最终会委托上去， ...由引导加载）</span></span><br><span class="line">        String s = <span class="keyword">new</span> String();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span>&#123; <span class="comment">// 引导加载， String类，类库中的</span></span><br><span class="line">    <span class="keyword">private</span> Integer i;<span class="comment">// 直接引导加载，毕竟无法委托了！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实还得分线程，每个线程都有一个当前的类加载器来负责加载类。</p><h3 id="6-3-流程"><a href="#6-3-流程" class="headerlink" title="6.3 流程"></a>6.3 流程</h3><p>基础阶段 <strong>了解</strong>，中级阶段 <strong>熟悉</strong>，高级阶段，<strong>不清楚</strong>。</p><p>继承<code>ClassLoader</code>类完成自定义类加载器。自定义类加载器一般是为了加载网络上的类，class在网络中传输，为了安全，那么class需要加密，需要自定义类加载器来加载（对class做解密工作）</p><p><code>ClassLoader</code>加载类都是通过==<code>loadClass()</code>==方法来完成的。<code>loadClass()</code>方法的工作流程如下：</p><ul><li>调用==<code>findLoadedClass()</code>==方法查看该类是否已经被加载过了，如果该类没有加载过，那么这个方法返回null。</li><li>判断<code>findLoadedClass()</code>返回的是否为null,如果不是null那么直接返回，可避免同一个类被加载两次。</li><li>如果<code>findLoadedClass()</code>返回的是null, 那么就启动代理模式（委托机制），即调用上级的<code>loadClass()</code>方法，获取上级的方法是<code>getParent()</code>，当然上级可能还有上级，这个动作就一直向上走；（==双亲委派机制==，tomcat破坏了双亲委派模型）</li><li>如果<code>getParent().loadClass()</code>返回的不是null，这说明上级加载成功了，那么就加载结果；</li><li>如果上级返回的是null，说明需要自己出手，<code>loadClass()</code>方法会调用本类的<code>findClass()</code>方法来加载类</li><li>这说明我们只需要重写<code>ClassLoader</code>的<code>findClass()</code>方法，这就可以了！如果重写了<code>loadClass()</code>方法覆盖了代理模式！</li></ul><p>我们要自定义一个类加载器，只需要继承<code>ClassLoader</code>类。然后重写它的<code>findClass()</code>方法即可。在<code>findClass()</code>中我们需要完成如下的工作！</p><ul><li>找到class文件，把它加载到一个byte[]中</li><li>调用<code>defineClass()</code>方法，把byte[]传递给这个方法即可</li></ul><h3 id="6-4-自定义类加载器"><a href="#6-4-自定义类加载器" class="headerlink" title="6.4 自定义类加载器"></a>6.4 自定义类加载器</h3><blockquote><p><strong>文件类加载器</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String directory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String _directory, ClassLoader paraent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(paraent);</span><br><span class="line">        <span class="keyword">this</span>.directory = _directory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 把类名转为目录</span></span><br><span class="line">            String file = directory + File.separator + name.replace(<span class="string">&quot;.&quot;</span>, File.separator) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            <span class="comment">// 构建输入流</span></span><br><span class="line">            InputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] byteArray = baos.toByteArray();</span><br><span class="line">            fis.close();</span><br><span class="line">            baos.close();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, byteArray, <span class="number">0</span>, byteArray.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>热部署，越过双亲委派，就是不用<code>loadClass</code> 用<code>findClass</code></p><blockquote><p><strong>复杂例子</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类加载器学习</span></span><br><span class="line"><span class="comment"> * 注意maven中的单元测试只能写在 test下面！</span></span><br><span class="line"><span class="comment"> * 字节码文件请自己生成一个 然后调用对应的方法哦！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类加载器的地盘，指明加载那个地方的class文件</span></span><br><span class="line">    <span class="keyword">private</span> String classpath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassLoaderDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassLoaderDemo</span><span class="params">(String classpath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classpath = classpath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoaderDemo classLoaderDemo = <span class="keyword">new</span> ClassLoaderDemo();</span><br><span class="line">        classLoaderDemo.fun2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行字节码的非静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoaderDemo classLoaderDemo = <span class="keyword">new</span> ClassLoaderDemo(<span class="string">&quot;D:\\&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = classLoaderDemo.loadClass(<span class="string">&quot;org.example.classloader.ClassLoaderTest&quot;</span>);</span><br><span class="line">        <span class="comment">// loaderSay是一个非静态方法，需要一个实例调用</span></span><br><span class="line">        Method loaderSay = clazz.getMethod(<span class="string">&quot;loaderSay&quot;</span>);</span><br><span class="line">        ClassLoaderTest o = (ClassLoaderTest) clazz.newInstance();</span><br><span class="line">        <span class="comment">// 非静态方法需要一个实例进行调用</span></span><br><span class="line">        loaderSay.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行字节码的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoaderDemo classLoaderDemo = <span class="keyword">new</span> ClassLoaderDemo(<span class="string">&quot;D:\\&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = classLoaderDemo.loadClass(<span class="string">&quot;org.example.classloader.ClassLoaderTest&quot;</span>);</span><br><span class="line">        <span class="comment">// loaderSay是一个非静态方法，需要一个实例调用</span></span><br><span class="line">        Method loaderSay = clazz.getMethod(<span class="string">&quot;loaderStaticFunction&quot;</span>);</span><br><span class="line">        <span class="comment">// 静态方法不用实例</span></span><br><span class="line">        String result = (String) loaderSay.invoke(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写这个方法即可</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 自定义的方法，通过类名找到class文件，把文件加载到一个字节数组中</span></span><br><span class="line">            <span class="keyword">byte</span>[] datas = getClassData(name);</span><br><span class="line">            <span class="keyword">if</span> (datas == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;类没有找到：&quot;</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, datas, <span class="number">0</span>, datas.length);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;类找不到:&quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String name) &#123;</span><br><span class="line">        <span class="comment">// 把名字换成文件夹的名字</span></span><br><span class="line">        name = name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;\\&quot;</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        File classFile = <span class="keyword">new</span> File(classpath, name);</span><br><span class="line">        System.out.println(classFile.getAbsoluteFile());</span><br><span class="line">        <span class="keyword">return</span> readClassData(classFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] readClassData(File classFile) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!classFile.exists()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(classFile);</span><br><span class="line">            bytes = fis.readAllBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-5-Tomcat类加载器"><a href="#6-5-Tomcat类加载器" class="headerlink" title="6.5 Tomcat类加载器"></a>6.5 Tomcat类加载器</h3><p>tomcat提供了两种类加载器。</p><p><strong>第一种 服务器类加载器</strong></p><ul><li>${CATALINA-HOME}\lib\，tomcat类加载器，它负责加载下面的类</li></ul><p><strong>第二种 应用类加载器</strong></p><ul><li>${CONTEXT}\WEB-INF\lib  </li><li>${CONTEXT}\WEB-INF\classes</li></ul><p><strong>总结</strong></p><p>tomcat破坏了双亲委派模型</p><p>引导</p><p>扩展</p><p>系统</p><p>服务器类加载器：先自己动手，然后再去委托</p><p>应用类加载器：先自己动手，然后再去委托</p><img src="D:\69546\Documents\pics\JavaStrengthen\tomcat_classLoader.png" style="float:left"><h2 id="第七章-并发"><a href="#第七章-并发" class="headerlink" title="第七章 并发"></a>第七章 并发</h2><h3 id="7-1-注意"><a href="#7-1-注意" class="headerlink" title="7.1 注意"></a>7.1 注意</h3><blockquote><p><strong>不要调用Thread类或Runnable对象的run方法</strong>。直接调用run方法会在同一个线程中执行—-不会启动新的线程。调用<code>Thread.start()</code>方法会创建一个执行run方法的新线程。</p></blockquote><blockquote><p><strong>线程的六种状态</strong></p></blockquote><ul><li>New：新建</li><li>Runnable：可运行【可能在运行 或 准备运行】</li><li>Blocked：【阻塞】</li><li>Waiting：【等待】</li><li>Timed waiting：【具有指定等待时间的等待线程的线程状态。一个线程处于定时等待状态，这是由于调用了以下方法中的一种，具有指定的正等待时间】</li><li>Terminated：【终止】</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread内部的枚举类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>lock和unlock，unlock要放在finally中，确保锁可以被释放。</strong></p></blockquote><blockquote><p><strong>可重入锁，获得锁的方法（代码）可以调用持有相同锁的方法</strong></p></blockquote><blockquote><p><strong><code>ReentrantLock()</code></strong></p></blockquote><ul><li>公平锁和非公平锁。</li><li>公平锁倾向于选择等待时间长的线程，这种策略可能严重影响性能。</li><li>一般选择非公平锁。</li></ul><blockquote><p><span style="color:green"><strong>Condition，用<code>ReentrantLock()</code>的实例对象获得Condition对象</strong></span></p></blockquote><ul><li><code>await()</code> 将该线程放在这个条件的等待集中，<span style="color:green"><strong>并放弃锁！</strong></span></li><li><code>singalAll()</code> 激活等待这个条件的所有线程，把他们从等待集中移出，让他们重新成为可运行的线程！</li><li><code>singal()</code> 从该条件的等待集中随机选取一个从等待集中移出，让他们重新成为可运行的线程！</li><li><span style="color:green"><strong>用if做条件判断不合适，存在虚假唤醒的问题，用while。【<code>JDK</code>注释中有说明】</strong></span></li></ul><blockquote><p><strong>synchronized</strong></p></blockquote><blockquote><p><strong>线程就是一个单独的资源类，没有任何附属的操作。</strong></p></blockquote><blockquote><p><strong>线程局部变量 <code>ThreadLocal</code></strong></p></blockquote><ul><li><code>ThreadLocal.withInitial()</code>为函数式编程提供的方法</li></ul><p><strong>Unsafe类啊！</strong></p><h2 id="第八章-网络编程"><a href="#第八章-网络编程" class="headerlink" title="第八章 网络编程"></a>第八章 网络编程</h2><p>采用windows的<code>telent</code>工具作为客户端进行发起连接。</p><h3 id="8-1-入门"><a href="#8-1-入门" class="headerlink" title="8.1 入门"></a>8.1 入门</h3><blockquote><p><strong>Client</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试服务器连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// jdk 7 try catch用法</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="keyword">var</span> socket = <span class="keyword">new</span> Socket(<span class="string">&quot;time-a.nist.gov&quot;</span>, <span class="number">13</span>)) &#123;</span><br><span class="line">            <span class="keyword">var</span> scanner = <span class="keyword">new</span> Scanner(socket.getInputStream());</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">                System.out.println(scanner.nextLine() + <span class="string">&quot;==&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException, UnsupportedEncodingException </span>&#123;</span><br><span class="line">        String host = <span class="string">&quot;www.bilibili.com&quot;</span>;</span><br><span class="line">        InetAddress[] localhosts = InetAddress.getAllByName(host);</span><br><span class="line">        <span class="keyword">for</span> (InetAddress tmp : localhosts) &#123;</span><br><span class="line">            System.out.println(tmp.getHostAddress());</span><br><span class="line">            System.out.println(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket();</span><br><span class="line">        socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;time-a.nist.gov&quot;</span>, <span class="number">13</span>), <span class="number">10000</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(socket.getInputStream());</span><br><span class="line">        <span class="comment">// Scanner类不是很熟悉</span></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            System.out.println(scanner.nextLine());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        fun3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Server</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器端的 inputStream 和 outPutStream</span></span><br><span class="line"><span class="comment">     * inPutStream 输入流，输入到Server</span></span><br><span class="line"><span class="comment">     * outPutStream 输出流，输出到client</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8189</span>);</span><br><span class="line">        Socket accept = serverSocket.accept();</span><br><span class="line">        <span class="comment">// 控制台读入数据</span></span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(accept.getInputStream(), StandardCharsets.UTF_8);</span><br><span class="line">        <span class="comment">// 输出 IO流还是不熟悉 类的组合太复杂了</span></span><br><span class="line">        <span class="comment">// PrintWriter out = new PrintWriter(new OutputStreamWriter(accept.getOutputStream(), StandardCharsets.UTF_8), true);</span></span><br><span class="line">        OutputStreamWriter out = <span class="keyword">new</span> OutputStreamWriter(accept.getOutputStream(), StandardCharsets.UTF_8);</span><br><span class="line">        out.write(<span class="string">&quot;connected&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!done &amp;&amp; in.hasNextLine()) &#123;</span><br><span class="line">            <span class="comment">// 控制台输入数据</span></span><br><span class="line">            String line = in.nextLine();</span><br><span class="line">            <span class="comment">// 输出到客户端</span></span><br><span class="line">            out.write(<span class="string">&quot;Echo:&quot;</span> + line);</span><br><span class="line">            out.flush();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;BYE&quot;</span>.equals(line.trim())) done = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第九章-Servlet3-0"><a href="#第九章-Servlet3-0" class="headerlink" title="第九章 Servlet3.0"></a>第九章 Servlet3.0</h2><ul><li>注解</li><li>文件上传</li><li>异步处理 需要 <code>asyncSupported=true</code>，有过滤器的话，过滤器也要设置<code>asyncSupported = true</code></li></ul><p>使用型特性就是在保护你的Java职业生涯。</p><h3 id="9-1-注解替代xml"><a href="#9-1-注解替代xml" class="headerlink" title="9.1 注解替代xml"></a>9.1 注解替代<code>xml</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/index.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        request.setAttribute(<span class="string">&quot;data&quot;</span>, fakeData());</span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/demo.jsp&quot;</span>).forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;User&gt; <span class="title">fakeData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        users.addAll(Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;111&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;222&quot;</span>, <span class="string">&quot;222&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;333&quot;</span>, <span class="string">&quot;333&quot;</span>)));</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-异步响应"><a href="#9-2-异步响应" class="headerlink" title="9.2 异步响应"></a>9.2 异步响应</h3><p>异步响应如果不设置编码格式 可能会导致异步失败（有乱码，异步可能会失败；主要是告诉它响应文本是什么。）测试了一下，的确是设置好响应文本即可。</p><p>异步响应如果过滤器这些东西没有设置为异步状态，也会导致异步失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 类型 异常报告</span><br><span class="line">* 消息 当前链的筛选器或servlet不支持异步操作。</span><br><span class="line">* 描述 服务器遇到一个意外的情况，阻止它完成请求</span><br><span class="line"></span><br><span class="line">错误的原因就是过滤器没有设置  asyncSupported = true</span><br></pre></td></tr></table></figure><p><strong>代码案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/async&quot;, asyncSupported = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] getOutPutChar(String str) &#123;</span><br><span class="line">        <span class="keyword">return</span> str == <span class="keyword">null</span> ? <span class="string">&quot;   2020年 10月24日，祝各位程序员节日快乐！ 2020-1024=996，想不到吧！&quot;</span>.toCharArray() : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 不加设置响应的类型的话，就无法异步。</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        AsyncContext asyncContext = request.startAsync(request, response);</span><br><span class="line">        threadOutPut(asyncContext, response, getOutPutChar(<span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> asyncContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStr    需要输出给浏览器的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">threadOutPut</span><span class="params">(AsyncContext asyncContext, HttpServletResponse response, <span class="keyword">char</span>[] outputStr)</span> </span>&#123;</span><br><span class="line">        asyncContext.start(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                PrintWriter print = response.getWriter();</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">600</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c : outputStr) &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">180</span>);</span><br><span class="line">                    print.print(c); print.flush();</span><br><span class="line">                &#125;</span><br><span class="line">                asyncContext.complete();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                asyncContext.complete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-文件上传"><a href="#9-3-文件上传" class="headerlink" title="9.3 文件上传"></a>9.3 文件上传</h3><blockquote><p><strong>几个重要的API</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- request.getPart(<span class="string">&quot;file_name&quot;</span>) <span class="comment">// 获得文件对象Part</span></span><br><span class="line">- part.getName() <span class="comment">// 获得文件上传时的 name &lt;input name=&quot;xx&quot;&gt; 中的name</span></span><br><span class="line">- part.getSize() <span class="comment">// 获得文件的大小</span></span><br><span class="line">- part.getSubmittedFileName() <span class="comment">// 获得提交的文件的名字。上传的是 demo.txt 那么得到的就是 demo.txt</span></span><br><span class="line">- part.getInputStream(); <span class="comment">// 获得文件输入流。</span></span><br><span class="line"></span><br><span class="line">获取文件输入流后，在用输出流 存入磁盘。</span><br></pre></td></tr></table></figure><p><strong>文件上传的简单Demo</strong></p><p>文件上传用绝对路径【公司】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/upload&quot;)</span></span><br><span class="line"><span class="meta">@MultipartConfig</span> <span class="comment">// 表示它支持文件上传</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        Part part = request.getPart(<span class="string">&quot;file_name&quot;</span>);</span><br><span class="line">        System.out.println(part.getName());</span><br><span class="line">        System.out.println(part.getSize());</span><br><span class="line">        System.out.println(part.getSubmittedFileName());</span><br><span class="line">        InputStream inputStream = part.getInputStream();</span><br><span class="line">        <span class="comment">// new FileOutputStream(&quot;filename&quot;) 这样是无法定位位置的，不能正常存储？</span></span><br><span class="line">        <span class="comment">//D:\citespace.projects.txt</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D://&quot;</span> + part.getSubmittedFileName());</span><br><span class="line">        <span class="comment">// citespace.projects.txt</span></span><br><span class="line">        <span class="comment">// FileOutputStream fos = new FileOutputStream(part.getSubmittedFileName());</span></span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        inputStream.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    enctype 说明有文件要提交过去</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/Tomcat/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file_name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="第十章-双亲委派"><a href="#第十章-双亲委派" class="headerlink" title="第十章 双亲委派"></a>第十章 双亲委派</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>class文件通过<strong>类加载器</strong>装载至JVM中的。为了防止内存中存放在多份同样的字节码，使用了双亲委派机制（它不会自己去尝试加载类，而是把请求委托给父加载器去完成，依次向上，避免重复加载字节码）</p><p>JDK中的本地方法类一般由根加载器（Bootstrap loader）装载；JDK中内部实现的扩展类一般由扩展加载器（ExtClassLoader）实现装载；而程序中的类文件则由系统加载器（AppClassLoader）实现装载。</p><img src="./pics/JavaStrengthen/jvm/ClassLoader.jpg"><h3 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h3><p>只要加载类的时候，不是从 App ClassLoader –&gt; Ext ClassLoader –&gt; BootStrap ClassLoader 这个顺序查找，就是打破了双亲委派机制。</p><p>加载class核心的方法在LoaderClass类的loadClass方法上（双亲委派机制的核心实现），只要我们定义个 ClassLoader，重写 loadClass 方法（不按照往上开始寻找类加载器），那就算是打破双亲委派机制了。</p><blockquote><p><strong>Tomcat打破双亲委派机制</strong></p></blockquote><p>我们部署传统javaweb项目是，把war包放到tomcat的webapp下，这意味着一个tomcat可以运行多个web应用程序；</p><hr><p>假设有两个Web应用程序，它们都有一个类，叫做User，并且它们的类全限定名都一样，如都是 <code>com.yyy.User</code>，但是他们的具体实现是不一样的。那么tomcat如何保证它们是不会冲突的？<strong>tomcat为每个Web应用创建一个类加载实例（WebAppClassLoader），该加载器重写了 loadClass 方法，优先加载当前应用目录下的嘞，如果当前找不到了，才一层一层往上找</strong>，这样就做到了Web应用层级的隔离。</p><hr><p>并不是Web应用程序下的所有依赖都需要隔离的，比如 Redis 就可以 Web 应用之间共享（有需要的话），因为如果版本相同，没必要每个Web应用程序都独自加载一份。具体做法是：Tomcat 在 WebAppClassLoader 上加了个父类加载器 （Shared ClassLoader），<strong>如果 WebAppClassLoader 自身没有加载到某个类，就委托 SharedClassLoader 去加载（把需要应用程序之间需要共享的类放到一个共享目录下，Share ClassLoader 读共享目录的类即可</strong>）。</p><p>为了隔绝Web应用程序与Tomcat本身的类，又有类加载器（CatalinaClassLoader）来装载 Tomcat 本身的依赖。如果 Tomcat 本身的依赖和 Web 应用还需要共享，那么还有类加载器（CommonClassLoader）来装载而达到共享。各个类加载器的加载目录可以到 Tomcat 的 catalina.properties 配置文件上查看。</p><hr><blockquote><p>Tomcat的类加载结构图</p></blockquote><img src="./pics/JavaStrengthen/jvm/Tomcat_ClassLoader.jpg"><blockquote><p>JDBC破坏了双亲委派？</p></blockquote><p>JDBC定义了接口，具体实现类由各个厂商进行实现。</p><p>类加载的规则如下：如果一个类由类加载器A加载，那么这个类的依赖类也是由相同的类加载器加载。</p><p>使用JDBC的时候，是使用 DriverManager 进而获取 Connection，DriverManager 在 java.sql 包下，显然是由 BootStrap 类加载器进行装载。当我们使用 DriverManager.getConnection() 时，得到的一定是厂商实现的类，<strong>但 BootStrap ClassLoader 无法加载到各个厂商实现的类</strong>，因为这些实现类没在 java 包中。DriverManager 的解决方案时 在 DriverManager 初始化的时候， 得到<strong>线程上下文加载器</strong>，去获取 Connection 的时候，是使用线程上下文加载器去加载 Connection 的，<strong>而这里的线程上下文加载器实际上还是 App ClassLoader</strong>，所以在获取 Connection 的时候，还是先找 Ext ClassLoader 和 BootStrap ClassLoader，只不过这两加载器肯定加载不到的，最终会由App ClassLoader进行加载！</p><p>有人觉得本应由 BootStrao ClassLoader 进行加载的 却改成 线程上下文加载器加载 就觉得破坏了。</p><p>有人觉得虽然改成了线程上下文加载器 但是依旧遵守 依次往上找父类加载器进行加载，都找不到时才由自己加载，认为<strong>原则</strong>上时没变的。</p><p>不重要好吧！理解为什么重要！</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>前置知识</strong>：JDK中默认类加载器有三个：AppClassLoader、Ext ClassLoader、BootStrap ClassLoader。AppClassLoader的父加载器为Ext ClassLoader、Ext ClassLoader的父加载器为BootStrap ClassLoader。这里的父子关系并不是通过继承实现的，而是组合。</p><p><strong>什么是双亲委派机制</strong>：加载器在加载过程中，先把类交由父类加载器进行加载，父类加载器没找到才由自身加载。</p><p><strong>双亲委派机制目的</strong>：为了防止内存中存在多份同样的字节码（安全）</p><p><strong>类加载规则</strong>：如果一个类由类加载器A加载，那么这个类的依赖类也是由「相同的类加载器」加载。</p><p><strong>如何打破双亲委派机制</strong>：自定义ClassLoader，重写loadClass方法（只要不依次往上交给父加载器进行加载，就算是打破双亲委派机制）</p><p><strong>打破双亲委派机制案例</strong>：Tomcat</p><ol><li>为了Web应用程序类之间隔离，为每个应用程序创建WebAppClassLoader类加载器</li><li>为了Web应用程序类之间共享，把ShareClassLoader作为WebAppClassLoader的父类加载器，如果WebAppClassLoader加载器找不到，则尝试用ShareClassLoader进行加载</li><li>为了Tomcat本身与Web应用程序类隔离，用CatalinaClassLoader类加载器进行隔离，CatalinaClassLoader加载Tomcat本身的类</li><li>为了Tomcat与Web应用程序类共享，用CommonClassLoader作为CatalinaClassLoader和ShareClassLoader的父类加载器</li><li>ShareClassLoader、CatalinaClassLoader、CommonClassLoader的目录可以在Tomcat的catalina.properties进行配置</li></ol><p><strong>线程上下文加载器</strong>：由于类加载的规则，很可能导致父加载器加载时依赖子加载器的类，导致无法加载成功（BootStrap ClassLoader无法加载第三方库的类），所以存在「线程上下文加载器」来进行加载。</p><h2 id="第十一章-Java内存模型"><a href="#第十一章-Java内存模型" class="headerlink" title="第十一章 Java内存模型"></a>第十一章 Java内存模型</h2><blockquote><p>Java内存模型概述</p></blockquote><p>Java的内存模型 Java Memory Model，简称JMM，本身是一种抽象的概念，实际上并不存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p><p>JMM关于同步的规定：</p><ul><li>线程解锁前，必须把共享变量的值刷新回主内存</li><li>线程加锁前，必须读取主内存的最新值，到自己的工作内存</li><li>加锁和解锁是同一把锁</li></ul><blockquote><p>Java内存模型三大特性</p></blockquote><p>JMM的三大特性，volatile只保证了两个，即可见性和有序性，不满足原子性</p><ul><li>可见性</li><li>原子性</li><li>有序性</li></ul><h3 id="为什么需要内存模型"><a href="#为什么需要内存模型" class="headerlink" title="为什么需要内存模型"></a>为什么需要内存模型</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>多核计算机，每个核心都会有高速缓存。高速缓存的为了解决CPU与内存（主存）直接的速度差异，L1，L2缓存一般是【每个核心独占】一份的。L3缓存一般是多核共享的。</p><p>为了让CPU提高运算效率，处理器可能会对代码进行【乱序执行】，即指令重排序，可以会议下计算机组成原理的流水线执行。</p><p>计算机中的一些操作往往是非原子性的，如 i++ 在执行的时候需要多个指令才能完成 i++ 这个操作。在单线程下，是不会存在什么问题的，因为单线程意味着无法并发。且在单线程下，编译器 /runtime/ 处理器 必须遵守 as-if-serial 语义，即它们不会对数据<strong>依赖关系的操作</strong>做重排序</p><blockquote><p>缓存数据不一致</p></blockquote><p>多个线程同时修改 【共享变量】，CPU核心下的高速缓存是 【不共享】的，多个 cache 与内存直接的数据同部如何进行的？</p><ul><li>锁总线，锁数据传输</li><li>缓存一致性协议（如MESI协议，M（Modified）E（Exclusive）S（Share）I（Invalid））</li><li>锁总线开销太大了，一般是用缓存一致性协议，没办法的时候才会用锁总线。</li></ul><h4 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h4><p>MESI协议，M（Modified）E（Exclusive）S（Share）I（Invalid）</p><p>缓存一致性协议锁的是==缓存行==进行加锁。<strong>缓存行是高速缓存存储的最小单位。</strong></p><blockquote><p>MESI原理（计组那块的知识）</p></blockquote><p>当每个 CPU 读取共享变量之前，会先识别数据的对象状态（修改、共享、独占、无效）。</p><p>==独占==：说明 CPU 将要得到的变量数据是最新的，没有被其他 CPU 同时读取。</p><p>==共享==：说明 CPU 将要得到的变量数据还是最新的，有其他 CPU 在读取，但是还没被修改。</p><p>==修改==：说明当前 CPU 正在修改该变量的值，同时会向其他 CPU 发送该数据状态为 invalid（无效）的通知，得到其他 CPU 响应后（其他 CPU 将数据状态从共享（share）变成invilid（无效）），会当前 CPU 将高速缓存的数据写到主存，并把自己的状态从 modify 变成 exclusive。如果 CPU 发现数据是 invilid 则需要从主存重新读取最新的数据。</p><p>MESI 协议做的就是判判断<strong>对象状态</strong>， 根据对象状态来采取不同的策略。在某个 CPU 在对数据进行修改时，需要<strong>同步</strong>通知其他 CPU ，表示这个数据被我修改了，你们不能用了。<strong>对比锁总线，MESI协议的“锁粒度”更小，性能更高</strong>。</p><blockquote><p>CPU 优化</p></blockquote><p>同步，意味着等待，什么都做不了，浪费 CPU 资源。解决方案是把 同步 变成 异步。修改时同步告诉其他 CPU ，而现在则把最新修改的值写到 store buffer 中，并通知其他 CPU 记得要修改状态，随后 CPU 就直接返回做其他事了。等收到其他 CPU 发过来的响应消息，再将数据更新到高速缓存中。</p><p>其他 CPU 接收到 invalid 通知时，也会把接收到的消息放入 invalid queue 中，只要写到 invalid queue 就会直接返回告诉修改数据的 CPU 已将状态置为 invalid。</p><p>异步的问题在于：现在 CPU 修改为 A 值，写到 store buffer 了，CPU 可以做其他事，如果该 CPU 又 接收指令需要修改 A 值，但上一次修改的值 还在 store buffer 中，未修改至高速缓存。 所以 CPU 在读取的时候，需要去 store buffer 看看存不存在，存在则直接取，不存在才读主存的数据。</p><blockquote><p>CPU 乱序执行</p></blockquote><p>如果是不同核心的CPU读它们共享的高速缓存，还是可能出现读旧值的问题。CPU1 修改了A值，把修改后值写到 store buffer 并通知CPU2 对该值 进行 invalid 操作，而 CPU2 可能还没收到 invalid 通知，就去做其他操作了，导致 CPU2 读到的还是旧值。这称之为 CPU 乱序执行。为了解决乱序问题，引出了<strong>内存屏障</strong></p><blockquote><p>内存屏障</p></blockquote><p>内存屏障实际上是为了解决<strong>异步优化</strong>导致 <strong>CPU乱序执行/缓存不及时可见</strong> 的问题，解决方案就是把<strong>异步优化禁用</strong>了。</p><p>内存屏障可分为：</p><ul><li>写屏障</li><li>读屏障</li><li>读写屏障</li></ul><p>屏障：操作数据时，往数据插入一条“特殊的指令”。只要遇见这条指令，那前面的操作都得【完成】。</p><p>==写屏障==：CPU当发现写屏障指令时，会把该指令<strong>之前</strong>存在于 store Buffer 所有写指令<strong>刷入高速缓存</strong>。通过这种方式就<strong>可以让CPU修改的数据可以马上暴露给其他 CPU</strong>，达到写操作可见性的效果。</p><p>==读屏障==：CPU 当发现读屏障指令时，会把该指令之前存在于 invalid queue 所有的指令都处理掉，通过这种方式就<strong>可以确保当前CPU的缓存状态是准确的</strong>，达到读操作一定是读取最新的效果。</p><p>深入Linux内核架构一书中，读、写屏障的解释：</p><ul><li>==读屏障==：是读访问内存屏障。它保证 在屏障之后发出的任何读取操作执行之前，屏障之前发出的所有读取操作都已经完成。（<strong>屏障内的所有操作完成了！然后才会执行屏障后的操作！</strong>）</li><li>==写屏障==：是写访问内存屏障。它保证 在屏障之后发出的任何写操作执行之前，屏障之前发出的所有写操作都已经完成。</li><li>编译器在屏障之前发出的读写请求完 成之前，不会处理屏障之后的任何读写请求</li></ul><h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><p>由于不同 CPU 架构的缓存体系不一样，缓存一致性协议不一样、重排序的策略不一样、所提供的内存屏障指令也有差异，为了简化 Java 开发人员的工作，==Java 封装了一套规范：Java内存模型==</p><p>Java内存模型希望屏蔽各种硬件和操作系统的访问差异，保证了Java程序在各种平台下对内存的访问都能得到一致的效果。目的是解决多线程存在的原子性、可见性（缓存一致性）以及有序性的问题。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li><p>并发问题产生的三大根源是「可见性」「有序性」「原子性」</p></li><li><p>可见性：CPU架构下存在高速缓存，每个核心下的L1/L2高速缓存不共享（不可见）</p></li><li><p>有序性：主要有三部分可能导致打破（编译器和处理器可以在不改变「单线程」程序语义的情况下，可以对代码语句顺序进行调整重新排序</p></li><li><ul><li>编译器优化导致重排序（编译器重排）<ul><li>指令集并行重排序（CPU原生重排）</li><li>内存系统重排序（CPU架构下很可能有store buffer /invalid queue 缓冲区，这种「异步」很可能会导致指令重排）</li></ul></li></ul></li><li><p>原子性：Java的一条语句往往需要多条 CPU 指令完成(i++)，由于操作系统的线程切换很可能导致 i++ 操作未完成，其他线程“中途”操作了共享变量  i ，导致最终结果并非我们所期待的。</p></li><li><p>在CPU层级下，为了解决「缓存一致性」问题，有相关的“锁”来保证，比如“总线锁”和“缓存锁”。</p></li><li><ul><li>总线锁是锁总线，对共享变量的修改在相同的时刻只允许一个CPU操作。<ul><li>缓存锁是锁缓存行(cache line)，其中比较出名的是MESI协议，对缓存行标记状态，通过“同步通知”的方式，来实现(缓存行)数据的可见性和有序性</li><li>但“同步通知”会影响性能，所以会有内存缓冲区(store buffer/invalid queue)来实现「异步」进而提高CPU的工作效率</li><li>引入了内存缓冲区后，又会存在「可见性」和「有序性」的问题，平日大多数情况下是可以享受「异步」带来的好处的，但少数情况下，需要强「可见性」和「有序性」，只能”禁用”缓存的优化。</li><li>“禁用”缓存优化在CPU层面下有「内存屏障」，读屏障/写屏障/全能屏障，本质上是插入一条”屏障指令”，使得缓冲区(store buffer/invalid queue)在屏障指令之前的操作均已被处理，进而达到 读写 在CPU层面上是可见和有序的。</li></ul></li></ul></li><li><p>不同的CPU实现的架构不一样，Java为了屏蔽硬件和操作系统访问内存的各种差异，提出了「Java内存模型」的规范，保证了Java程序在各种平台下对内存的访问都能得到一致效果。</p></li></ul><h3 id="从源码到执行"><a href="#从源码到执行" class="headerlink" title="从源码到执行"></a>从源码到执行</h3><blockquote><p>流程概述</p></blockquote><p>编译—&gt;加载—&gt;解释—&gt;执行</p><ul><li>编译：将源码文件编译成JVM可解释的class文件。会对程序做语法分析、语义分析、注解处理等操作，最后才生成字节码文件。<ul><li>典型的处理有：泛型擦出，Java的泛型擦出就是在 编译 阶段执行的。</li></ul></li><li>加载：将编译后的class文件加载到JVM中。<ul><li>加载步骤：装载—&gt;连接—&gt;初始化</li></ul></li></ul><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><blockquote><p>装载</p></blockquote><ul><li><strong>装载时机</strong>：为了节省内存的开销，不会一次把所有的类都装载到JVM，而是等到 有需要 的时候才进行装载。（如new 反射）</li><li><strong>装载发生</strong>：class文件是通过 类加载器 加载到 JVM中，为防止内存中出现多分相同的字节码，使用了双亲委派机制（不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上）</li><li><strong>装载规则</strong>：JDK中的本地犯法类一般由根加载器（Bootstrao loader）装载，JDK中内部实现的扩展类一般由扩展加载器（ExtClassLoader）实现装载，而程序中的类文件则由系统加载器（AppClassLoader）实现装载。</li></ul><p>查找并加载类的二进制数据，在JVM堆中创建一个java.lang.Class类的对象，并将类相关的信息存储在JVM方法区中。</p><p>装载后，class文件就装载到了JVM中，并创建出了对应的Class对象和类信息，并这Class对象和类信息存储到了方法区中。</p><blockquote><p>连接</p></blockquote><p>对class的信息进行验证、为类变量分配内存空间并对其赋默认值。</p><p>连接的细化步骤为：验证—&gt;准备—&gt;解析</p><ul><li>验证：验证类是否符合 Java 规范 和 JVM 规范。</li><li>准备：为类的静态变量分配内存，初始化为系统的初始值。</li><li>解析：将<strong>符号引用</strong>转为直接引用的过程。（什么是符号引用？）</li></ul><p>通过连接，对class信息做了校验并分配了内存空间和默认值。</p><blockquote><p>初始化</p></blockquote><p>为类的静态变量赋予正确的初始值。</p><p>过程：收集 class 的静态变量、静态代码块、静态方法至clinit() 方法，随后从上往下开始执行（clinit()方法？）</p><p>如果 <strong>实例化对象</strong> 则会调用方法对实例变量进行初始化，并执行对应的构造方法内的代码。（==这块感觉写到有问题，查查资料==）</p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>初始化完成后，执行某个类的方法时，会找到对应方法的字节码信息。然后交由解释器去将这些字节码信息解释成系统可以识别的指令。</p><p>字节码变成机器码的方式</p><ul><li>解释器</li><li>JIT</li></ul><p>JVM对热点代码做编译，非热点代码直接进行解释。运行频繁的数据会被解释为热点代码。</p><p>热点代码使用热点探测来检测是否为热点代码。热点探测一般两种方式：</p><ul><li>计数器 </li><li>抽样</li></ul><p>HotSpot使用的是 计数器 的方式进行探测，为每个方法准备了两类计数器：方法调用计数器和回边计数器。这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。即时编译器把热点方法的指令码保存起来，下次执行的时候就无需重复的进行解释，直接执行缓存的机器语言。</p><p><strong>执行次数大于100万次的代码会被编译成热点代码</strong></p><h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><p>操作系统把解释器解析出来的指令码，调用系统的硬件执行最终的程序指令。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul><li><p>Java跨平台因为有JVM屏蔽了底层操作系统</p></li><li><p>Java源码到执行的过程，从JVM的角度看可以总结为四个步骤：编译-&gt;加载-&gt;解释-&gt;执行</p></li><li><ul><li>「编译」经过 语法分析、语义分析、注解处理 最后才生成会class文件<ul><li>「加载」又可以细分步骤为：装载-&gt;连接-&gt;初始化。装载则把class文件装载至JVM，连接则校验class信息、分配内存空间及赋默认值，初始化则为变量赋值为正确的初始值。连接里又可以细化为：验证、准备、解析</li><li>「解释」则是把字节码转换成操作系统可识别的执行指令，在JVM中会有字节码解释器和即时编译器。在解释时会对代码进行分析，查看是否为「热点代码」，如果为「热点代码」则触发JIT编译，下次执行时就无需重复进行解释，提高解释速度</li><li>「执行」调用系统的硬件执行最终的程序指令</li></ul></li></ul></li><li><img src="./pics/JavaStrengthen/jvm/From_Java2Class.jpg"></li></ul><h3 id="Java内存模型-1"><a href="#Java内存模型-1" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>ava内存模型希望屏蔽各种硬件和操作系统的访问差异，保证了Java程序在各种平台下对内存的访问都能得到一致的效果。目的是解决多线程存在的原子性、可见性（缓存一致性）以及有序性的问题。==Java 内存模型时一种规范，JVM会实现这种规范。==</p><blockquote><p>主要内容概述</p></blockquote><ul><li>Java 内存模型的抽象结构</li><li>happen-before 规则</li><li>对 volatile 内存语义的探讨</li></ul><blockquote><p>Java 内存模型的抽象结构</p></blockquote><p>Java 内存模型定义了：Java 线程对内存数据进行交互的规范。</p><p>线程之间的 共享变量 存储在 主内存 中，每个线程都有自己私有的 本地内存，本地内存 存储了该线程以 读\写 共享变量的副本。</p><p>本地内存是 Java 内存模型的抽象概念，并不是真实存在的。</p><img src="./pics/JavaStrengthen/jvm/JMM.jpg"><p>Java 内存模型规定了：线程对变量的所有操作都必须在 <strong>本地内存</strong> 进行，<strong>不能直接读写主内存</strong> 的变量。</p><p>Java内存模型定义了 8 种 操作来完成 变量如何从主内存到本地内存，以及变量如何从本地内存到主内存。分别是 read/load/use/assign/store/writer/lock/unlock操作。</p><img src="./pics/JavaStrengthen/jvm/eight_op.jpg"><blockquote><p>happen-before</p></blockquote><p>happen-before也是一套规则。目的是阐述“操作之间”的内存“可见性”。在happen-before规则下，我们写的代码只要前一个操作的结果对后续操作是可见的，是不会发生重排序的。</p><blockquote><p>volatile</p></blockquote><ul><li>有序性</li><li>可见性</li></ul><p>在volatile前后加了内存屏障，使得编译器和CPU无法进行重排序，并且写 volatile 变量对其他线程可见。</p><p>在汇编层面，是通过 lock 前缀指令来实现的（<strong>实现什么？没讲清楚，黄俊说的是实现的内存屏障？</strong>），而不是各种 fence 指令（因为大部分平台都支持 lock 指令，而 fence 指令 是 x86 平台的）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存屏障的实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movq 0(%%rsp), %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (local_dummy) : : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movl 0(%%esp),%0&quot;</span> : <span class="string">&quot;=r&quot;</span> (local_dummy) : : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// AMD64</span></span></span><br></pre></td></tr></table></figure><p>lock指令能保证：禁止 CPU 和 编译器 的重排序（保证了有序性）、保证 CPU 写核心的指令可以立即生效且其他核心的缓存数据失效（保证了可见性）</p><h2 id="第十二章-JVM内存结构"><a href="#第十二章-JVM内存结构" class="headerlink" title="第十二章 JVM内存结构"></a>第十二章 JVM内存结构</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>JVM的内存结构，往往指的就是 JVM 定义的 运行时数据区域。</p><p>==JVM内存结构分为5块：==方法区、堆、程序计数器、虚拟机栈、本地方法栈。=</p><img src="./pics/JavaStrengthen/jvm/JVM_Memory.jpg"><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>一块较小的内存空间，当前线程所执行字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。程序计数器时程序控制流的指示器，分支、循环、跳转、异常处理、线程回复等基础功能都依赖于程序计数器完成。</p><p>可以理解为计算机组成原理中的程序计数器。指向下一条需要执行的指令。<strong>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址</strong>；<strong>如果正在执行的是本地方法，这个计数器值则应为空。</strong></p><p>每个线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。程序计数器这块区域为线程私有，是线程安全的。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>描述的是 Java 方法执行的线程内存模型。每一条 Java 虚拟机线程都有自己私有的 Java 虚拟机栈，这个栈与线程同时创建，<strong>每次方法调用都会创建一个 栈帧</strong>。</p><p>==每个栈帧会包含几块内容：局部变量表、操作时栈、动态连接和返回地址==</p><p>Java 虚拟机栈的作用与传统语言中的栈非常类似，用于存储局部变量与一些尚未算好的结果。</p><img src="./pics/JavaStrengthen/jvm/JVM_Stack.jpg"><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到本地方法服务。</p><p>==HotSpot VM 直接把虚拟机栈和本地方法栈合二为一了。==</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote><p><strong>Java虚拟机规范中的解释：</strong></p></blockquote><p>方法区是可供各个线程共享的运行时内存区域。<strong>存储了每一个类的结构信息，如：运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。</strong>虚拟机可以自行选在在不在方法区实现垃圾回收算法。</p><blockquote><p><strong>HotSpot虚拟机</strong></p></blockquote><p>在HotSpot虚拟机，会常常提到 <strong>永久代</strong> 这个词。==HotSpot虚拟在 JDK8前 用 <strong>永久代</strong>实现了<strong>方法区</strong>==，而很多其他厂商的虚拟机其实是没有永久代的概念的。Java 虚拟机把方法区描述为堆的一个逻辑部分，但是它有一个别名叫作“非堆”，目的是为了与 Java 堆区分开来。</p><p>采用 <strong>永久代</strong> 实现 <strong>方法区</strong> 这种设计导致了 Java 应用 更容易遇到内存溢出的问题（永久代有 -XX:MaxPermSize 的上限，即使不设置也有默认大小，而J9 和 JRockit 只要没有触碰到进程可用内存的上限，如32位系统位4GB，就不会出现问题。）在JDK6 的时候 HotSpot 开发团队就有放弃永久代，逐步改为本地内存来实现方法区的计划了。</p><p>方法区主要用来存放已被虚拟机加载的“类相关信息”：包括类信息、常量池。</p><ul><li>类信息：类的版本、字段、方法、接口和父类等信息</li><li>常量池：静态常量池 和 运行时常量池（这块不熟悉）</li></ul><p>常量池：</p><ul><li>静态常量池：存储的是 <strong>字面量</strong> 以及 <strong>符号引用</strong> 等信息，静态常量池也包括了我们说的 <strong>字符串常量池</strong></li><li>运行时常量池：存储的是 <strong>类加载</strong> 时生成的 <strong>直接引用</strong> 等信息</li></ul><p>但自从在 <strong>JDK7</strong> 以后，就已经把 <strong>运行时常量池</strong> 和 <strong>静态常量池</strong> 转移到了 <strong>堆</strong> 内存中进行存储。<strong>到了JDK 8，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的元空间（Meta-space）来代替，把 JDK 7 中永久代还剩余的内容（主要是类型信息）全部移到元空间中。</strong>对于 <strong>物理分区</strong> 来说 <strong>运行时常量池</strong> 和 <strong>静态常量池</strong> 就属于堆。==（逻辑分区和物理实际存储的位置是不一样的）==</p><p>元空间存储不在虚拟机中，而是使用本地内存，JVM 不会再出现方法区的内存溢出，以往永久代经常因为内存不够用导致OOM异常。</p><img src="./pics/JavaStrengthen/jvm/Method_Area.jpg"><blockquote><p><strong>小结</strong></p></blockquote><p>HotSpot VM：HotSpot VM JDK7 以前永久代实现的方法区。JDK7 以前常量池在永久代（方法区）中，永久代容易OOM，JDK7 把常量池从 永久代（方法区） 移动到了 JVM 堆中。 ==JDK8开始，不在用永久代实现方法区了，而是用元空间实现方法区，永久代中剩余的内容（主要是类型信息）被移到了元空间。==</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。</p><p>堆涉及到了垃圾回收。以往的垃圾回收多数是基于“经典分代”来设计，需要新生代、老年代收集器搭配才能工作；HotSpot里面也出现了不采用分代设计的新垃圾收集器。现在以传统的 分代 思想介绍下堆的划分。</p><p><strong>堆</strong>被划分为新时代和老年代，新时代又被进一步划分为Eden和Survivor区，Surivivor由From Survivor和To Survivor组成。</p><img src="./pics/JavaStrengthen/jvm/Heap_Split.jpg"><p><strong>一般情况下 Eden：from：to = 8：1：1</strong></p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p><strong>JVM内存结构组成</strong>：JVM内存结构又称为「运行时数据区域」。主要有五部分组成：虚拟机栈、本地方法栈、程序计数器、方法区和堆。其中方法区和堆是线程共享的。虚拟机栈、本地方法栈以及程序计数器是线程隔离的。</p><h1 id="第四部分-源码阅读"><a href="#第四部分-源码阅读" class="headerlink" title="第四部分 源码阅读"></a>第四部分 源码阅读</h1><ul><li><p>修改idea配置</p><ul><li>Build，Execution，Deployment –&gt; Debugger –&gt; Stepping 的Do not step into the classes不要勾选</li></ul></li><li><p>把jdk的源码，解压，然后放在项目的目录下，不要放在src下就行，非项目目录也可以，然后idea源码关联改成我们解压后的那些文件，这样就可以修改源码注释了。</p></li></ul><hr><p><span style="color:red"><strong>JDK8核心源码目录说明</strong></span></p><ul><li><p>java.applet：applet所必须的类</p></li><li><p>java.awt：创建用户界面和绘制图形图像的所有类</p></li><li><p>java.beans：包含与开发javabeans有关的类</p></li><li><p><span style="color:red"><strong>java.lang：</strong></span>Java基础类【类装载（Class等）】、反射、字符串、线程类</p></li><li><p>java.math：主要是BigInteger、BigDecimal这两个的源码</p></li><li><p>java.net：网络应用出现提供类（阻塞式）</p></li><li><p><span style="color:red"><strong>java.nio：</strong></span>多路的、无阻塞的I/O</p></li><li><p>java.rmi：远程方法调用相关</p></li><li><p>java.security：安全框架类和接口</p></li><li><p>java.sql：操作数据库，闲得无聊可以看看</p></li><li><p><span style="color:red"><strong>java.util：</strong></span>重要的有：集合、JUC（Atomic、Lock、concurrent）、Stream（函数式操作）、工具类</p></li><li><p>java.text：处理文本、日期、数字和消息的类和接口（常见DataFormat、SimpleDataFormat）</p></li><li><p>java.time：日期时间工具库</p></li><li><p>javax.java：java扩展包，为了保持版本兼容，但有了更好的解决方案。如swing</p></li><li><p>launcher：和底层交互的c代码</p></li><li><p>org：其他企业组织提供的java类库，大部分不是oracle公司提供的。如w3c提供的对xml解析类和接口</p></li><li><p>com.sun：hotspot虚拟机中java.* 和javax.*的实现类，其他jdk中没有，这些类可能不向后兼容。</p></li></ul><p>Java native方法是用c c++实现的，无法查看到代码~要看的话去下open jdk的源码</p><p><span style="color:red"><strong>用open jdk的源码。</strong></span></p><ul><li>corba：不流行的多语言、分布式通讯接口</li><li>hotspot：Java虚拟机</li><li>hotspot-cpu：CPU相关代码（汇编器、模版解释器、部分runtime函数）</li><li>hotspot-os：操作系统相关代码</li><li>hotspot-os_cpu：操作系统+CPU的代码</li><li>hotspot-share：平台无关的通用代码</li><li>jaxp：xml处理</li><li>jaxws：一组XML web services的Java API</li><li><span style="color:green"><strong>jdk</strong></span>：Java开发工具包（share\class Java的实现 share\native目录里的是C++的实现）</li><li>langtools：Java语言工具</li><li>nashorn：JVM上的JavaScript运行时</li></ul><hr><p><a href="https://mp.weixin.qq.com/s/2yke6e-bfEYGtTHxH-31HQ">https://mp.weixin.qq.com/s/2yke6e-bfEYGtTHxH-31HQ</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;JavaSE 的学习笔记&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaSE" scheme="https://csliujw.github.io/blog/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>IO</title>
    <link href="https://csliujw.github.io/blog/IO/"/>
    <id>https://csliujw.github.io/blog/IO/</id>
    <published>2021-07-24T10:11:25.000Z</published>
    <updated>2021-07-25T02:16:59.067Z</updated>
    
    <content type="html"><![CDATA[<p>BIO NIO AIO的学习笔记</p><span id="more"></span><h1 id="NIO基本梳理"><a href="#NIO基本梳理" class="headerlink" title="NIO基本梳理"></a>NIO基本梳理</h1><p>NIO JDK1.4引入。</p><h2 id="NIO与传统IO的区别"><a href="#NIO与传统IO的区别" class="headerlink" title="NIO与传统IO的区别"></a>NIO与传统IO的区别</h2><p>传统IO是一次一个字节地处理数据，NIO是以块的形式处理数据（操作系统IO部分）。NIO可以实现非阻塞，传统IO只能是阻塞的。IO的实际场景是文件IO和网络IO，NIO在网络IO场景下提升尤其明显。</p><p>Java NIO有三个核心部分：Buffer（缓冲区）、Channel（管道）、Selector（选择器）</p><ul><li>Buffer：存储数据的地方。</li><li>Channel：运输数据的载体。</li><li>Selector：用于检查多个Channel的状态变更情况。</li></ul><h2 id="NIO-Demo"><a href="#NIO-Demo" class="headerlink" title="NIO Demo"></a>NIO Demo</h2><p>服务端接收图片后保存，能通知客户端已经收到图片、而客户端发送图片给客户端，并接收服务端的响应。</p><blockquote><p>==服务端==</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoBlockServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.获取通道</span></span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.切换成非阻塞模式</span></span><br><span class="line">        server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 绑定连接</span></span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 获取选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.1将通道注册到选择器上，指定接收“监听通道”事件</span></span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 轮训地获取选择器上已“就绪”的事件---&gt;只要select()&gt;0，说明已就绪</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 6. 获取当前选择器所有注册的“选择键”(已就绪的监听事件)</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7. 获取已“就绪”的事件，(不同的事件做不同的事)</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                SelectionKey selectionKey = iterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 接收事件就绪</span></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 8. 获取客户端的链接</span></span><br><span class="line">                    SocketChannel client = server.accept();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 8.1 切换成非阻塞状态</span></span><br><span class="line">                    client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 8.2 注册到选择器上--&gt;拿到客户端的连接为了读取通道的数据(监听读就绪事件)</span></span><br><span class="line">                    client.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123; <span class="comment">// 读事件就绪</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 9. 获取当前选择器读就绪状态的通道</span></span><br><span class="line">                    SocketChannel client = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 9.1读取数据</span></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 9.2得到文件通道，将客户端传递过来的图片写到本地项目下(写模式、没有则创建)</span></span><br><span class="line">                    FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">&quot;2.png&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (client.read(buffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 在读之前都要切换成读模式</span></span><br><span class="line">                        buffer.flip();</span><br><span class="line"></span><br><span class="line">                        outChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 读完切换成写模式，能让管道继续读取文件的数据</span></span><br><span class="line">                        buffer.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 10. 取消选择键(已经处理过的事件，就应该取消掉了)</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>==客户端==</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoBlockClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.1切换成非阻塞模式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.2获取选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.3将通道注册到选择器中，获取服务端返回的数据</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 发送一张图片给服务端吧</span></span><br><span class="line">        FileChannel fileChannel = FileChannel.open(Paths.get(<span class="string">&quot;X:\\Users\\ozc\\Desktop\\面试造火箭\\1.png&quot;</span>), StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.要使用NIO，有了Channel，就必然要有Buffer，Buffer是与数据打交道的呢</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.读取本地文件(图片)，发送到服务器</span></span><br><span class="line">        <span class="keyword">while</span> (fileChannel.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 在读之前都要切换成读模式</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line">            <span class="comment">// 读完切换成写模式，能让管道继续读取文件的数据</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 轮训地获取选择器上已“就绪”的事件---&gt;只要select()&gt;0，说明已就绪</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 6. 获取当前选择器所有注册的“选择键”(已就绪的监听事件)</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7. 获取已“就绪”的事件，(不同的事件做不同的事)</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                SelectionKey selectionKey = iterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 8. 读事件就绪</span></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 8.1得到对应的通道</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">                    ByteBuffer responseBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 9. 知道服务端要返回响应的数据给客户端，客户端在这里接收</span></span><br><span class="line">                    <span class="keyword">int</span> readBytes = channel.read(responseBuffer);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (readBytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 切换读模式</span></span><br><span class="line">                        responseBuffer.flip();</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(responseBuffer.array(), <span class="number">0</span>, readBytes));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 10. 取消选择键(已经处理过的事件，就应该取消掉了)</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><ul><li>阻塞IO、非阻塞IO、IO复用、信号驱动以及异步I/O。</li><li>开发中碰得最多的就是阻塞I/O、非阻塞I/O以及I/O复用</li></ul><h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p>客户端是否有数据传输，相应的线程都需要进行等待（阻塞了）</p><h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p>空着</p><h3 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h3><p>以Linux系统为例，Linux对文件的操作实际上就是通过文件描述符（fd）。IO复用模型指的是，通过一个进程监听多个文件描述符，一旦某个文件描述符准备就绪，就去通知程序做相对应的处理。这种以通知的方式，优势并不是对于单个连接能处理得更快，而是在于它能处理更多的连接。</p><p>==在Linux下IO复用模型用的函数有select/poll和epoll。==</p><blockquote><p>select</p></blockquote><p>select 函数它支持最大的连接数是1024或2018，因为在 select 函数下要传入 fd_set 参数，这个 fd_set 的大小要么1024或2048（看OS的位数）。fd_set 是 bitmap 的数据结构，可以简单理解为只要位为0，那说明还没数据到缓冲区，只要位为1，那么说明数据已经到缓冲区。==select 函数做的就是每次将 fd_set 遍历，判断标志位有没有发送变化，如果有变化则通知程序做中断处理。==</p><blockquote><p>epoll</p></blockquote><p>epoll 是在 Linux 2.6 内核正式提出，完善了 select 的一些缺点。它定义了 epoll_event 结构体来处理，不存在最大连接数的限制。它不像 select 函数每次把所有的文件描述符（fd）都遍历，简单理解就是 epoll 把就绪的文件描述符（fd）专门维护了一块空间，每次从就绪列表里边拿就好了，不再进行对所有文件描述符（fd）进行遍历。</p><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>以读操作为例，假设用户程序发起一次读请求。其实会调用read相关的【系统函数】，然后会从用户态切换到内核态，随后CPU会告诉DMA去磁盘把数据拷贝到内核空间。等到【内核缓冲区】有数据后CPU会把【内核缓冲区】拷贝到【用户缓冲区】，最终用户程序才能获取到。</p><p>简单说就是 DMA磁盘数据–&gt;内核空间  内核缓冲区–&gt;用户缓冲区。</p><p>==一次读操作会让DMA将磁盘数据拷贝到内核缓冲区，CPU将内核缓冲区数据拷贝到用户缓冲区。所谓的零拷贝就是将这次CPU拷贝给省去，来提高效率和性能。==</p><p><strong>常见的零拷贝技术有mmap（内核缓冲区与用户缓冲区的共享）、sendfile（系统底层函数支持）</strong></p><h1 id="第一章-BIO、NIO、AIO"><a href="#第一章-BIO、NIO、AIO" class="headerlink" title="第一章 BIO、NIO、AIO"></a>第一章 BIO、NIO、AIO</h1><h2 id="1-1-说明"><a href="#1-1-说明" class="headerlink" title="1.1 说明"></a>1.1 说明</h2><p>对于高性能场景，同步阻塞式I/O通信（BIO）性能低下。Java 2002年开始支持非阻塞式I/O通信技术（NIO）。</p><p>通过大量案例，从最基础的BIO开始到NIO、AIO。清晰了解阻塞、同步、异步的现象、概念和特征及其优缺点。</p><h2 id="1-2-前置知识"><a href="#1-2-前置知识" class="headerlink" title="1.2 前置知识"></a>1.2 前置知识</h2><ul><li>掌握JavaSE（Java多线程、Java IO流编程、Java网络基础知识），常用Java设计模式</li><li>熟练掌握OOP。</li></ul><h2 id="1-3-可解决的问题"><a href="#1-3-可解决的问题" class="headerlink" title="1.3 可解决的问题"></a>1.3 可解决的问题</h2><ul><li>局域网内的通信要求</li><li>多系统间底层消息传递机制</li><li>高并发下、大数据量的通信场景需要</li><li>游戏服务器端（手游、端游）</li></ul><h1 id="第二章-IO演变"><a href="#第二章-IO演变" class="headerlink" title="第二章 IO演变"></a>第二章 IO演变</h1><h2 id="2-1-I-O模型基本说明"><a href="#2-1-I-O模型基本说明" class="headerlink" title="2.1 I/O模型基本说明"></a>2.1 I/O模型基本说明</h2><h2 id="2-2-I-O模型"><a href="#2-2-I-O模型" class="headerlink" title="2.2 I/O模型"></a>2.2 I/O模型</h2><h3 id="Java-BIO"><a href="#Java-BIO" class="headerlink" title="Java BIO"></a>Java BIO</h3><p>客户端是否有数据传输，相应的线程都需要进行等待（阻塞了）</p><img src="https://csliujw.github.io/blog/img/pics/JavaStrengthen/io/Java_BIO.png"><h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h3><p>多路复用器会自动轮询所有的管道，去看那些管道有数据请求操作，有才会分配新的线程去处理管道通信，如果管道没有数据请求，那么线程可以去做其他的事情，不用等待。【依然需要轮询访问通道，但是通道无数据的时候，线程无需等待】</p><img src="https://csliujw.github.io/blog/img/pics/JavaStrengthen/io/Java_NIO.png"><h3 id="Java-AIO"><a href="#Java-AIO" class="headerlink" title="Java AIO"></a>Java AIO</h3><p>Java AIO(NIO.2) ： 异步 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，一般适用于连接数较 多且连接时间较长的应用。</p><p>客户端的数据都是通过OS进行处理，OS处理完数据后才会通知相应的服务端的线程进行数据的接收。</p><img src="https://csliujw.github.io/blog/img/pics/JavaStrengthen/io/Java_AIO.png"><h2 id="2-3-BIO、NIO、AIO适用场景"><a href="#2-3-BIO、NIO、AIO适用场景" class="headerlink" title="2.3 BIO、NIO、AIO适用场景"></a>2.3 BIO、NIO、AIO适用场景</h2><p>1、<strong>BIO</strong> 方式<code>适用于连接数目比较小且固定的架构</code>，这种方式对服务器资源要求比较高（每次请求都要创建一个线程进行处理，线程无数据可处理的时候还要进行等待），<code>并发局限于应用中</code>，JDK1.4以前的唯一选择，但程序简单易理解。</p><p>2、<strong>NIO</strong> 方式<code>适用于连接数目多且连接比较短（轻操作）的架构</code>（<strong>NIO造成系统资源浪费哪里没听懂！！！</strong>，如果通道的资源少，那么解决起来就快，就可以很快地把资源释放给其他通道用。如果一直占据，会造成并发，资源浪费。AIO是OS充分干预，适用于长连接一类的。），比如聊天服务器，弹幕系统，服务器间通讯等。 编程比较复杂，JDK1.4 开始支持。</p><p>3、<strong>AIO</strong> 方式<code>适用于连接数目多且连接比较长（重操作）的架构</code>，比如相册服务器，<code>充分调用 OS 参与并发操作</code>（注册客户端通道，客户端的数据交由操作系统处理，操作系统处理完后再通过回调机制通知我们的服务器进行数据的接收处理）， 编程比较复杂，JDK7 开始支持。</p><h1 id="第三章-Java-BIO深入剖析"><a href="#第三章-Java-BIO深入剖析" class="headerlink" title="第三章 Java BIO深入剖析"></a>第三章 Java BIO深入剖析</h1><h2 id="3-1-Java-BIO基本介绍"><a href="#3-1-Java-BIO基本介绍" class="headerlink" title="3.1 Java BIO基本介绍"></a>3.1 Java BIO基本介绍</h2><ul><li>Java BIO 就是传统的 java io 编程，其相关的类和接口在 java.io</li><li>BIO(blocking I/O) ： 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善(实现多个客户连接服务器).</li></ul><h2 id="3-2-Java-BIO-工作机制"><a href="#3-2-Java-BIO-工作机制" class="headerlink" title="3.2 Java BIO 工作机制"></a>3.2 Java BIO 工作机制</h2><img src="https://csliujw.github.io/blog/img/pics/JavaStrengthen/io/BIO_model.png"><p>对BIO编程流程的梳理</p><ol><li>服务器端启动一个 <strong>ServerSocket</strong>，注册端口，调用accpet方法监听客户端的Socket连接。</li><li>客户端启动 <strong>Socket</strong> 对服务器进行通信（<code>Socket端与Socket端之间会形成一个虚拟管道，用于数据传输</code>），默认情况下服务器端需要对每个客户 建立一个线程与之通讯</li></ol><h2 id="3-3-传统的BIO编程实例回顾"><a href="#3-3-传统的BIO编程实例回顾" class="headerlink" title="3.3 传统的BIO编程实例回顾"></a>3.3 传统的BIO编程实例回顾</h2><p>网络编程的基本模型是Client/Server模型，也就是两个进程之间进行相互通信，其中服务端提供位置信（绑定IP地址和端口），客户端通过连接操作向服务端监听的端口地址发起连接请求，基于TCP协议下进行三次握手连接，连接成功后，双方通过网络套接字（Socket）进行通信。</p><p>传统的同步阻塞模型开发中，服务端ServerSocket负责绑定IP地址，启动监听端口；客户端Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信。 基于BIO模式下的通信，客户端 - 服务端是完全同步，完全耦合的。</p><h3 id="客户端案例如下"><a href="#客户端案例如下" class="headerlink" title="客户端案例如下"></a>客户端案例如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima._02bio01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标: Socket网络编程。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Java提供了一个包：java.net下的类都是用于网络通信。</span></span><br><span class="line"><span class="comment">    Java提供了基于套接字（端口）Socket的网络通信模式，我们基于这种模式就可以直接实现TCP通信。</span></span><br><span class="line"><span class="comment">    只要用Socket通信，那么就是基于TCP可靠传输通信。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    功能1：客户端发送一个消息，服务端接口一个消息，通信结束！！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    创建客户端对象：</span></span><br><span class="line"><span class="comment">        （1）创建一个Socket的通信管道，请求与服务端的端口连接。</span></span><br><span class="line"><span class="comment">        （2）从Socket管道中得到一个字节输出流。</span></span><br><span class="line"><span class="comment">        （3）把字节流改装成自己需要的流进行数据的发送</span></span><br><span class="line"><span class="comment">    创建服务端对象：</span></span><br><span class="line"><span class="comment">        （1）注册端口</span></span><br><span class="line"><span class="comment">        （2）开始等待接收客户端的连接,得到一个端到端的Socket管道</span></span><br><span class="line"><span class="comment">        （3）从Socket管道中得到一个字节输入流。</span></span><br><span class="line"><span class="comment">        （4）把字节输入流包装成自己需要的流进行数据的读取。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Socket的使用：</span></span><br><span class="line"><span class="comment">        构造器：public Socket(String host, int port)</span></span><br><span class="line"><span class="comment">        方法：  public OutputStream getOutputStream()：获取字节输出流</span></span><br><span class="line"><span class="comment">               public InputStream getInputStream() :获取字节输入流</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ServerSocket的使用：</span></span><br><span class="line"><span class="comment">        构造器：public ServerSocket(int port)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        通信是很严格的，对方怎么发你就怎么收，对方发多少你就只能收多少！！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==客户端的启动==&quot;</span>);</span><br><span class="line">        <span class="comment">// （1）创建一个Socket的通信管道，请求与服务端的端口连接。</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// （2）从Socket通信管道中得到一个字节输出流。</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// （3）把字节流改装成自己需要的流进行数据的发送</span></span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(os);</span><br><span class="line">        <span class="comment">// （4）开始发送消息</span></span><br><span class="line">        ps.println(<span class="string">&quot;我是客户端，我想约你吃小龙虾！！！&quot;</span>);</span><br><span class="line">        ps.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端案例如下"><a href="#服务端案例如下" class="headerlink" title="服务端案例如下"></a>服务端案例如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima._02bio01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==服务器的启动==&quot;</span>);</span><br><span class="line">        <span class="comment">// （1）注册端口</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//（2）开始在这里暂停等待接收客户端的连接,得到一个端到端的Socket管道</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">//（3）从Socket管道中得到一个字节输入流。</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">//（4）把字节输入流包装成自己需要的流进行数据的读取。</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">        <span class="comment">//（5）读取数据</span></span><br><span class="line">        String line ;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端收到：&quot;</span>+line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>在以上通信中，服务端会一致等待客户端的消息，如果客户端没有进行消息的发送，服务端将一直进入阻塞状态。</li><li>同时服务端是按照行获取消息的，这意味着客户端也必须按照行进行消息的发送，否则服务端将进入等待消息的阻塞状态！</li></ul><h2 id="3-4-BIO模式下多发和多收消息"><a href="#3-4-BIO模式下多发和多收消息" class="headerlink" title="3.4 BIO模式下多发和多收消息"></a>3.4 BIO模式下多发和多收消息</h2><p> 在1.3的案例中，<strong>只能实现客户端发送消息，服务端接收消息</strong>，并不能实现反复的收消息和反复的发消息，我们只需要在客户端案例中，加上反复按照行发送消息的逻辑即可！案例代码如下：</p><h3 id="客户端代码如下"><a href="#客户端代码如下" class="headerlink" title="客户端代码如下"></a>客户端代码如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima._03bio02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标: Socket网络编程。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    功能1：客户端可以反复发消息，服务端可以反复收消息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        通信是很严格的，对方怎么发你就怎么收，对方发多少你就只能收多少！！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==客户端的启动==&quot;</span>);</span><br><span class="line">        <span class="comment">// （1）创建一个Socket的通信管道，请求与服务端的端口连接。</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// （2）从Socket通信管道中得到一个字节输出流。</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// （3）把字节流改装成自己需要的流进行数据的发送</span></span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(os);</span><br><span class="line">        <span class="comment">// （4）开始发送消息</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;请说:&quot;</span>);</span><br><span class="line">            String msg = sc.nextLine();</span><br><span class="line">            ps.println(msg);</span><br><span class="line">            ps.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端代码如下"><a href="#服务端代码如下" class="headerlink" title="服务端代码如下"></a>服务端代码如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima._03bio02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==服务器的启动==&quot;</span>);</span><br><span class="line">        <span class="comment">//（1）注册端口</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//（2）开始在这里暂停等待接收客户端的连接,得到一个端到端的Socket管道</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">//（3）从Socket管道中得到一个字节输入流。</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">//（4）把字节输入流包装成  自己需要的流进行数据的读取。</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">        <span class="comment">//（5）读取数据</span></span><br><span class="line">        String line ;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端收到：&quot;</span>+line);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>本案例中确实可以实现客户端多发多收</li><li>但是服务端只能处理一个客户端的请求，因为服务端是单线程的。一次只能与一个客户端进行消息通信。</li></ul><h2 id="3-5-BIO模式下接收多个客户端"><a href="#3-5-BIO模式下接收多个客户端" class="headerlink" title="3.5 BIO模式下接收多个客户端"></a>3.5 BIO模式下接收多个客户端</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p> 在上述的案例中，一个服务端只能接收一个客户端的通信请求，<strong>那么如果服务端需要处理很多个客户端的消息通信请求应该如何处理呢</strong>，此时我们就需要在服务端引入线程了，也就是说客户端每发起一个请求，服务端就创建一个新的线程来处理这个客户端的请求，这样就实现了一个客户端一个线程的模型，图解模式如下：</p><img src="https://csliujw.github.io/blog/img/pics/JavaStrengthen/io/Java_BIO.png"><h3 id="客户端案例代码如下"><a href="#客户端案例代码如下" class="headerlink" title="客户端案例代码如下"></a>客户端案例代码如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标: Socket网络编程。</span></span><br><span class="line"><span class="comment">    功能1：客户端可以反复发，一个服务端可以接收无数个客户端的消息！！</span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">         服务器如果想要接收多个客户端，那么必须引入线程，一个客户端一个线程处理！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==客户端的启动==&quot;</span>);</span><br><span class="line">        <span class="comment">// （1）创建一个Socket的通信管道，请求与服务端的端口连接。</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">7777</span>);</span><br><span class="line">        <span class="comment">// （2）从Socket通信管道中得到一个字节输出流。</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// （3）把字节流改装成自己需要的流进行数据的发送</span></span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(os);</span><br><span class="line">        <span class="comment">// （4）开始发送消息</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;请说:&quot;</span>);</span><br><span class="line">            String msg = sc.nextLine();</span><br><span class="line">            ps.println(msg);</span><br><span class="line">            ps.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端案例代码如下"><a href="#服务端案例代码如下" class="headerlink" title="服务端案例代码如下"></a>服务端案例代码如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.v4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端 因为只一次accept 只接受到了一个客户端的请求，所以只能接受到一个客户端的消息。</span></span><br><span class="line"><span class="comment">// 我们为每个客户端创建一个线程，就可以一个服务器 连接多个客户端了！</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;========服务端启动========&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 定义一个ServerSocket对象进行服务器的端口注册</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 2. 开始在这里暂停等待接收客户端的连接,得到一个端到端的Socket管道</span></span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> DealClient(accept)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DealClient</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DealClient</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 从Socket管道中得到一个字节输入流。</span></span><br><span class="line">            inputStream = socket.getInputStream();</span><br><span class="line">            <span class="comment">// 4. 把字节输入流包装成自己需要的流进行数据的读取。</span></span><br><span class="line">            bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line">            <span class="comment">// 5. 读取数据</span></span><br><span class="line">            String msg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> ((msg = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器端接收到：&quot;</span> + socket.getRemoteSocketAddress() + <span class="string">&quot;:\t&quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bufferedReader.close();</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul><li><code>1.</code>每个Socket接收到，都会创建一个线程，线程的竞争、切换上下文影响性能；</li><li><code>2.</code>每个线程都会占用栈空间和CPU资源（并发的资源消耗）；</li><li><code>3.</code>并不是每个socket都进行IO操作，无意义的线程处理；</li><li><code>4.</code>客户端的并发访问增加时。服务端将呈现1:1的线程开销，访问量越大，系统将发生线程栈溢出，线程创建失败，最终导致进程宕机或者僵死，从而不能对外提供服务。</li></ul><h2 id="3-6-伪异步I-O编程"><a href="#3-6-伪异步I-O编程" class="headerlink" title="3.6 伪异步I/O编程"></a>3.6 伪异步I/O编程</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p> <code>在上述案例中：客户端的并发访问增加时。服务端将呈现1:1的线程开销，访问量越大，系统将发生线程栈溢出，线程创建失败，最终导致进程宕机或者僵死，从而不能对外提供服务。</code></p><p><code>接下来我们采用一个伪异步I/O的通信框架，采用线程池和任务队列实现，</code>当客户端接入时，将客户端的Socket封装成一个Task（该任务实现java.lang.Runnable线程任务接口）交给后端的线程池中进行处理。<code>JDK的线程池维护一个消息队列和N个活跃的线程，对消息队列中Socket任务进行处理</code>，由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。</p><p> 图示如下:</p><img src="https://csliujw.github.io/blog/img/pics/JavaStrengthen/io/fake_async.png"><h3 id="线程池介绍"><a href="#线程池介绍" class="headerlink" title="线程池介绍"></a>线程池介绍</h3><p>我自己加的内容</p><h3 id="客户端源码分析"><a href="#客户端源码分析" class="headerlink" title="客户端源码分析"></a>客户端源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.v5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端 启动多个客户端 给通过一个服务器发送消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.建立一个与服务端的Socket对象：套接字</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 2.从socket管道中获取一个输出流，写数据给服务端</span></span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 3.把输出流包装成一个打印流 </span></span><br><span class="line">        PrintStream printStream = <span class="keyword">new</span> PrintStream(outputStream);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;please input:&quot;</span>);</span><br><span class="line">            String msg = scanner.nextLine();</span><br><span class="line">            printStream.println(msg);</span><br><span class="line">            printStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端源码分析"><a href="#服务端源码分析" class="headerlink" title="服务端源码分析"></a>服务端源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.v5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现伪异步通信架构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1、注册端口</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 把socket对象包装成一个任务，交给线程池进行处理。</span></span><br><span class="line">        HandlerSocketServerPool handlerSocketServerPool = <span class="keyword">new</span> HandlerSocketServerPool(<span class="number">6</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 初始化一个线程池对象</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 2、定义一个循环接收客户端的Socket链接请求</span></span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">            <span class="comment">// 3、把socket封装成任务对象，交由线程池处理</span></span><br><span class="line">            ServerRunnableTarget serverRunnableTarget = <span class="keyword">new</span> ServerRunnableTarget(accept);</span><br><span class="line">            <span class="comment">// 线程池一旦有空闲的线程，就会执行。</span></span><br><span class="line">            handlerSocketServerPool.execute(serverRunnableTarget);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerSocketServerPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、创建一个线程池的成员变量用于存储一个线程池对象。</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * public ThreadPoolExecutor(int corePoolSize, 核心线程的数目</span></span><br><span class="line"><span class="comment">     * int maximumPoolSize, 最大线程数量</span></span><br><span class="line"><span class="comment">     * long keepAliveTime,    线程的空闲时间</span></span><br><span class="line"><span class="comment">     * TimeUnit unit, 空闲时间的时间单位</span></span><br><span class="line"><span class="comment">     * BlockingQueue&lt;Runnable&gt; workQueue) &#123; 任务队列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxThreadNumber</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> taskQueueSize</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerSocketServerPool</span><span class="params">(<span class="keyword">int</span> maxThreadNumber, <span class="keyword">int</span> taskQueueSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最多三个线程。</span></span><br><span class="line">        <span class="comment">// 阻塞队列的最大数目为 taskQueueSize</span></span><br><span class="line">        executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, maxThreadNumber,</span><br><span class="line">                <span class="number">120</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(taskQueueSize));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">        executorService.execute(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerRunnableTarget</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerRunnableTarget</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理接收到的客户端Socket通信需求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span> ((msg = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;服务端接收到：&quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ul><li><code>伪异步io采用了线程池实现，因此避免了为每个请求创建一个独立线程造成线程资源耗尽的问题，但由于底层依然是采用的同步阻塞模型，因此无法从根本上解决问题。</code></li><li><code>如果单个消息处理的缓慢，或者服务器线程池中的全部线程都被阻塞，那么后续socket的i/o消息都将在队列中排队。新的Socket请求将被拒绝，客户端会发生大量连接超时。</code></li></ul><h2 id="3-7-基于BIO形式下的文件上传"><a href="#3-7-基于BIO形式下的文件上传" class="headerlink" title="3.7 基于BIO形式下的文件上传"></a>3.7 基于BIO形式下的文件上传</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>支持任意类型文件形式的上传。</p><h3 id="客户端开发"><a href="#客户端开发" class="headerlink" title="客户端开发"></a>客户端开发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.bio.v6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现任意文件的上传</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 请求与服务端的socket连接</span></span><br><span class="line">            Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">            DataOutputStream dataOutputStream = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line">            dataOutputStream.writeUTF(<span class="string">&quot;.pdf&quot;</span>);</span><br><span class="line">            FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\file.pdf&quot;</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                dataOutputStream.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            dataOutputStream.flush();</span><br><span class="line">            <span class="comment">// 流正常关闭就行，不必非得shutdownOutput()</span></span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line">            dataOutputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端开发"><a href="#服务端开发" class="headerlink" title="服务端开发"></a>服务端开发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.bio.v6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    DataInputStream dataInputStream = <span class="keyword">new</span> DataInputStream(accept.getInputStream());</span><br><span class="line">                    String suffix = dataInputStream.readUTF();</span><br><span class="line">                    FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\demo&quot;</span> + suffix);</span><br><span class="line">                    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((len = dataInputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        fileOutputStream.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    fileOutputStream.close();</span><br><span class="line">                    dataInputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>客户端怎么发，服务端就怎么接收</p><h2 id="3-8-Java-BIO模式下的端口转发思想"><a href="#3-8-Java-BIO模式下的端口转发思想" class="headerlink" title="3.8 Java BIO模式下的端口转发思想"></a>3.8 Java BIO模式下的端口转发思想</h2><p>需求：需要实现一个客户端的消息可以发送给所有的客户端去接收。（类似于群聊实现）</p><img src="https://csliujw.github.io/blog/img/pics/JavaStrengthen/io/port_trans.png"><p>大致流程梳理：</p><ul><li><p>客户端发送一条数据过去，服务端接收到后需要转发给所有的客户端。 </p></li><li><p>如何转发呢？</p></li><li><p>客户端发送数据，所有的客户端socket都在一个集合里，服务端遍历集合，把数据一个一个发过去就行。 </p></li></ul><h3 id="客户端开发-1"><a href="#客户端开发-1" class="headerlink" title="客户端开发"></a>客户端开发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.bio.v8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、创建于服务端的Socket链接</span></span><br><span class="line">            Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">            <span class="comment">// 4、分配一个线程为客户端socket服务接收服务端发来的消息</span></span><br><span class="line">            <span class="keyword">new</span> ClientReaderThread(socket).start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、从当前socket管道中得到一个字节输出流对应的打印流</span></span><br><span class="line">            PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line">            <span class="comment">// 3、接收用户输入的消息发送出去</span></span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String msg = sc.nextLine();</span><br><span class="line">                ps.println(<span class="string">&quot;波妞：&quot;</span> + msg);</span><br><span class="line">                ps.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientReaderThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span> ((msg = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.bio.v8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：BIO模式下的端口转发思想-服务端实现</span></span><br><span class="line"><span class="comment"> * 服务端实现的需求：</span></span><br><span class="line"><span class="comment"> * 1.注册端口</span></span><br><span class="line"><span class="comment"> * 2.接收客户端的socket连接，交给一个独立的线程来处理</span></span><br><span class="line"><span class="comment"> * 3.把当前连接的客户端socket存入到一个所谓的在线socket集合中保存</span></span><br><span class="line"><span class="comment"> * 4.接收客户端的消息，然后推送给当前所有在线的socket接收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Socket&gt; onLineSocket = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket accept = serverSocket.accept();</span><br><span class="line">                <span class="comment">// 把登录的客户端存入到一个在线集合中。</span></span><br><span class="line">                onLineSocket.add(accept);</span><br><span class="line">                <span class="comment">// 为登录成功的socket分配一个线程进行处理</span></span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> ServerReaderThread(accept)).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerReaderThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerReaderThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerReaderThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span> ((msg = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 服务端接收到数据后，把消息传给所有的在线用户</span></span><br><span class="line">                sendMsgToAllClient(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;有人下线&quot;</span>);</span><br><span class="line">            Server.onLineSocket.remove(socket);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMsgToAllClient</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Socket sk : Server.onLineSocket) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sk == socket) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 包装一下，用PrintStream的方式传递数据。知道是哪个socket，就可以直接给这个socket发送数据了。</span></span><br><span class="line">                PrintStream printStream = <span class="keyword">new</span> PrintStream(sk.getOutputStream());</span><br><span class="line">                printStream.println(msg);</span><br><span class="line">                printStream.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><h2 id="3-9-基于BIO模式下即时通信"><a href="#3-9-基于BIO模式下即时通信" class="headerlink" title="3.9 基于BIO模式下即时通信"></a>3.9 基于BIO模式下即时通信</h2><p>基于BIO模式下的即时通信，我们需要解决客户端到客户端的通信，也就是需要实现客户端与客户端的端口消息转发逻辑。</p><h3 id="项目功能演示"><a href="#项目功能演示" class="headerlink" title="项目功能演示"></a>项目功能演示</h3><h4 id="项目案例说明"><a href="#项目案例说明" class="headerlink" title="项目案例说明"></a>项目案例说明</h4><p>本项目案例为即时通信的软件项目，适合基础加强的大案例，具备综合性。学习本项目案例至少需要具备如下Java SE技术点:</p><ul><li><ol><li>Java 面向对象设计，语法设计。</li></ol></li><li><ol start="2"><li>多线程技术。</li></ol></li><li><ol start="3"><li>IO流技术。</li></ol></li><li><ol start="4"><li>网络通信相关技术。</li></ol></li><li><ol start="5"><li>集合框架。</li></ol></li><li><ol start="6"><li>项目开发思维。</li></ol></li><li><ol start="7"><li>Java 常用 api 使用。</li></ol></li></ul><p>​    ……</p><h4 id="功能清单简单说明："><a href="#功能清单简单说明：" class="headerlink" title="功能清单简单说明："></a>功能清单简单说明：</h4><p><strong>1.客户端登陆功能</strong></p><ul><li>可以启动客户端进行登录，客户端登陆只需要输入用户名和服务端ip地址即可。</li></ul><p><strong>2.在线人数实时更新。</strong></p><ul><li>客户端用户户登陆以后，需要同步更新所有客户端的联系人信息栏。</li></ul><p><strong>3.离线人数更新</strong></p><ul><li>检测到有客户端下线后，需要同步更新所有客户端的联系人信息栏。</li></ul><p><strong>4.群聊</strong></p><ul><li>任意一个客户端的消息，可以推送给当前所有客户端接收。</li></ul><p><strong>5.私聊</strong></p><ul><li>可以选择某个员工，点击私聊按钮，然后发出的消息可以被该客户端单独接收。</li></ul><p><strong>6.@消息</strong></p><ul><li>可以选择某个员工，然后发出的消息可以@该用户，但是其他所有人都能</li></ul><p><strong>7.消息用户和消息时间点</strong></p><ul><li>服务端可以实时记录该用户的消息时间点，然后进行消息的多路转发或者选择。</li></ul><h4 id="项目启动与演示"><a href="#项目启动与演示" class="headerlink" title="项目启动与演示"></a>项目启动与演示</h4><p><strong>项目代码结构演示。</strong></p><img src="https://csliujw.github.io/blog/img/pics/JavaStrengthen/io/image-20200223212913139.png"><p><strong>项目启动步骤：</strong></p><ul><li>1.首先需要启动服务端，点击ServerChat类直接右键启动，显示服务端启动成功！</li><li>2.其次，点击客户端类ClientChat类，在弹出的方框中输入服务端的ip和当前客户端的昵称</li></ul><img src="https://csliujw.github.io/blog/img/pics/JavaStrengthen/io/image-20200223214123052.png"><ul><li><p>3.登陆进入后的聊天界面如下，即可进行相关操作。</p><ul><li>如果直接点击发送，默认发送群聊消息</li></ul></li><li><p>如果选中右侧在线列表某个用户，默认发送@消息</p><ul><li>如果选中右侧在线列表某个用户，然后选择右下侧私聊按钮默，认发送私聊消息。</li></ul><img src="https://csliujw.github.io/blog/img/pics/JavaStrengthen/io/image-20200223214143465.png"><img src="https://csliujw.github.io/blog/img/pics/JavaStrengthen/io/image-20200223214155975.png"></li></ul><h4 id="技术选型分析"><a href="#技术选型分析" class="headerlink" title="技术选型分析"></a>技术选型分析</h4><p>本项目案例涉及到Java基础加强的案例，具体涉及到的技术点如下：</p><ul><li><ol><li>Java 面向对象设计，语法设计。</li></ol></li><li><ol start="2"><li>多线程技术。</li></ol></li><li><ol start="3"><li>IO流技术。</li></ol></li><li><ol start="4"><li>网络通信相关技术。</li></ol></li><li><ol start="5"><li>集合框架。</li></ol></li><li><ol start="6"><li>项目开发思维。</li></ol></li><li><ol start="7"><li>Java 常用 api 使用。</li></ol><p>……</p></li></ul><h3 id="服务端设计"><a href="#服务端设计" class="headerlink" title="服务端设计"></a>服务端设计</h3><h4 id="服务端接收多个客户端逻辑"><a href="#服务端接收多个客户端逻辑" class="headerlink" title="服务端接收多个客户端逻辑"></a>服务端接收多个客户端逻辑</h4><h5 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h5><p>服务端需要接收多个客户端的接入。</p><h5 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h5><ul><li>1.服务端需要接收多个客户端，目前我们采取的策略是一个客户端对应一个服务端线程。</li><li>2.服务端除了要注册端口以外，还需要为每个客户端分配一个独立线程处理与之通信。</li></ul><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><ul><li>服务端主体代码，主要进行端口注册，和接收客户端，分配线程处理该客户端请求</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerChat</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 定义一个集合存放所有在线的socket  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Socket, String&gt; onLineSockets = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">/** 1.注册端口   */</span></span><br><span class="line">         ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(Constants.PORT);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/** 2.循环一直等待所有可能的客户端连接 */</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            <span class="comment">/**3. 把客户端的socket管道单独配置一个线程来处理 */</span></span><br><span class="line">            <span class="keyword">new</span> ServerReader(socket).start();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>服务端分配的独立线程类负责处理该客户端Socket的管道请求。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerReader</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Socket socket;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ServerReader</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.socket = socket;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">       </span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量包负责做端口配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constants</span> </span>&#123;</span><br><span class="line">   <span class="comment">/** 常量 */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">7778</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h5><p>​    本节实现了服务端可以接收多个客户端请求。</p><h4 id="服务端接收登陆消息以及监测离线"><a href="#服务端接收登陆消息以及监测离线" class="headerlink" title="服务端接收登陆消息以及监测离线"></a>服务端接收登陆消息以及监测离线</h4><h5 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h5><p>在上节我们实现了服务端可以接收多个客户端，然后服务端可以接收多个客户端连接，接下来我们要接收客户端的登陆消息。</p><h5 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h5><ul><li>需要在服务端处理客户端的线程的登陆消息。</li><li>需要注意的是，服务端需要接收客户端的消息可能有很多种。<ul><li>分别是登陆消息，群聊消息，私聊消息 和@消息。</li><li>这里需要约定如果客户端发送消息之前需要先发送消息的类型，类型我们使用信号值标志（1，2，3）。<ul><li>1代表接收的是登陆消息</li><li>2代表群发| @消息</li><li>3代表了私聊消息</li></ul></li></ul></li><li>服务端的线程中有异常校验机制，一旦发现客户端下线会在异常机制中处理，然后移除当前客户端用户，把最新的用户列表发回给全部客户端进行在线人数更新。</li></ul><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerReader</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Socket socket;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerReader</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.socket = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">dis = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line"><span class="comment">/** 1.循环一直等待客户端的消息 */</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">/** 2.读取当前的消息类型 ：登录,群发,私聊 , @消息 */</span></span><br><span class="line"><span class="keyword">int</span> flag = dis.readInt();</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">/** 先将当前登录的客户端socket存到在线人数的socket集合中   */</span></span><br><span class="line">String name = dis.readUTF() ;</span><br><span class="line">System.out.println(name+<span class="string">&quot;----&gt;&quot;</span>+socket.getRemoteSocketAddress());</span><br><span class="line">ServerChat.onLineSockets.put(socket, name);</span><br><span class="line">&#125;</span><br><span class="line">writeMsg(flag,dis);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;--有人下线了--&quot;</span>);</span><br><span class="line"><span class="comment">// 从在线人数中将当前socket移出去  </span></span><br><span class="line">ServerChat.onLineSockets.remove(socket);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 从新更新在线人数并发给所有客户端 </span></span><br><span class="line">writeMsg(<span class="number">1</span>,dis);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeMsg</span><span class="params">(<span class="keyword">int</span> flag, DataInputStream dis)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// DataOutputStream dos = new DataOutputStream(socket.getOutputStream()); </span></span><br><span class="line"><span class="comment">// 定义一个变量存放最终的消息形式 </span></span><br><span class="line">String msg = <span class="keyword">null</span> ;</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">/** 读取所有在线人数发给所有客户端去更新自己的在线人数列表 */</span></span><br><span class="line"><span class="comment">/** onlineNames = [波仔,zhangsan,波妞]*/</span></span><br><span class="line">StringBuilder rs = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">Collection&lt;String&gt; onlineNames = ServerChat.onLineSockets.values();</span><br><span class="line"><span class="comment">// 判断是否存在在线人数 </span></span><br><span class="line"><span class="keyword">if</span>(onlineNames != <span class="keyword">null</span> &amp;&amp; onlineNames.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(String name : onlineNames)&#123;</span><br><span class="line">rs.append(name+ Constants.SPILIT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 波仔003197♣♣㏘♣④④♣zhangsan003197♣♣㏘♣④④♣波妞003197♣♣㏘♣④④♣</span></span><br><span class="line"><span class="comment">// 去掉最后的一个分隔符 </span></span><br><span class="line">msg = rs.substring(<span class="number">0</span>, rs.lastIndexOf(Constants.SPILIT));</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 将消息发送给所有的客户端 */</span></span><br><span class="line">sendMsgToAll(flag,msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">2</span> || flag == <span class="number">3</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMsgToAll</span><span class="params">(<span class="keyword">int</span> flag, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 拿到所有的在线socket管道 给这些管道写出消息</span></span><br><span class="line">Set&lt;Socket&gt; allOnLineSockets = ServerChat.onLineSockets.keySet();</span><br><span class="line"><span class="keyword">for</span>(Socket sk :  allOnLineSockets)&#123;</span><br><span class="line">DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(sk.getOutputStream());</span><br><span class="line">dos.writeInt(flag); <span class="comment">// 消息类型</span></span><br><span class="line">dos.writeUTF(msg);</span><br><span class="line">dos.flush();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h5><ul><li>此处实现了接收客户端的登陆消息，然后提取当前在线的全部的用户名称和当前登陆的用户名称发送给全部在线用户更新自己的在线人数列表。</li></ul><h4 id="服务端接收群聊消息"><a href="#服务端接收群聊消息" class="headerlink" title="服务端接收群聊消息"></a>服务端接收群聊消息</h4><h5 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h5><p>在上节实现了接收客户端的登陆消息，然后提取当前在线的全部的用户名称和当前登陆的用户名称发送给全部在线用户更新自己的在线人数列表。接下来要接收客户端发来的群聊消息推送给当前在线的所有客户端</p><h5 id="实现步骤-2"><a href="#实现步骤-2" class="headerlink" title="实现步骤"></a>实现步骤</h5><ul><li>接下来要接收客户端发来的群聊消息。</li><li>需要注意的是，服务端需要接收客户端的消息可能有很多种。<ul><li>分别是登陆消息，群聊消息，私聊消息 和@消息。</li><li>这里需要约定如果客户端发送消息之前需要先发送消息的类型，类型我们使用信号值标志（1，2，3）。<ul><li>1代表接收的是登陆消息</li><li>2代表群发| @消息</li><li>3代表了私聊消息</li></ul></li></ul></li></ul><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerReader</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Socket socket;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerReader</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.socket = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">dis = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line"><span class="comment">/** 1.循环一直等待客户端的消息 */</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">/** 2.读取当前的消息类型 ：登录,群发,私聊 , @消息 */</span></span><br><span class="line"><span class="keyword">int</span> flag = dis.readInt();</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">/** 先将当前登录的客户端socket存到在线人数的socket集合中   */</span></span><br><span class="line">String name = dis.readUTF() ;</span><br><span class="line">System.out.println(name+<span class="string">&quot;----&gt;&quot;</span>+socket.getRemoteSocketAddress());</span><br><span class="line">ServerChat.onLineSockets.put(socket, name);</span><br><span class="line">&#125;</span><br><span class="line">writeMsg(flag,dis);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;--有人下线了--&quot;</span>);</span><br><span class="line"><span class="comment">// 从在线人数中将当前socket移出去  </span></span><br><span class="line">ServerChat.onLineSockets.remove(socket);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 从新更新在线人数并发给所有客户端 </span></span><br><span class="line">writeMsg(<span class="number">1</span>,dis);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeMsg</span><span class="params">(<span class="keyword">int</span> flag, DataInputStream dis)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// DataOutputStream dos = new DataOutputStream(socket.getOutputStream()); </span></span><br><span class="line"><span class="comment">// 定义一个变量存放最终的消息形式 </span></span><br><span class="line">String msg = <span class="keyword">null</span> ;</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">/** 读取所有在线人数发给所有客户端去更新自己的在线人数列表 */</span></span><br><span class="line"><span class="comment">/** onlineNames = [波仔,zhangsan,波妞]*/</span></span><br><span class="line">StringBuilder rs = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">Collection&lt;String&gt; onlineNames = ServerChat.onLineSockets.values();</span><br><span class="line"><span class="comment">// 判断是否存在在线人数 </span></span><br><span class="line"><span class="keyword">if</span>(onlineNames != <span class="keyword">null</span> &amp;&amp; onlineNames.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(String name : onlineNames)&#123;</span><br><span class="line">rs.append(name+ Constants.SPILIT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 波仔003197♣♣㏘♣④④♣zhangsan003197♣♣㏘♣④④♣波妞003197♣♣㏘♣④④♣</span></span><br><span class="line"><span class="comment">// 去掉最后的一个分隔符 </span></span><br><span class="line">msg = rs.substring(<span class="number">0</span>, rs.lastIndexOf(Constants.SPILIT));</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 将消息发送给所有的客户端 */</span></span><br><span class="line">sendMsgToAll(flag,msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">2</span> || flag == <span class="number">3</span>)&#123;</span><br><span class="line"><span class="comment">// 读到消息  群发的 或者 @消息</span></span><br><span class="line">String newMsg = dis.readUTF() ; <span class="comment">// 消息</span></span><br><span class="line"><span class="comment">// 得到发件人 </span></span><br><span class="line">String sendName = ServerChat.onLineSockets.get(socket);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内容</span></span><br><span class="line">StringBuilder msgFinal = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">// 时间  </span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss EEE&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">2</span>)&#123;</span><br><span class="line">msgFinal.append(sendName).append(<span class="string">&quot;  &quot;</span>).append(sdf.format(System.currentTimeMillis())).append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">msgFinal.append(<span class="string">&quot;    &quot;</span>).append(newMsg).append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">sendMsgToAll(flag,msgFinal.toString());</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">3</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMsgToAll</span><span class="params">(<span class="keyword">int</span> flag, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 拿到所有的在线socket管道 给这些管道写出消息</span></span><br><span class="line">Set&lt;Socket&gt; allOnLineSockets = ServerChat.onLineSockets.keySet();</span><br><span class="line"><span class="keyword">for</span>(Socket sk :  allOnLineSockets)&#123;</span><br><span class="line">DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(sk.getOutputStream());</span><br><span class="line">dos.writeInt(flag); <span class="comment">// 消息类型</span></span><br><span class="line">dos.writeUTF(msg);</span><br><span class="line">dos.flush();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h5><ul><li>此处根据消息的类型判断为群聊消息，然后把群聊消息推送给当前在线的所有客户端。</li></ul><h4 id="服务端接收私聊消息"><a href="#服务端接收私聊消息" class="headerlink" title="服务端接收私聊消息"></a>服务端接收私聊消息</h4><h5 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h5><p>在上节我们接收了客户端发来的群聊消息推送给当前在线的所有客户端，接下来要解决私聊消息的推送逻辑</p><h5 id="实现步骤-3"><a href="#实现步骤-3" class="headerlink" title="实现步骤"></a>实现步骤</h5><ul><li>解决私聊消息的推送逻辑，私聊消息需要知道推送给某个具体的客户端</li><li>我们可以接收到客户端发来的私聊用户名称，根据用户名称定位该用户的Socket管道，然后单独推送消息给该Socket管道。</li><li>需要注意的是，服务端需要接收客户端的消息可能有很多种。<ul><li>分别是登陆消息，群聊消息，私聊消息 和@消息。</li><li>这里需要约定如果客户端发送消息之前需要先发送消息的类型，类型我们使用信号值标志（1，2，3）。<ul><li>1代表接收的是登陆消息</li><li>2代表群发| @消息</li><li>3代表了私聊消息</li></ul></li></ul></li></ul><h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerReader</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Socket socket;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerReader</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.socket = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">dis = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line"><span class="comment">/** 1.循环一直等待客户端的消息 */</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">/** 2.读取当前的消息类型 ：登录,群发,私聊 , @消息 */</span></span><br><span class="line"><span class="keyword">int</span> flag = dis.readInt();</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">/** 先将当前登录的客户端socket存到在线人数的socket集合中   */</span></span><br><span class="line">String name = dis.readUTF() ;</span><br><span class="line">System.out.println(name+<span class="string">&quot;----&gt;&quot;</span>+socket.getRemoteSocketAddress());</span><br><span class="line">ServerChat.onLineSockets.put(socket, name);</span><br><span class="line">&#125;</span><br><span class="line">writeMsg(flag,dis);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;--有人下线了--&quot;</span>);</span><br><span class="line"><span class="comment">// 从在线人数中将当前socket移出去  </span></span><br><span class="line">ServerChat.onLineSockets.remove(socket);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 从新更新在线人数并发给所有客户端 </span></span><br><span class="line">writeMsg(<span class="number">1</span>,dis);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeMsg</span><span class="params">(<span class="keyword">int</span> flag, DataInputStream dis)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// DataOutputStream dos = new DataOutputStream(socket.getOutputStream()); </span></span><br><span class="line"><span class="comment">// 定义一个变量存放最终的消息形式 </span></span><br><span class="line">String msg = <span class="keyword">null</span> ;</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">/** 读取所有在线人数发给所有客户端去更新自己的在线人数列表 */</span></span><br><span class="line"><span class="comment">/** onlineNames = [波仔,zhangsan,波妞]*/</span></span><br><span class="line">StringBuilder rs = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">Collection&lt;String&gt; onlineNames = ServerChat.onLineSockets.values();</span><br><span class="line"><span class="comment">// 判断是否存在在线人数 </span></span><br><span class="line"><span class="keyword">if</span>(onlineNames != <span class="keyword">null</span> &amp;&amp; onlineNames.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(String name : onlineNames)&#123;</span><br><span class="line">rs.append(name+ Constants.SPILIT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 波仔003197♣♣㏘♣④④♣zhangsan003197♣♣㏘♣④④♣波妞003197♣♣㏘♣④④♣</span></span><br><span class="line"><span class="comment">// 去掉最后的一个分隔符 </span></span><br><span class="line">msg = rs.substring(<span class="number">0</span>, rs.lastIndexOf(Constants.SPILIT));</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 将消息发送给所有的客户端 */</span></span><br><span class="line">sendMsgToAll(flag,msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">2</span> || flag == <span class="number">3</span>)&#123;</span><br><span class="line"><span class="comment">// 读到消息  群发的 或者 @消息</span></span><br><span class="line">String newMsg = dis.readUTF() ; <span class="comment">// 消息</span></span><br><span class="line"><span class="comment">// 得到发件人 </span></span><br><span class="line">String sendName = ServerChat.onLineSockets.get(socket);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内容</span></span><br><span class="line">StringBuilder msgFinal = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">// 时间  </span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss EEE&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">2</span>)&#123;</span><br><span class="line">msgFinal.append(sendName).append(<span class="string">&quot;  &quot;</span>).append(sdf.format(System.currentTimeMillis())).append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">msgFinal.append(<span class="string">&quot;    &quot;</span>).append(newMsg).append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">sendMsgToAll(flag,msgFinal.toString());</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">3</span>)&#123;</span><br><span class="line">msgFinal.append(sendName).append(<span class="string">&quot;  &quot;</span>).append(sdf.format(System.currentTimeMillis())).append(<span class="string">&quot;对您私发\r\n&quot;</span>);</span><br><span class="line">msgFinal.append(<span class="string">&quot;    &quot;</span>).append(newMsg).append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"><span class="comment">// 私发 </span></span><br><span class="line"><span class="comment">// 得到给谁私发 </span></span><br><span class="line">String destName = dis.readUTF();</span><br><span class="line">sendMsgToOne(destName,msgFinal.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destName 对谁私发 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg 发的消息内容 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMsgToOne</span><span class="params">(String destName, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 拿到所有的在线socket管道 给这些管道写出消息</span></span><br><span class="line">Set&lt;Socket&gt; allOnLineSockets = ServerChat.onLineSockets.keySet();</span><br><span class="line"><span class="keyword">for</span>(Socket sk :  allOnLineSockets)&#123;</span><br><span class="line"><span class="comment">// 得到当前需要私发的socket </span></span><br><span class="line"><span class="comment">// 只对这个名字对应的socket私发消息</span></span><br><span class="line"><span class="keyword">if</span>(ServerChat.onLineSockets.get(sk).trim().equals(destName))&#123;</span><br><span class="line">DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(sk.getOutputStream());</span><br><span class="line">dos.writeInt(<span class="number">2</span>); <span class="comment">// 消息类型</span></span><br><span class="line">dos.writeUTF(msg);</span><br><span class="line">dos.flush();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMsgToAll</span><span class="params">(<span class="keyword">int</span> flag, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 拿到所有的在线socket管道 给这些管道写出消息</span></span><br><span class="line">Set&lt;Socket&gt; allOnLineSockets = ServerChat.onLineSockets.keySet();</span><br><span class="line"><span class="keyword">for</span>(Socket sk :  allOnLineSockets)&#123;</span><br><span class="line">DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(sk.getOutputStream());</span><br><span class="line">dos.writeInt(flag); <span class="comment">// 消息类型</span></span><br><span class="line">dos.writeUTF(msg);</span><br><span class="line">dos.flush();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h5><ul><li>本节我们解决了私聊消息的推送逻辑，私聊消息需要知道推送给某个具体的客户端Socket管道</li><li>我们可以接收到客户端发来的私聊用户名称，根据用户名称定位该用户的Socket管道，然后单独推送消息给该Socket管道。</li></ul><h3 id="客户端设计"><a href="#客户端设计" class="headerlink" title="客户端设计"></a>客户端设计</h3><h4 id="启动客户端界面-登陆，刷新在线"><a href="#启动客户端界面-登陆，刷新在线" class="headerlink" title="启动客户端界面 ,登陆，刷新在线"></a>启动客户端界面 ,登陆，刷新在线</h4><h5 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h5><p><strong>启动客户端界面</strong>，登陆，刷新在线人数列表</p><h5 id="实现步骤-4"><a href="#实现步骤-4" class="headerlink" title="实现步骤"></a>实现步骤</h5><ul><li>客户端界面主要是GUI设计，主体页面分为登陆界面和聊天窗口，以及在线用户列表。</li><li>GUI界面读者可以自行复制使用。</li><li>登陆输入服务端ip和用户名后，要请求与服务端的登陆，然后立即为当前客户端分配一个读线程处理客户端的读数据消息。因为客户端可能随时会接收到服务端那边转发过来的各种即时消息信息。</li><li>客户端登陆完成，服务端收到登陆的用户名后，会立即发来最新的用户列表给客户端更新。</li></ul><h5 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h5><p><strong>客户端主体代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientChat</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">   <span class="comment">/** 1.设计界面  */</span></span><br><span class="line">   <span class="keyword">private</span> JFrame win = <span class="keyword">new</span> JFrame();</span><br><span class="line">   <span class="comment">/** 2.消息内容框架 */</span></span><br><span class="line">   <span class="keyword">public</span> JTextArea smsContent =<span class="keyword">new</span> JTextArea(<span class="number">23</span> , <span class="number">50</span>);</span><br><span class="line">   <span class="comment">/** 3.发送消息的框  */</span></span><br><span class="line">   <span class="keyword">private</span> JTextArea smsSend = <span class="keyword">new</span> JTextArea(<span class="number">4</span>,<span class="number">40</span>);</span><br><span class="line">   <span class="comment">/** 4.在线人数的区域  */</span></span><br><span class="line">   <span class="comment">/** 存放人的数据 */</span></span><br><span class="line">   <span class="comment">/** 展示在线人数的窗口 */</span></span><br><span class="line">   <span class="keyword">public</span> JList&lt;String&gt; onLineUsers = <span class="keyword">new</span> JList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否私聊按钮</span></span><br><span class="line">   <span class="keyword">private</span> JCheckBox isPrivateBn = <span class="keyword">new</span> JCheckBox(<span class="string">&quot;私聊&quot;</span>);</span><br><span class="line">   <span class="comment">// 消息按钮</span></span><br><span class="line">   <span class="keyword">private</span> JButton sendBn  = <span class="keyword">new</span> JButton(<span class="string">&quot;发送&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 登录界面</span></span><br><span class="line">   <span class="keyword">private</span> JFrame loginView;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> JTextField ipEt , nameEt , idEt;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Socket socket ;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">new</span> ClientChat().initView();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">/** 初始化聊天窗口的界面 */</span></span><br><span class="line">      win.setSize(<span class="number">650</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 展示登录界面  */</span></span><br><span class="line">      displayLoginView();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 展示聊天界面 */</span></span><br><span class="line">      <span class="comment">//displayChatView();</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">displayChatView</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      JPanel bottomPanel = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> BorderLayout());</span><br><span class="line">      <span class="comment">//-----------------------------------------------</span></span><br><span class="line">      <span class="comment">// 将消息框和按钮 添加到窗口的底端</span></span><br><span class="line">      win.add(bottomPanel, BorderLayout.SOUTH);</span><br><span class="line">      bottomPanel.add(smsSend);</span><br><span class="line">      JPanel btns = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.LEFT));</span><br><span class="line">      btns.add(sendBn);</span><br><span class="line">      btns.add(isPrivateBn);</span><br><span class="line">      bottomPanel.add(btns, BorderLayout.EAST);</span><br><span class="line">      <span class="comment">//-----------------------------------------------</span></span><br><span class="line">      <span class="comment">// 给发送消息按钮绑定点击事件监听器</span></span><br><span class="line">      <span class="comment">// 将展示消息区centerPanel添加到窗口的中间</span></span><br><span class="line">      smsContent.setBackground(<span class="keyword">new</span> Color(<span class="number">0xdd</span>,<span class="number">0xdd</span>,<span class="number">0xdd</span>));</span><br><span class="line">      <span class="comment">// 让展示消息区可以滚动。</span></span><br><span class="line">      win.add(<span class="keyword">new</span> JScrollPane(smsContent), BorderLayout.CENTER);</span><br><span class="line">      smsContent.setEditable(<span class="keyword">false</span>);</span><br><span class="line">      <span class="comment">//-----------------------------------------------</span></span><br><span class="line">      <span class="comment">// 用户列表和是否私聊放到窗口的最右边</span></span><br><span class="line">      Box rightBox = <span class="keyword">new</span> Box(BoxLayout.Y_AXIS);</span><br><span class="line">      onLineUsers.setFixedCellWidth(<span class="number">120</span>);</span><br><span class="line">      onLineUsers.setVisibleRowCount(<span class="number">13</span>);</span><br><span class="line">      rightBox.add(<span class="keyword">new</span> JScrollPane(onLineUsers));</span><br><span class="line">      win.add(rightBox, BorderLayout.EAST);</span><br><span class="line">      <span class="comment">//-----------------------------------------------</span></span><br><span class="line">      <span class="comment">// 关闭窗口退出当前程序</span></span><br><span class="line">      win.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">      win.pack();  <span class="comment">// swing 加上这句 就可以拥有关闭窗口的功能</span></span><br><span class="line">      <span class="comment">/** 设置窗口居中,显示出来  */</span></span><br><span class="line">      setWindowCenter(win,<span class="number">650</span>,<span class="number">600</span>,<span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">// 发送按钮绑定点击事件</span></span><br><span class="line">      sendBn.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">displayLoginView</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 先让用户进行登录</span></span><br><span class="line"><span class="comment">       *  服务端ip</span></span><br><span class="line"><span class="comment">       *  用户名</span></span><br><span class="line"><span class="comment">       *  id</span></span><br><span class="line"><span class="comment">       *  */</span></span><br><span class="line">      <span class="comment">/** 显示一个qq的登录框     */</span></span><br><span class="line">      loginView = <span class="keyword">new</span> JFrame(<span class="string">&quot;登录&quot;</span>);</span><br><span class="line">      loginView.setLayout(<span class="keyword">new</span> GridLayout(<span class="number">3</span>, <span class="number">1</span>));</span><br><span class="line">      loginView.setSize(<span class="number">400</span>, <span class="number">230</span>);</span><br><span class="line"></span><br><span class="line">      JPanel ip = <span class="keyword">new</span> JPanel();</span><br><span class="line">      JLabel label = <span class="keyword">new</span> JLabel(<span class="string">&quot;   IP:&quot;</span>);</span><br><span class="line">      ip.add(label);</span><br><span class="line">      ipEt = <span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">      ip.add(ipEt);</span><br><span class="line">      loginView.add(ip);</span><br><span class="line"></span><br><span class="line">      JPanel name = <span class="keyword">new</span> JPanel();</span><br><span class="line">      JLabel label1 = <span class="keyword">new</span> JLabel(<span class="string">&quot;姓名:&quot;</span>);</span><br><span class="line">      name.add(label1);</span><br><span class="line">      nameEt = <span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">      name.add(nameEt);</span><br><span class="line">      loginView.add(name);</span><br><span class="line"></span><br><span class="line">      JPanel btnView = <span class="keyword">new</span> JPanel();</span><br><span class="line">      JButton login = <span class="keyword">new</span> JButton(<span class="string">&quot;登陆&quot;</span>);</span><br><span class="line">      btnView.add(login);</span><br><span class="line">      JButton cancle = <span class="keyword">new</span> JButton(<span class="string">&quot;取消&quot;</span>);</span><br><span class="line">      btnView.add(cancle);</span><br><span class="line">      loginView.add(btnView);</span><br><span class="line">      <span class="comment">// 关闭窗口退出当前程序</span></span><br><span class="line">      loginView.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">      setWindowCenter(loginView,<span class="number">400</span>,<span class="number">260</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 给登录和取消绑定点击事件 */</span></span><br><span class="line">      login.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">      cancle.addActionListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setWindowCenter</span><span class="params">(JFrame frame, <span class="keyword">int</span> width , <span class="keyword">int</span> height, <span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/** 得到所在系统所在屏幕的宽高 */</span></span><br><span class="line">      Dimension ds = frame.getToolkit().getScreenSize();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 拿到电脑的宽 */</span></span><br><span class="line">      <span class="keyword">int</span> width1 = ds.width;</span><br><span class="line">      <span class="comment">/** 高 */</span></span><br><span class="line">      <span class="keyword">int</span> height1 = ds.height ;</span><br><span class="line"></span><br><span class="line">      System.out.println(width1 +<span class="string">&quot;*&quot;</span> + height1);</span><br><span class="line">      <span class="comment">/** 设置窗口的左上角坐标 */</span></span><br><span class="line">      frame.setLocation(width1/<span class="number">2</span> - width/<span class="number">2</span>, height1/<span class="number">2</span> -height/<span class="number">2</span>);</span><br><span class="line">      frame.setVisible(flag);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/** 得到点击的事件源 */</span></span><br><span class="line">      JButton btn = (JButton) e.getSource();</span><br><span class="line">      <span class="keyword">switch</span>(btn.getText())&#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;登陆&quot;</span>:</span><br><span class="line">            String ip = ipEt.getText().toString();</span><br><span class="line">            String name = nameEt.getText().toString();</span><br><span class="line">            <span class="comment">// 校验参数是否为空</span></span><br><span class="line">            <span class="comment">// 错误提示</span></span><br><span class="line">            String msg = <span class="string">&quot;&quot;</span> ;</span><br><span class="line">            <span class="comment">// 12.1.2.0</span></span><br><span class="line">            <span class="comment">// \d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\</span></span><br><span class="line">            <span class="keyword">if</span>(ip==<span class="keyword">null</span> || !ip.matches(<span class="string">&quot;\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;&quot;</span>))&#123;</span><br><span class="line">               msg = <span class="string">&quot;请输入合法的服务端ip地址&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(name==<span class="keyword">null</span> || !name.matches(<span class="string">&quot;\\S&#123;1,&#125;&quot;</span>))&#123;</span><br><span class="line">               msg = <span class="string">&quot;姓名必须1个字符以上&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!msg.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">               <span class="comment">/** msg有内容说明参数有为空 */</span></span><br><span class="line">               <span class="comment">// 参数一：弹出放到哪个窗口里面</span></span><br><span class="line">               JOptionPane.showMessageDialog(loginView, msg);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 参数都合法了</span></span><br><span class="line">                  <span class="comment">// 当前登录的用户,去服务端登陆</span></span><br><span class="line">                  <span class="comment">/** 先把当前用户的名称展示到界面 */</span></span><br><span class="line">                  win.setTitle(name);</span><br><span class="line">                  <span class="comment">// 去服务端登陆连接一个socket管道</span></span><br><span class="line">                  socket = <span class="keyword">new</span> Socket(ip, Constants.PORT);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">//为客户端的socket分配一个线程 专门负责收消息</span></span><br><span class="line">                  <span class="keyword">new</span> ClientReader(<span class="keyword">this</span>,socket).start();</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 带上用户信息过去</span></span><br><span class="line">                  DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line">                  dos.writeInt(<span class="number">1</span>); <span class="comment">// 登录消息</span></span><br><span class="line">                  dos.writeUTF(name.trim());</span><br><span class="line">                  dos.flush();</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 关系当前窗口 弹出聊天界面</span></span><br><span class="line">                  loginView.dispose(); <span class="comment">// 登录窗口销毁</span></span><br><span class="line">                  displayChatView(); <span class="comment">// 展示了聊天窗口了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">                  e1.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;取消&quot;</span>:</span><br><span class="line">            <span class="comment">/** 退出系统 */</span></span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;发送&quot;</span>:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端socket处理线程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientReader</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="comment">// 接收客户端界面，方便收到消息后，更新界面数据。</span></span><br><span class="line">   <span class="keyword">private</span> ClientChat clientChat ;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ClientReader</span><span class="params">(ClientChat clientChat, Socket socket)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.clientChat = clientChat;</span><br><span class="line">      <span class="keyword">this</span>.socket = socket;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         DataInputStream dis = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line">         <span class="comment">/** 循环一直等待客户端的消息 */</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">/** 读取当前的消息类型 ：登录,群发,私聊 , @消息 */</span></span><br><span class="line">            <span class="keyword">int</span> flag = dis.readInt();</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">               <span class="comment">// 在线人数消息回来了</span></span><br><span class="line">               String nameDatas = dis.readUTF();</span><br><span class="line">               <span class="comment">// 展示到在线人数的界面</span></span><br><span class="line">               String[] names = nameDatas.split(Constants.SPILIT);</span><br><span class="line"></span><br><span class="line">               clientChat.onLineUsers.setListData(names);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">2</span>)&#123;</span><br><span class="line">              </span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h5><ul><li>此处说明了如果启动客户端界面，以及登陆功能后，服务端收到新的登陆消息后，会响应一个在线列表用户回来给客户端更新在线人数！</li></ul><h4 id="客户端发送消息逻辑"><a href="#客户端发送消息逻辑" class="headerlink" title="客户端发送消息逻辑"></a>客户端发送消息逻辑</h4><h5 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h5><p>客户端发送群聊消息，@消息，以及私聊消息。</p><h5 id="实现步骤-5"><a href="#实现步骤-5" class="headerlink" title="实现步骤"></a>实现步骤</h5><ul><li>客户端启动后，在聊天界面需要通过发送按钮推送群聊消息，@消息，以及私聊消息。</li><li><img src="https://csliujw.github.io/blog/img/pics/JavaStrengthen/io/image-20200223232406727.png"></li><li>如果直接点击发送，默认发送群聊消息</li><li>如果选中右侧在线列表某个用户，默认发送@消息</li><li>如果选中右侧在线列表某个用户，然后选择右下侧私聊按钮默，认发送私聊消息。</li></ul><h5 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h5><p><strong>客户端主体代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientChat</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line"><span class="comment">/** 1.设计界面  */</span></span><br><span class="line"><span class="keyword">private</span> JFrame win = <span class="keyword">new</span> JFrame();</span><br><span class="line"><span class="comment">/** 2.消息内容框架 */</span></span><br><span class="line"><span class="keyword">public</span> JTextArea smsContent =<span class="keyword">new</span> JTextArea(<span class="number">23</span> , <span class="number">50</span>);</span><br><span class="line"><span class="comment">/** 3.发送消息的框  */</span></span><br><span class="line"><span class="keyword">private</span> JTextArea smsSend = <span class="keyword">new</span> JTextArea(<span class="number">4</span>,<span class="number">40</span>);</span><br><span class="line"><span class="comment">/** 4.在线人数的区域  */</span></span><br><span class="line"><span class="comment">/** 存放人的数据 */</span></span><br><span class="line"><span class="comment">/** 展示在线人数的窗口 */</span></span><br><span class="line"><span class="keyword">public</span> JList&lt;String&gt; onLineUsers = <span class="keyword">new</span> JList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否私聊按钮</span></span><br><span class="line"><span class="keyword">private</span> JCheckBox isPrivateBn = <span class="keyword">new</span> JCheckBox(<span class="string">&quot;私聊&quot;</span>);</span><br><span class="line"><span class="comment">// 消息按钮</span></span><br><span class="line"><span class="keyword">private</span> JButton sendBn  = <span class="keyword">new</span> JButton(<span class="string">&quot;发送&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录界面</span></span><br><span class="line"><span class="keyword">private</span> JFrame loginView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> JTextField ipEt , nameEt , idEt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Socket socket ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> ClientChat().initView();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/** 初始化聊天窗口的界面 */</span></span><br><span class="line">win.setSize(<span class="number">650</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 展示登录界面  */</span></span><br><span class="line">displayLoginView();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 展示聊天界面 */</span></span><br><span class="line"><span class="comment">//displayChatView();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">displayChatView</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">JPanel bottomPanel = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> BorderLayout());</span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="comment">// 将消息框和按钮 添加到窗口的底端</span></span><br><span class="line">win.add(bottomPanel, BorderLayout.SOUTH);</span><br><span class="line">bottomPanel.add(smsSend);</span><br><span class="line">JPanel btns = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> FlowLayout(FlowLayout.LEFT));</span><br><span class="line">btns.add(sendBn);</span><br><span class="line">btns.add(isPrivateBn);</span><br><span class="line">bottomPanel.add(btns, BorderLayout.EAST);</span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="comment">// 给发送消息按钮绑定点击事件监听器</span></span><br><span class="line"><span class="comment">// 将展示消息区centerPanel添加到窗口的中间</span></span><br><span class="line">smsContent.setBackground(<span class="keyword">new</span> Color(<span class="number">0xdd</span>,<span class="number">0xdd</span>,<span class="number">0xdd</span>));</span><br><span class="line"><span class="comment">// 让展示消息区可以滚动。</span></span><br><span class="line">win.add(<span class="keyword">new</span> JScrollPane(smsContent), BorderLayout.CENTER);</span><br><span class="line">smsContent.setEditable(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="comment">// 用户列表和是否私聊放到窗口的最右边</span></span><br><span class="line">Box rightBox = <span class="keyword">new</span> Box(BoxLayout.Y_AXIS);</span><br><span class="line">onLineUsers.setFixedCellWidth(<span class="number">120</span>);</span><br><span class="line">onLineUsers.setVisibleRowCount(<span class="number">13</span>);</span><br><span class="line">rightBox.add(<span class="keyword">new</span> JScrollPane(onLineUsers));</span><br><span class="line">win.add(rightBox, BorderLayout.EAST);</span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="comment">// 关闭窗口退出当前程序</span></span><br><span class="line">win.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">win.pack();  <span class="comment">// swing 加上这句 就可以拥有关闭窗口的功能</span></span><br><span class="line"><span class="comment">/** 设置窗口居中,显示出来  */</span></span><br><span class="line">setWindowCenter(win,<span class="number">650</span>,<span class="number">600</span>,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 发送按钮绑定点击事件</span></span><br><span class="line">sendBn.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">displayLoginView</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 先让用户进行登录</span></span><br><span class="line"><span class="comment"> *  服务端ip</span></span><br><span class="line"><span class="comment"> *  用户名</span></span><br><span class="line"><span class="comment"> *  id</span></span><br><span class="line"><span class="comment"> *  */</span></span><br><span class="line"><span class="comment">/** 显示一个qq的登录框     */</span></span><br><span class="line">loginView = <span class="keyword">new</span> JFrame(<span class="string">&quot;登录&quot;</span>);</span><br><span class="line">loginView.setLayout(<span class="keyword">new</span> GridLayout(<span class="number">3</span>, <span class="number">1</span>));</span><br><span class="line">loginView.setSize(<span class="number">400</span>, <span class="number">230</span>);</span><br><span class="line"></span><br><span class="line">JPanel ip = <span class="keyword">new</span> JPanel();</span><br><span class="line">JLabel label = <span class="keyword">new</span> JLabel(<span class="string">&quot;   IP:&quot;</span>);</span><br><span class="line">ip.add(label);</span><br><span class="line">ipEt = <span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">ip.add(ipEt);</span><br><span class="line">loginView.add(ip);</span><br><span class="line"></span><br><span class="line">JPanel name = <span class="keyword">new</span> JPanel();</span><br><span class="line">JLabel label1 = <span class="keyword">new</span> JLabel(<span class="string">&quot;姓名:&quot;</span>);</span><br><span class="line">name.add(label1);</span><br><span class="line">nameEt = <span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">name.add(nameEt);</span><br><span class="line">loginView.add(name);</span><br><span class="line"></span><br><span class="line">JPanel btnView = <span class="keyword">new</span> JPanel();</span><br><span class="line">JButton login = <span class="keyword">new</span> JButton(<span class="string">&quot;登陆&quot;</span>);</span><br><span class="line">btnView.add(login);</span><br><span class="line">JButton cancle = <span class="keyword">new</span> JButton(<span class="string">&quot;取消&quot;</span>);</span><br><span class="line">btnView.add(cancle);</span><br><span class="line">loginView.add(btnView);</span><br><span class="line"><span class="comment">// 关闭窗口退出当前程序</span></span><br><span class="line">loginView.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">setWindowCenter(loginView,<span class="number">400</span>,<span class="number">260</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 给登录和取消绑定点击事件 */</span></span><br><span class="line">login.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">cancle.addActionListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setWindowCenter</span><span class="params">(JFrame frame, <span class="keyword">int</span> width , <span class="keyword">int</span> height, <span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line"><span class="comment">/** 得到所在系统所在屏幕的宽高 */</span></span><br><span class="line">Dimension ds = frame.getToolkit().getScreenSize();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 拿到电脑的宽 */</span></span><br><span class="line"><span class="keyword">int</span> width1 = ds.width;</span><br><span class="line"><span class="comment">/** 高 */</span></span><br><span class="line"><span class="keyword">int</span> height1 = ds.height ;</span><br><span class="line"></span><br><span class="line">System.out.println(width1 +<span class="string">&quot;*&quot;</span> + height1);</span><br><span class="line"><span class="comment">/** 设置窗口的左上角坐标 */</span></span><br><span class="line">frame.setLocation(width1/<span class="number">2</span> - width/<span class="number">2</span>, height1/<span class="number">2</span> -height/<span class="number">2</span>);</span><br><span class="line">frame.setVisible(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line"><span class="comment">/** 得到点击的事件源 */</span></span><br><span class="line">JButton btn = (JButton) e.getSource();</span><br><span class="line"><span class="keyword">switch</span>(btn.getText())&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;登陆&quot;</span>:</span><br><span class="line">String ip = ipEt.getText().toString();</span><br><span class="line">String name = nameEt.getText().toString();</span><br><span class="line"><span class="comment">// 校验参数是否为空</span></span><br><span class="line"><span class="comment">// 错误提示</span></span><br><span class="line">String msg = <span class="string">&quot;&quot;</span> ;</span><br><span class="line"><span class="comment">// 12.1.2.0</span></span><br><span class="line"><span class="comment">// \d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\</span></span><br><span class="line"><span class="keyword">if</span>(ip==<span class="keyword">null</span> || !ip.matches(<span class="string">&quot;\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;&quot;</span>))&#123;</span><br><span class="line">msg = <span class="string">&quot;请输入合法的服务端ip地址&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(name==<span class="keyword">null</span> || !name.matches(<span class="string">&quot;\\S&#123;1,&#125;&quot;</span>))&#123;</span><br><span class="line">msg = <span class="string">&quot;姓名必须1个字符以上&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!msg.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line"><span class="comment">/** msg有内容说明参数有为空 */</span></span><br><span class="line"><span class="comment">// 参数一：弹出放到哪个窗口里面</span></span><br><span class="line">JOptionPane.showMessageDialog(loginView, msg);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 参数都合法了</span></span><br><span class="line"><span class="comment">// 当前登录的用户,去服务端登陆</span></span><br><span class="line"><span class="comment">/** 先把当前用户的名称展示到界面 */</span></span><br><span class="line">win.setTitle(name);</span><br><span class="line"><span class="comment">// 去服务端登陆连接一个socket管道</span></span><br><span class="line">socket = <span class="keyword">new</span> Socket(ip, Constants.PORT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为客户端的socket分配一个线程 专门负责收消息</span></span><br><span class="line"><span class="keyword">new</span> ClientReader(<span class="keyword">this</span>,socket).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带上用户信息过去</span></span><br><span class="line">DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line">dos.writeInt(<span class="number">1</span>); <span class="comment">// 登录消息</span></span><br><span class="line">dos.writeUTF(name.trim());</span><br><span class="line">dos.flush();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关系当前窗口 弹出聊天界面</span></span><br><span class="line">loginView.dispose(); <span class="comment">// 登录窗口销毁</span></span><br><span class="line">displayChatView(); <span class="comment">// 展示了聊天窗口了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;取消&quot;</span>:</span><br><span class="line"><span class="comment">/** 退出系统 */</span></span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;发送&quot;</span>:</span><br><span class="line"><span class="comment">// 得到发送消息的内容</span></span><br><span class="line">String msgSend = smsSend.getText().toString();</span><br><span class="line"><span class="keyword">if</span>(!msgSend.trim().equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line"><span class="comment">/** 发消息给服务端 */</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 判断是否对谁发消息</span></span><br><span class="line">String selectName = onLineUsers.getSelectedValue();</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">2</span> ;<span class="comment">// 群发 @消息</span></span><br><span class="line"><span class="keyword">if</span>(selectName!=<span class="keyword">null</span>&amp;&amp;!selectName.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">msgSend =(<span class="string">&quot;@&quot;</span>+selectName+<span class="string">&quot;,&quot;</span>+msgSend);</span><br><span class="line"><span class="comment">/** 判断是否选中了私法 */</span></span><br><span class="line"><span class="keyword">if</span>(isPrivateBn.isSelected())&#123;</span><br><span class="line"><span class="comment">/** 私法 */</span></span><br><span class="line">flag = <span class="number">3</span> ;<span class="comment">//私发消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line">dos.writeInt(flag); <span class="comment">// 群发消息  发送给所有人</span></span><br><span class="line">dos.writeUTF(msgSend);</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">3</span>)&#123;</span><br><span class="line"><span class="comment">// 告诉服务端我对谁私发</span></span><br><span class="line">dos.writeUTF(selectName.trim());</span><br><span class="line">&#125;</span><br><span class="line">dos.flush();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">smsSend.setText(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端socket处理线程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientReader</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Socket socket;</span><br><span class="line"><span class="keyword">private</span> ClientChat clientChat ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClientReader</span><span class="params">(ClientChat clientChat, Socket socket)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.clientChat = clientChat;</span><br><span class="line"><span class="keyword">this</span>.socket = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line"><span class="comment">/** 循环一直等待客户端的消息 */</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">/** 读取当前的消息类型 ：登录,群发,私聊 , @消息 */</span></span><br><span class="line"><span class="keyword">int</span> flag = dis.readInt();</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">// 在线人数消息回来了</span></span><br><span class="line">String nameDatas = dis.readUTF();</span><br><span class="line"><span class="comment">// 展示到在线人数的界面</span></span><br><span class="line">String[] names = nameDatas.split(Constants.SPILIT);</span><br><span class="line"></span><br><span class="line">clientChat.onLineUsers.setListData(names);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">//群发,私聊 , @消息 都是直接显示的。</span></span><br><span class="line">String msg = dis.readUTF() ;</span><br><span class="line">clientChat.smsContent.append(msg);</span><br><span class="line"><span class="comment">// 让消息界面滾動到底端</span></span><br><span class="line">clientChat.smsContent.setCaretPosition(clientChat.smsContent.getText().length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h5><ul><li>此处实现了客户端发送群聊消息，@消息，以及私聊消息。</li><li>如果直接点击发送，默认发送群聊消息</li><li>如果选中右侧在线列表某个用户，默认发送@消息</li><li>如果选中右侧在线列表某个用户，然后选择右下侧私聊按钮默，认发送私聊消息。</li></ul><h1 id="第四章-JAVA-NIO深入剖析"><a href="#第四章-JAVA-NIO深入剖析" class="headerlink" title="第四章 JAVA NIO深入剖析"></a>第四章 JAVA NIO深入剖析</h1><p>在讲解利用NIO实现通信架构之前，我们需要先来了解一下NIO的基本特点和使用。</p><h2 id="4-1-Java-NIO-基本介绍"><a href="#4-1-Java-NIO-基本介绍" class="headerlink" title="4.1 Java NIO 基本介绍"></a>4.1 Java NIO 基本介绍</h2><ul><li>Java NIO（New IO）也有人称之为 java non-blocking IO是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面<strong>向缓冲区</strong>的、基于<strong>通道</strong>的IO操作。NIO将以更加高效的方式进行文件的读写操作。NIO可以理解为非阻塞IO,传统的IO的read和write只能阻塞执行，线程在读写IO期间不能干其他事情，比如调用socket.read()时，如果服务器一直没有数据传输过来，线程就一直阻塞，而NIO中可以配置socket为非阻塞模式。</li><li>NIO 相关类都被放在 java.nio 包及子包下，并且对原 java.io 包中的很多类进行改写。</li><li>NIO 有三大核心部分：<code>Channel(通道)</code>，<code>Buffer(缓冲区)</code>，<code>Selector(选择器)</code></li><li>Java NIO 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。<code>（基于通道进行数据读取的，通道中没有数据，线程不会进行阻塞，会去做其他事情，有数据时再来读取。很像OS的线程中断驱动I/O；DMA的I/O）</code><ul><li>==中断驱动I/O：==等待数据传输完成的过程中，CPU去做其他事。数据传输完成后，用中断进行通知。中断驱动I/O的缺点是I/O发生在每一个字符上。</li><li>==DMA的I/O：==DMA负责I/O请求，CPU不用管事。DMA速度比CPU执行速度慢很多，如果CPU在等待DMA的同时没有其他的事要做，那么采用中断驱动I/O或程序控制I/O可能会更好。</li></ul></li><li>通俗理解：NIO 是可以做到用一个线程来处理多个操作的。假设有 1000 个请求过来,根据实际情况，可以分配20 或者 80个线程来处理。不像之前的阻塞 IO 那样，非得分配 1000 个。</li></ul><h2 id="4-2-NIO-和-BIO-的比较"><a href="#4-2-NIO-和-BIO-的比较" class="headerlink" title="4.2 NIO 和 BIO 的比较"></a>4.2 NIO 和 BIO 的比较</h2><ul><li>BIO 以流的方式处理数据,而 <code>NIO 以块的方式处理数据</code>,块 I/O 的效率比流 I/O 高很多<ul><li>中断驱动I/O：一个字符一个字符产生中断</li><li>DMA：一个块的传输结束后产生中断</li></ul></li><li>BIO 是阻塞的，NIO 则是非阻塞的<ul><li>程序控制I/O是阻塞的。</li><li>中断、DMA是非阻塞的。</li></ul></li><li>BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据总是从通道<br>读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道</li></ul><table><thead><tr><th>NIO</th><th>BIO</th></tr></thead><tbody><tr><td>面向缓冲区（Buffer）</td><td>面向流（Stream）</td></tr><tr><td>非阻塞（Non Blocking IO）</td><td>阻塞IO(Blocking IO)</td></tr><tr><td>选择器（Selectors）</td><td></td></tr></tbody></table><blockquote><p>NIO示意图</p></blockquote><img src="https://csliujw.github.io/blog/img/pics/JavaStrengthen/io/image-20210522103002504.png"><h2 id="4-3-NIO-三大核心原理示意图"><a href="#4-3-NIO-三大核心原理示意图" class="headerlink" title="4.3 NIO 三大核心原理示意图"></a>4.3 NIO 三大核心原理示意图</h2><p>NIO 有三大核心部分：<strong>Channel( 通道) ，Buffer( 缓冲区), Selector( 选择器)</strong></p><h3 id="Buffer缓冲区"><a href="#Buffer缓冲区" class="headerlink" title="Buffer缓冲区"></a>Buffer缓冲区</h3><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。相比较直接对数组的操作，Buffer API更加容易操作和管理。</p><h3 id="Channel（通道）"><a href="#Channel（通道）" class="headerlink" title="Channel（通道）"></a>Channel（通道）</h3><p>Java NIO的通道类似流，但又有些不同：既可以从通道中读取数据，又可以写数据到通道。但流的（input或output)读写通常是单向的。 通道可以非阻塞读取和写入通道，通道可以支持读取或写入缓冲区，也支持异步地读写。</p><h3 id="Selector选择器"><a href="#Selector选择器" class="headerlink" title="Selector选择器"></a>Selector选择器</h3><p>Selector是 一个Java NIO组件，可以能够检查一个或多个 NIO 通道，并确定哪些通道已经准备好进行读取或写入。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接，提高效率</p><ul><li>每个 channel 都会对应一个 Buffer</li><li>一个线程对应Selector ， 一个Selector对应多个 channel(连接)</li><li>程序切换到哪个 channel 是由事件决定的</li><li>Selector 会根据不同的事件，在各个通道上切换</li><li>Buffer 就是一个内存块 ， 底层是一个数组</li><li>数据的读取写入是通过 Buffer完成的 , BIO 中要么是输入流，或者是输出流, 不能双向，但是 NIO 的 Buffer 是可以读也可以写。</li><li>Java NIO系统的核心在于：通道(Channel)和缓冲区 (Buffer)。通道表示打开到 IO 设备(例如：文件、 套接字)的连接。若需要使用 NIO 系统，需要获取 用于连接 IO 设备的通道以及用于容纳数据的缓冲 区。然后操作缓冲区，对数据进行处理。简而言之，Channel 负责传输， Buffer 负责存取数据</li></ul><h2 id="4-4-NIO核心一：缓冲区-Buffer"><a href="#4-4-NIO核心一：缓冲区-Buffer" class="headerlink" title="4.4 NIO核心一：缓冲区(Buffer)"></a>4.4 NIO核心一：缓冲区(Buffer)</h2><h3 id="缓冲区（Buffer）"><a href="#缓冲区（Buffer）" class="headerlink" title="缓冲区（Buffer）"></a>缓冲区（Buffer）</h3><p>一个用于特定基本数据类 型的容器。由 java.nio 包定义的，所有缓冲区 都是 Buffer 抽象类的子类.。Java NIO 中的 Buffer 主要用于与 NIO 通道进行 交互，数据是从通道读入缓冲区，从缓冲区写入通道中的</p><img src="https://csliujw.github.io/blog/img/pics/JavaStrengthen/io/Buffer_PIC.png"><h3 id="Buffer-类及其子类"><a href="#Buffer-类及其子类" class="headerlink" title="Buffer 类及其子类"></a><strong>Buffer 类及其子类</strong></h3><p><strong>Buffer</strong> 就像一个数组，可以保存多个相同类型的数据。根 据数据类型不同 ，有以下 Buffer 常用子类：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p>上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自 管理的数据类型不同而已。都是通过如下方法获取一个 Buffer 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> XxxBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> : 创建一个容量为capacity 的 XxxBuffer 对象</span></span><br></pre></td></tr></table></figure><h3 id="缓冲区的基本属性"><a href="#缓冲区的基本属性" class="headerlink" title="缓冲区的基本属性"></a>缓冲区的基本属性</h3><p>Buffer 中的重要概念：</p><ul><li><strong>容量 (capacity)</strong> ：作为一个内存块，Buffer具有一定的固定大小，也称为”容量”，缓冲区容量不能为负，并且创建后不能更改。</li><li>**限制 (limit)**：表示缓冲区中可以操作数据的大小（limit 后数据不能进行读写）。缓冲区的限制不能为负，并且不能大于其容量。 <strong>写入模式，限制等于buffer的容量。读取模式下，limit等于写入的数据量</strong>。</li><li>**位置 (position)**：下一个要读取或写入的数据的索引。缓冲区的位置不能为 负，并且不能大于其限制</li><li>**标记 (mark)与重置 (reset)**：标记是一个索引，通过 Buffer 中的 mark() 方法 指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这 个 position. <strong>标记、位置、限制、容量遵守以下不变式： 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</strong></li><li><strong>图示:</strong></li></ul><img src="https://csliujw.github.io/blog/img/pics/JavaStrengthen/io/allocate_1.png"><h3 id="Buffer常见方法"><a href="#Buffer常见方法" class="headerlink" title="Buffer常见方法"></a>Buffer常见方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Buffer <span class="title">clear</span><span class="params">()</span> 清空缓冲区并返回对缓冲区的引用</span></span><br><span class="line"><span class="function">Buffer <span class="title">flip</span><span class="params">()</span> 为 将缓冲区的界限设置为当前位置，并将当前位置充值为 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> 返回 Buffer 的 capacity 大小</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span> 判断缓冲区中是否还有元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span> 返回 Buffer 的界限<span class="params">(limit)</span> 的位置</span></span><br><span class="line"><span class="function">Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> n)</span> 将设置缓冲区界限为 n, 并返回一个具有新 limit 的缓冲区对象</span></span><br><span class="line"><span class="function">Buffer <span class="title">mark</span><span class="params">()</span> 对缓冲区设置标记</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">position</span><span class="params">()</span> 返回缓冲区的当前位置 position</span></span><br><span class="line"><span class="function">Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> n)</span> 将设置缓冲区的当前位置为 n , 并返回修改后的 Buffer 对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span> 返回 position 和 limit 之间的元素个数</span></span><br><span class="line"><span class="function">Buffer <span class="title">reset</span><span class="params">()</span> 将位置 position 转到以前设置的 mark 所在的位置</span></span><br><span class="line"><span class="function">Buffer <span class="title">rewind</span><span class="params">()</span> 将位置设为为 0， 取消设置的 mark</span></span><br></pre></td></tr></table></figure><h3 id="缓冲区的数据操作"><a href="#缓冲区的数据操作" class="headerlink" title="缓冲区的数据操作"></a>缓冲区的数据操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Buffer 所有子类提供了两个用于数据操作的方法：get()put() 方法</span><br><span class="line">取获取 Buffer中的数据</span><br><span class="line">get() ：读取单个字节</span><br><span class="line">get(<span class="keyword">byte</span>[] dst)：批量读取多个字节到 dst 中</span><br><span class="line">get(<span class="keyword">int</span> index)：读取指定索引位置的字节(不会移动 position)</span><br><span class="line">    </span><br><span class="line">放到 入数据到 Buffer 中 中</span><br><span class="line">put(<span class="keyword">byte</span> b)：将给定单个字节写入缓冲区的当前位置</span><br><span class="line">put(<span class="keyword">byte</span>[] src)：将 src 中的字节写入缓冲区的当前位置</span><br><span class="line">put(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)：将指定字节写入缓冲区的索引位置(不会移动 position)</span><br></pre></td></tr></table></figure><p><strong>使用Buffer读写数据一般遵循以下四个步骤：</strong></p><ul><li>1.写入数据到Buffer</li><li>2.调用flip()方法，转换为读取模式</li><li>3.从Buffer中读取数据</li><li>4.调用buffer.clear()方法或者buffer.compact()方法清除缓冲区</li></ul><h3 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBuffer</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//分配直接缓冲区</span></span><br><span class="line">      ByteBuffer buf = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">      System.out.println(buf.isDirect());</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">      String str = <span class="string">&quot;itheima&quot;</span>;</span><br><span class="line">      </span><br><span class="line">      ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">      </span><br><span class="line">      buf.put(str.getBytes());</span><br><span class="line">      </span><br><span class="line">      buf.flip();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.limit()];</span><br><span class="line">      buf.get(dst, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">      System.out.println(<span class="keyword">new</span> String(dst, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">      System.out.println(buf.position());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//mark() : 标记</span></span><br><span class="line">      buf.mark();</span><br><span class="line">      </span><br><span class="line">      buf.get(dst, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">      System.out.println(<span class="keyword">new</span> String(dst, <span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">      System.out.println(buf.position());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//reset() : 恢复到 mark 的位置</span></span><br><span class="line">      buf.reset();</span><br><span class="line">      System.out.println(buf.position());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//判断缓冲区中是否还有剩余数据</span></span><br><span class="line">      <span class="keyword">if</span>(buf.hasRemaining())&#123;</span><br><span class="line">         <span class="comment">//获取缓冲区中可以操作的数量</span></span><br><span class="line">         System.out.println(buf.remaining());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">      String str = <span class="string">&quot;itheima&quot;</span>;</span><br><span class="line">      <span class="comment">//1. 分配一个指定大小的缓冲区</span></span><br><span class="line">      ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;-----------------allocate()----------------&quot;</span>);</span><br><span class="line">      System.out.println(buf.position());</span><br><span class="line">      System.out.println(buf.limit());</span><br><span class="line">      System.out.println(buf.capacity());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//2. 利用 put() 存入数据到缓冲区中</span></span><br><span class="line">      buf.put(str.getBytes());</span><br><span class="line">      System.out.println(<span class="string">&quot;-----------------put()----------------&quot;</span>);</span><br><span class="line">      System.out.println(buf.position());</span><br><span class="line">      System.out.println(buf.limit());</span><br><span class="line">      System.out.println(buf.capacity());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//3. 切换读取数据模式</span></span><br><span class="line">      buf.flip();</span><br><span class="line">      System.out.println(<span class="string">&quot;-----------------flip()----------------&quot;</span>);</span><br><span class="line">      System.out.println(buf.position());</span><br><span class="line">      System.out.println(buf.limit());</span><br><span class="line">      System.out.println(buf.capacity());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//4. 利用 get() 读取缓冲区中的数据</span></span><br><span class="line">      <span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.limit()];</span><br><span class="line">      buf.get(dst);</span><br><span class="line">      System.out.println(<span class="keyword">new</span> String(dst, <span class="number">0</span>, dst.length));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;-----------------get()----------------&quot;</span>);</span><br><span class="line">      System.out.println(buf.position());</span><br><span class="line">      System.out.println(buf.limit());</span><br><span class="line">      System.out.println(buf.capacity());</span><br><span class="line">      <span class="comment">//5. rewind() : 可重复读</span></span><br><span class="line">      buf.rewind();</span><br><span class="line">      System.out.println(<span class="string">&quot;-----------------rewind()----------------&quot;</span>);</span><br><span class="line">      System.out.println(buf.position());</span><br><span class="line">      System.out.println(buf.limit());</span><br><span class="line">      System.out.println(buf.capacity());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//6. clear() : 清空缓冲区. 但是缓冲区中的数据依然存在，但是处于“被遗忘”状态</span></span><br><span class="line">      buf.clear();</span><br><span class="line">      System.out.println(<span class="string">&quot;-----------------clear()----------------&quot;</span>);</span><br><span class="line">      System.out.println(buf.position());</span><br><span class="line">      System.out.println(buf.limit());</span><br><span class="line">      System.out.println(buf.capacity());</span><br><span class="line">      System.out.println((<span class="keyword">char</span>)buf.get());</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="直接与非直接缓冲区"><a href="#直接与非直接缓冲区" class="headerlink" title="直接与非直接缓冲区"></a>直接与非直接缓冲区</h3><p>什么是直接内存与非直接内存</p><p>根据官方文档的描述：</p><p><code>byte byffer</code>可以是两种类型，一种是基于直接内存（也就是非堆内存）；另一种是非直接内存（也就是堆内存）。对于直接内存来说，JVM将会在IO操作上具有更高的性能，因为它直接作用于本地系统的IO操作。而非直接内存，也就是堆内存中的数据，如果要作IO操作，会先从本进程内存复制到直接内存，再利用本地IO处理。</p><p>从数据流的角度，非直接内存是下面这样的作用链：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本地IO--&gt;直接内存--&gt;非直接内存--&gt;直接内存--&gt;本地IO</span><br></pre></td></tr></table></figure><p>而直接内存是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本地IO--&gt;直接内存--&gt;本地IO</span><br></pre></td></tr></table></figure><p>很明显，在做IO处理时，比如网络发送大量数据时，直接内存会具有更高的效率。直接内存使用allocateDirect创建，但是它比申请普通的堆内存需要耗费更高的性能。不过，这部分的数据是在JVM之外的，因此它不会占用应用的内存。所以呢，当你有很大的数据要缓存，并且它的生命周期又很长，那么就比较适合使用直接内存。只是一般来说，如果不是能带来很明显的性能提升，还是推荐直接使用堆内存。字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect() 方法来确定。</p><p><strong>使用场景</strong></p><ul><li>1 有很大的数据需要存储，它的生命周期又很长</li><li>2 适合频繁的IO操作，比如网络并发场景</li></ul><h2 id="4-5-NIO核心二：通道-Channel"><a href="#4-5-NIO核心二：通道-Channel" class="headerlink" title="4.5 NIO核心二：通道(Channel)"></a>4.5 NIO核心二：通道(Channel)</h2><h3 id="通道Channe概述"><a href="#通道Channe概述" class="headerlink" title="通道Channe概述"></a>通道Channe概述</h3><p>通道（Channel）：由 java.nio.channels 包定义 的。Channel 表示 IO 源与目标打开的连接。 Channel 类似于传统的“流”。只不过 Channel 本身不能直接访问数据，Channel 只能与 Buffer 进行交互。</p><p>1、 NIO 的通道类似于流，但有些区别如下：</p><ul><li>通道可以同时进行读写，而流只能读或者只能写</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲读数据，也可以写数据到缓冲:</li></ul><p>2、BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道(Channel) 是双向的，可以读操作，也可以写操作。</p><p>3、Channel 在 NIO 中是一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span> <span class="keyword">extends</span> <span class="title">Closeable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="常用的Channel实现类"><a href="#常用的Channel实现类" class="headerlink" title="常用的Channel实现类"></a>常用的Channel实现类</h3><ul><li>FileChannel：用于读取、写入、映射和操作文件的通道。</li><li>DatagramChannel：通过 UDP 读写网络中的数据通道。</li><li>SocketChannel：通过 TCP 读写网络中的数据。</li><li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。 【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】</li></ul><h3 id="FileChannel-类"><a href="#FileChannel-类" class="headerlink" title="FileChannel 类"></a>FileChannel 类</h3><p>获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下：</p><ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li><li>DatagramSocket</li><li>Socket</li><li>ServerSocket 获取通道的其他方式是使用 Files 类的静态方法 newByteChannel() 获取字节通道。或者通过通道的静态方法 open() 打开并返回指定通道</li></ul><h3 id="FileChannel的常用方法"><a href="#FileChannel的常用方法" class="headerlink" title="FileChannel的常用方法"></a>FileChannel的常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> 从 从  Channel 到 中读取数据到  ByteBuffer</span></span><br><span class="line"><span class="function"><span class="keyword">long</span>  <span class="title">read</span><span class="params">(ByteBuffer[] dsts)</span> 将 将  Channel 到 中的数据“分散”到  ByteBuffer[]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">write</span><span class="params">(ByteBuffer src)</span> 将 将  ByteBuffer 到 中的数据写入到  Channel</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs)</span> 将 将  ByteBuffer[] 到 中的数据“聚集”到  Channel</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">position</span><span class="params">()</span> 返回此通道的文件位置</span></span><br><span class="line"><span class="function">FileChannel <span class="title">position</span><span class="params">(<span class="keyword">long</span> p)</span> 设置此通道的文件位置</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">size</span><span class="params">()</span> 返回此通道的文件的当前大小</span></span><br><span class="line"><span class="function">FileChannel <span class="title">truncate</span><span class="params">(<span class="keyword">long</span> s)</span> 将此通道的文件截取为给定大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">force</span><span class="params">(<span class="keyword">boolean</span> metaData)</span> 强制将所有对此通道的文件更新写入到存储设备中</span></span><br></pre></td></tr></table></figure><h3 id="案例1-本地文件写数据"><a href="#案例1-本地文件写数据" class="headerlink" title="案例1-本地文件写数据"></a>案例1-本地文件写数据</h3><p>需求：使用前面学习后的 ByteBuffer(缓冲) 和 FileChannel(通道)， 将 “hello,黑马Java程序员！” 写入到 data.txt 中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、字节输出流通向目标文件</span></span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;data01.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 2、得到字节输出流对应的通道Channel</span></span><br><span class="line">            FileChannel channel = fos.getChannel();</span><br><span class="line">            <span class="comment">// 3、分配缓冲区</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            buffer.put(<span class="string">&quot;hello,黑马Java程序员！&quot;</span>.getBytes());</span><br><span class="line">            <span class="comment">// 4、把缓冲区切换成写出模式</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            channel.write(buffer);</span><br><span class="line">            channel.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;写数据到文件中！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例2-本地文件读数据"><a href="#案例2-本地文件读数据" class="headerlink" title="案例2-本地文件读数据"></a>案例2-本地文件读数据</h3><p>需求：使用前面学习后的 ByteBuffer(缓冲) 和 FileChannel(通道)， 将 data01.txt 中的数据读入到程序，并显示在控制台屏幕</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1、定义一个文件字节输入流与源文件接通</span></span><br><span class="line">        FileInputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;data01.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、需要得到文件字节输入流的文件通道</span></span><br><span class="line">        FileChannel channel = is.getChannel();</span><br><span class="line">        <span class="comment">// 3、定义一个缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 4、读取数据到缓冲区</span></span><br><span class="line">        channel.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// 5、读取出缓冲区中的数据并输出即可</span></span><br><span class="line">        String rs = <span class="keyword">new</span> String(buffer.array(),<span class="number">0</span>,buffer.remaining());</span><br><span class="line">        System.out.println(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例3-使用Buffer完成文件复制"><a href="#案例3-使用Buffer完成文件复制" class="headerlink" title="案例3-使用Buffer完成文件复制"></a>案例3-使用Buffer完成文件复制</h3><p>使用 FileChannel(通道) ，完成文件的拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 源文件</span></span><br><span class="line">    File srcFile = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\dlei\\Desktop\\BIO,NIO,AIO\\文件\\壁纸.jpg&quot;</span>);</span><br><span class="line">    File destFile = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\dlei\\Desktop\\BIO,NIO,AIO\\文件\\壁纸new.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">// 得到一个字节字节输入流</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">    <span class="comment">// 得到一个字节输出流</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destFile);</span><br><span class="line">    <span class="comment">// 得到的是文件通道</span></span><br><span class="line">    FileChannel isChannel = fis.getChannel();</span><br><span class="line">    FileChannel osChannel = fos.getChannel();</span><br><span class="line">    <span class="comment">// 分配缓冲区</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 必须先清空缓冲然后再写入数据到缓冲区</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="comment">// 开始读取一次数据</span></span><br><span class="line">        <span class="keyword">int</span> flag = isChannel.read(buffer);</span><br><span class="line">        <span class="keyword">if</span>(flag == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经读取了数据 ，把缓冲区的模式切换成可读模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// 把数据写出到</span></span><br><span class="line">        osChannel.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    isChannel.close();</span><br><span class="line">    osChannel.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;复制完成！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例4-分散-Scatter-和聚集-Gather"><a href="#案例4-分散-Scatter-和聚集-Gather" class="headerlink" title="案例4-分散 (Scatter) 和聚集 (Gather)"></a>案例4-分散 (Scatter) 和聚集 (Gather)</h3><p>分散读取（Scatter ）:是指把Channel通道的数据读入到多个缓冲区中去</p><p>聚集写入（Gathering ）是指将多个 Buffer 中的数据“聚集”到 Channel。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分散和聚集</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">RandomAccessFile raf1 = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="comment">//1. 获取通道</span></span><br><span class="line">FileChannel channel1 = raf1.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 分配指定大小的缓冲区</span></span><br><span class="line">ByteBuffer buf1 = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">ByteBuffer buf2 = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 分散读取</span></span><br><span class="line">ByteBuffer[] bufs = &#123;buf1, buf2&#125;;</span><br><span class="line">channel1.read(bufs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ByteBuffer byteBuffer : bufs) &#123;</span><br><span class="line">byteBuffer.flip();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(bufs[<span class="number">0</span>].array(), <span class="number">0</span>, bufs[<span class="number">0</span>].limit()));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(bufs[<span class="number">1</span>].array(), <span class="number">0</span>, bufs[<span class="number">1</span>].limit()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 聚集写入</span></span><br><span class="line">RandomAccessFile raf2 = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;2.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">FileChannel channel2 = raf2.getChannel();</span><br><span class="line"></span><br><span class="line">channel2.write(bufs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例5-transferFrom"><a href="#案例5-transferFrom" class="headerlink" title="案例5-transferFrom()"></a>案例5-transferFrom()</h3><p>从目标通道中去复制原通道数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1、字节输入管道</span></span><br><span class="line">    FileInputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;data01.txt&quot;</span>);</span><br><span class="line">    FileChannel isChannel = is.getChannel();</span><br><span class="line">    <span class="comment">// 2、字节输出流管道</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;data03.txt&quot;</span>);</span><br><span class="line">    FileChannel osChannel = fos.getChannel();</span><br><span class="line">    <span class="comment">// 3、复制</span></span><br><span class="line">    osChannel.transferFrom(isChannel,isChannel.position(),isChannel.size());</span><br><span class="line">    isChannel.close();</span><br><span class="line">    osChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例6-transferTo"><a href="#案例6-transferTo" class="headerlink" title="案例6-transferTo()"></a>案例6-transferTo()</h3><p>把原通道数据复制到目标通道</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1、字节输入管道</span></span><br><span class="line">    FileInputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;data01.txt&quot;</span>);</span><br><span class="line">    FileChannel isChannel = is.getChannel();</span><br><span class="line">    <span class="comment">// 2、字节输出流管道</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;data04.txt&quot;</span>);</span><br><span class="line">    FileChannel osChannel = fos.getChannel();</span><br><span class="line">    <span class="comment">// 3、复制</span></span><br><span class="line">    isChannel.transferTo(isChannel.position() , isChannel.size() , osChannel);</span><br><span class="line">    isChannel.close();</span><br><span class="line">    osChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-NIO核心三：选择器-Selector"><a href="#4-6-NIO核心三：选择器-Selector" class="headerlink" title="4.6 NIO核心三：选择器(Selector)"></a>4.6 NIO核心三：选择器(Selector)</h2><h3 id="选择器-Selector-概述"><a href="#选择器-Selector-概述" class="headerlink" title="选择器(Selector)概述"></a>选择器(Selector)概述</h3><p>选择器（Selector） 是 SelectableChannle 对象的多路复用器，Selector 可以同时监控多个 SelectableChannel 的 IO 状况，也就是说，利用 Selector可使一个单独的线程管理多个 Channel。Selector 是非阻塞 IO 的核心</p><img src="https://csliujw.github.io/blog/img/pics/JavaStrengthen/io/selector_imp.png"><ul><li>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到 Selector(选择器)</li><li>Selector 能够检测多个注册的通道上是否有事件发生(注意:多个 Channel 以事件的方式可以注册到同一个 Selector)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管 理多个通道，也就是管理多个连接和请求。</li><li>只有在 连接/通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都 创建一个线程，不用去维护多个线程</li><li>避免了多线程之间的上下文切换导致的开销</li></ul><h3 id="选择-器（Selector）的应用"><a href="#选择-器（Selector）的应用" class="headerlink" title="选择 器（Selector）的应用"></a>选择 器（Selector）的应用</h3><p>创建 Selector ：通过调用 Selector.open() 方法创建一个 Selector。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><p>向选择器注册通道：SelectableChannel.register(Selector sel, int ops)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 获取通道</span></span><br><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">//2. 切换非阻塞模式</span></span><br><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//3. 绑定连接</span></span><br><span class="line">ssChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</span><br><span class="line"><span class="comment">//4. 获取选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"><span class="comment">//5. 将通道注册到选择器上, 并且指定“监听接收事件”</span></span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure><p>当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数 ops 指定。可以监听的事件类型（用 可使用 SelectionKey 的四个常量 表示）：</p><ul><li>读 : SelectionKey.OP_READ （1）</li><li>写 : SelectionKey.OP_WRITE （4）</li><li>连接 : SelectionKey.OP_CONNECT （8）</li><li>接收 : SelectionKey.OP_ACCEPT （16）</li><li>若注册时不止监听一个事件，则可以使用“位或”操作符连接。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ|SelectionKey.OP_WRITE </span><br></pre></td></tr></table></figure><h2 id="4-7-NIO非阻塞式网络通信原理分析"><a href="#4-7-NIO非阻塞式网络通信原理分析" class="headerlink" title="4.7 NIO非阻塞式网络通信原理分析"></a>4.7 NIO非阻塞式网络通信原理分析</h2><h3 id="Selector-示意图和特点说明"><a href="#Selector-示意图和特点说明" class="headerlink" title="Selector 示意图和特点说明"></a>Selector 示意图和特点说明</h3><p>Selector可以实现： 一个 I/O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I/O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p><img src="https://csliujw.github.io/blog/img/pics/JavaStrengthen/io/NIO_Three.png"><h3 id="服务端流程"><a href="#服务端流程" class="headerlink" title="服务端流程"></a>服务端流程</h3><ul><li><p>1、当客户端连接服务端时，服务端会通过 ServerSocketChannel 得到 SocketChannel：1. 获取通道</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br></pre></td></tr></table></figure></li><li><p>2、切换非阻塞模式</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></li><li><p>3、绑定连接</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br></pre></td></tr></table></figure></li><li><p>4、 获取选择器</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure></li><li><p>5、 将通道注册到选择器上, 并且指定“监听接收事件”</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure></li><li><ol><li>轮询式的获取选择器上已经“准备就绪”的事件</li></ol></li><li><p>```java<br>  //轮询式的获取选择器上已经“准备就绪”的事件<br>   while (selector.select() &gt; 0) {</p><pre><code>      System.out.println(&quot;轮一轮&quot;);      //7. 获取当前选择器中所有注册的“选择键(已就绪的监听事件)”      Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();      while (it.hasNext()) &#123;          //8. 获取准备“就绪”的是事件          SelectionKey sk = it.next();          //9. 判断具体是什么事件准备就绪          if (sk.isAcceptable()) &#123;              //10. 若“接收就绪”，获取客户端连接              SocketChannel sChannel = ssChannel.accept();              //11. 切换非阻塞模式              sChannel.configureBlocking(false);              //12. 将该通道注册到选择器上              sChannel.register(selector, SelectionKey.OP_READ);          &#125; else if (sk.isReadable()) &#123;              //13. 获取当前选择器上“读就绪”状态的通道              SocketChannel sChannel = (SocketChannel) sk.channel();              //14. 读取数据              ByteBuffer buf = ByteBuffer.allocate(1024);              int len = 0;              while ((len = sChannel.read(buf)) &gt; 0) &#123;                  buf.flip();                  System.out.println(new String(buf.array(), 0, len));                  buf.clear();              &#125;          &#125;          //15. 取消选择键 SelectionKey          it.remove();      &#125;  &#125;</code></pre><p>  }</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 客户端流程</span><br><span class="line"></span><br><span class="line">- 1. 获取通道</span><br><span class="line"></span><br><span class="line">        ```java</span><br><span class="line">        SocketChannel sChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 9999));</span><br></pre></td></tr></table></figure></li><li><ol><li><p>切换非阻塞模式</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sChannel.configureBlocking(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></li></ol></li><li><ol><li>分配指定大小的缓冲区</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure></li><li><ol><li><p>发送数据给服务端</p><p>   Scanner scan = new Scanner(System.in); while(scan.hasNext()){ String str = scan.nextLine(); buf.put((new SimpleDateFormat(“yyyy/MM/dd HH:mm:ss”).format(System.currentTimeMillis()) + “\n” + str).getBytes()); buf.flip(); sChannel.write(buf); buf.clear(); } //关闭通道 sChannel.close();</p></li></ol></li></ul><h2 id="4-8-NIO非阻塞式网络通信入门案例"><a href="#4-8-NIO非阻塞式网络通信入门案例" class="headerlink" title="4.8 NIO非阻塞式网络通信入门案例"></a>4.8 NIO非阻塞式网络通信入门案例</h2><p>需求：服务端接收客户端的连接请求，并接收多个客户端发送过来的事件。</p><h3 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//1. 获取通道</span></span><br><span class="line">SocketChannel sChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>));</span><br><span class="line"><span class="comment">//2. 切换非阻塞模式</span></span><br><span class="line">sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//3. 分配指定大小的缓冲区</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="comment">//4. 发送数据给服务端</span></span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">while</span>(scan.hasNext())&#123;</span><br><span class="line">String str = scan.nextLine();</span><br><span class="line">buf.put((<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>).format(System.currentTimeMillis())</span><br><span class="line">+ <span class="string">&quot;\n&quot;</span> + str).getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line">sChannel.write(buf);</span><br><span class="line">buf.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5. 关闭通道</span></span><br><span class="line">sChannel.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取通道</span></span><br><span class="line">        ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//2. 切换非阻塞模式</span></span><br><span class="line">        ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//3. 绑定连接</span></span><br><span class="line">        ssChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">        <span class="comment">//4. 获取选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//5. 将通道注册到选择器上, 并且指定“监听接收事件”</span></span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">//6. 轮询式的获取选择器上已经“准备就绪”的事件</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;轮一轮&quot;</span>);</span><br><span class="line">            <span class="comment">//7. 获取当前选择器中所有注册的“选择键(已就绪的监听事件)”</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//8. 获取准备“就绪”的是事件</span></span><br><span class="line">                SelectionKey sk = it.next();</span><br><span class="line">                <span class="comment">//9. 判断具体是什么事件准备就绪</span></span><br><span class="line">                <span class="keyword">if</span> (sk.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">//10. 若“接收就绪”，获取客户端连接</span></span><br><span class="line">                    SocketChannel sChannel = ssChannel.accept();</span><br><span class="line">                    <span class="comment">//11. 切换非阻塞模式</span></span><br><span class="line">                    sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//12. 将该通道注册到选择器上</span></span><br><span class="line">                    sChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">//13. 获取当前选择器上“读就绪”状态的通道</span></span><br><span class="line">                    SocketChannel sChannel = (SocketChannel) sk.channel();</span><br><span class="line">                    <span class="comment">//14. 读取数据</span></span><br><span class="line">                    ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((len = sChannel.read(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        buf.flip();</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(buf.array(), <span class="number">0</span>, len));</span><br><span class="line">                        buf.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//15. 取消选择键 SelectionKey</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-9-NIO-网络编程应用实例-群聊系统"><a href="#4-9-NIO-网络编程应用实例-群聊系统" class="headerlink" title="4.9 NIO 网络编程应用实例-群聊系统"></a>4.9 NIO 网络编程应用实例-群聊系统</h2><h3 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h3><p><strong>需求:进一步理解 NIO 非阻塞网络编程机制，实现多人群聊</strong></p><ul><li>编写一个 NIO 群聊系统，实现客户端与客户端的通信需求（非阻塞）</li><li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li><li>客户端：通过 channel 可以无阻塞发送消息给其它所有客户端用户，同时可以接受其它客户端用户通过服务端转发来的消息</li></ul><h3 id="服务端代码实现"><a href="#服务端代码实现" class="headerlink" title="服务端代码实现"></a>服务端代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel ssChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">9999</span>;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、获取通道</span></span><br><span class="line">            ssChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">// 2、切换为非阻塞模式</span></span><br><span class="line">            ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 3、绑定连接的端口</span></span><br><span class="line">            ssChannel.bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            <span class="comment">// 4、获取选择器Selector</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">// 5、将通道都注册到选择器上去，并且开始指定监听接收事件</span></span><br><span class="line">            ssChannel.register(selector , SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始一轮事件处理~~~&quot;</span>);</span><br><span class="line">                <span class="comment">// 7、获取选择器中的所有注册的通道中已经就绪好的事件</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="comment">// 8、开始遍历这些准备好的事件</span></span><br><span class="line">                <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">                    <span class="comment">// 提取当前这个事件</span></span><br><span class="line">                    SelectionKey sk = it.next();</span><br><span class="line">                    <span class="comment">// 9、判断这个事件具体是什么</span></span><br><span class="line">                    <span class="keyword">if</span>(sk.isAcceptable())&#123;</span><br><span class="line">                        <span class="comment">// 10、直接获取当前接入的客户端通道</span></span><br><span class="line">                        SocketChannel schannel = ssChannel.accept();</span><br><span class="line">                        <span class="comment">// 11 、切换成非阻塞模式</span></span><br><span class="line">                        schannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                        <span class="comment">// 12、将本客户端通道注册到选择器</span></span><br><span class="line">                        System.out.println(schannel.getRemoteAddress() + <span class="string">&quot; 上线 &quot;</span>);</span><br><span class="line">                        schannel.register(selector , SelectionKey.OP_READ);</span><br><span class="line">                        <span class="comment">//提示</span></span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sk.isReadable())&#123;</span><br><span class="line">                        <span class="comment">//处理读 (专门写方法..)</span></span><br><span class="line">                        readData(sk);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    it.remove(); <span class="comment">// 处理完毕之后需要移除当前事件</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//发生异常处理....</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取客户端消息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//取到关联的channle</span></span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//得到channel</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//创建buffer</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">int</span> count = channel.read(buffer);</span><br><span class="line">            <span class="comment">//根据count的值做处理</span></span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//把缓存区的数据转成字符串</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                <span class="comment">//输出该消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;form 客户端: &quot;</span> + msg);</span><br><span class="line">                <span class="comment">//向其它的客户端转发消息(去掉自己), 专门写一个方法来处理</span></span><br><span class="line">                sendInfoToOtherClients(msg, channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">&quot; 离线了..&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">                e2.printStackTrace();;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转发消息给其它客户(通道)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInfoToOtherClients</span><span class="params">(String msg, SocketChannel self )</span> <span class="keyword">throws</span>  IOException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息中...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发数据给客户端线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//遍历 所有注册到selector 上的 SocketChannel,并排除 self</span></span><br><span class="line">        <span class="keyword">for</span>(SelectionKey key: selector.keys()) &#123;</span><br><span class="line">            <span class="comment">//通过 key  取出对应的 SocketChannel</span></span><br><span class="line">            Channel targetChannel = key.channel();</span><br><span class="line">            <span class="comment">//排除自己</span></span><br><span class="line">            <span class="keyword">if</span>(targetChannel <span class="keyword">instanceof</span>  SocketChannel &amp;&amp; targetChannel != self) &#123;</span><br><span class="line">                <span class="comment">//转型</span></span><br><span class="line">                SocketChannel dest = (SocketChannel)targetChannel;</span><br><span class="line">                <span class="comment">//将msg 存储到buffer</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">//将buffer 的数据写入 通道</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建服务器对象</span></span><br><span class="line">        Server groupChatServer = <span class="keyword">new</span> Server();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端代码实现"><a href="#客户端代码实现" class="headerlink" title="客户端代码实现"></a>客户端代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.chat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义相关的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String HOST = <span class="string">&quot;127.0.0.1&quot;</span>; <span class="comment">// 服务器的ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">9999</span>; <span class="comment">//服务器端口</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器, 完成初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        socketChannel = socketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, PORT));</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//将channel 注册到selector</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">//得到username</span></span><br><span class="line">        username = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(username + <span class="string">&quot; is ok...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        info = username + <span class="string">&quot; 说：&quot;</span> + info;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取从服务器端回复的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> readChannels = selector.select();</span><br><span class="line">            <span class="keyword">if</span>(readChannels &gt; <span class="number">0</span>) &#123;<span class="comment">//有可以用的通道</span></span><br><span class="line"></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">                        <span class="comment">//得到相关的通道</span></span><br><span class="line">                       SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                       <span class="comment">//得到一个Buffer</span></span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//读取</span></span><br><span class="line">                        sc.read(buffer);</span><br><span class="line">                        <span class="comment">//把读到的缓冲区的数据转成字符串</span></span><br><span class="line">                        String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                        System.out.println(msg.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                iterator.remove(); <span class="comment">//删除当前的selectionKey, 防止重复操作</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;没有可以用的通道...&quot;);</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//启动我们客户端</span></span><br><span class="line">        Client chatClient = <span class="keyword">new</span> Client();</span><br><span class="line">        <span class="comment">//启动一个线程, 每个3秒，读取从服务器发送数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    chatClient.readInfo();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据给服务器端</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            chatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-12"><a href="#小结-12" class="headerlink" title="小结"></a>小结</h3><h1 id="第五章-JAVA-AIO深入剖析"><a href="#第五章-JAVA-AIO深入剖析" class="headerlink" title="第五章 JAVA AIO深入剖析"></a>第五章 JAVA AIO深入剖析</h1><h2 id="5-1-AIO编程"><a href="#5-1-AIO编程" class="headerlink" title="5.1 AIO编程"></a>5.1 AIO编程</h2><ul><li>Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AIO</span><br><span class="line">异步非阻塞，基于NIO的，可以称之为NIO2<span class="number">.0</span></span><br><span class="line">BIO                         NIO                              AIO        </span><br><span class="line">Socket                SocketChannel                    AsynchronousSocketChannel</span><br><span class="line">ServerSocket          ServerSocketChannel          AsynchronousServerSocketChannel</span><br></pre></td></tr></table></figure><p>与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可, 这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区,对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序</p><p>即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。在JDK1.7中，这部分内容被称作NIO.2，主要在Java.nio.channels包下增加了下面四个异步通道：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousSocketChannel</span><br><span class="line">AsynchronousServerSocketChannel</span><br><span class="line">AsynchronousFileChannel</span><br><span class="line">AsynchronousDatagramChannel</span><br></pre></td></tr></table></figure><h1 id="第六章-BIO-NIO-AIO课程总结"><a href="#第六章-BIO-NIO-AIO课程总结" class="headerlink" title="第六章 BIO,NIO,AIO课程总结"></a>第六章 BIO,NIO,AIO课程总结</h1><p><strong>BIO、NIO、AIO：</strong></p><ul><li>Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li><li>Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</li><li>Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</li></ul><p><strong>BIO、NIO、AIO适用场景分析:</strong></p><ul><li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li><li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li><li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。Netty!</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;BIO NIO AIO的学习笔记&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaSE" scheme="https://csliujw.github.io/blog/tags/JavaSE/"/>
    
    <category term="IO" scheme="https://csliujw.github.io/blog/tags/IO/"/>
    
    <category term="NIO" scheme="https://csliujw.github.io/blog/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>hello hexo markdown</title>
    <link href="https://csliujw.github.io/blog/hexo%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://csliujw.github.io/blog/hexo%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2016-11-16T10:11:25.000Z</published>
    <updated>2021-07-24T15:01:23.841Z</updated>
    
    <content type="html"><![CDATA[<p>我是短小精悍的文章摘要(๑•̀ㅂ•́) ✧</p><span id="more"></span><p>紧接着文章摘要的正文内容</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我是短小精悍的文章摘要(๑•̀ㅂ•́) ✧&lt;/p&gt;</summary>
    
    
    
    
    <category term="hello" scheme="https://csliujw.github.io/blog/tags/hello/"/>
    
    <category term="hexo" scheme="https://csliujw.github.io/blog/tags/hexo/"/>
    
    <category term="markdown" scheme="https://csliujw.github.io/blog/tags/markdown/"/>
    
  </entry>
  
</feed>
