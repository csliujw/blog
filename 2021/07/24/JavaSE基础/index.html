<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="yanm1ng&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/blog/css/images/logo.png">
  
  <title>
    
      JavaSE基础 | Papyhone
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/blog/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    
<script src="/blog/js/qrious.js"></script>

  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/blog/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.4.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/blog/">
      <div class="logo"></div>
      <span>Papyhone</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/blog/" class="item-link">首页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/blog/series/" class="item-link">文章</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/blog/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/blog/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/blog/project/" class="item-link">项目</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/blog/about/" class="item-link">关于</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/blog/" class="menu-link">首页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/blog/series/" class="menu-link">文章</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/blog/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/blog/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/blog/project/" class="menu-link">项目</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/blog/about/" class="menu-link">关于</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>JavaSE基础</h2>
  <p class="post-date">2021-07-24</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>这是一份 JavaSE 语法入门指南</p>
<span id="more"></span>

<h1 id="第一部分-入门"><a href="#第一部分-入门" class="headerlink" title="第一部分 入门"></a>第一部分 入门</h1><h2 id="第二章-开发环境"><a href="#第二章-开发环境" class="headerlink" title="第二章 开发环境"></a>第二章 开发环境</h2><h3 id="2-1-Java虚拟机"><a href="#2-1-Java虚拟机" class="headerlink" title="2.1 Java虚拟机"></a>2.1 Java虚拟机</h3><ul>
<li>JVM：Java虚拟机。Java代码是运行在虚拟机上的。</li>
<li>跨平台：代码运行在虚拟机上，不同版的OS（linux，windows，mac）对应不同的虚拟机。虚拟机本身不具备跨平台功能，每个OS下都有不同版本的虚拟机。【可理解为，各个OS下的虚拟机都是采用一套编码指令集，JVM是面向操作系统的，它负责把Class字节码解释成系统所能识别的指令并执行，同时也负责程序运行时内存的管理】</li>
</ul>
<h3 id="2-2-JRE和JDK"><a href="#2-2-JRE和JDK" class="headerlink" title="2.2 JRE和JDK"></a>2.2 JRE和JDK</h3><ul>
<li>JRE (Java Runtime Environment):Java程序的运行时环境，包含JVM和运行时所需要的核心类库</li>
<li>JDK(Java Development Kit):是Java程序开发的工具包，包含JRE和开发人员使用的工具。</li>
<li>运行Java程序有jre就行，开发Java程序需要JDK。</li>
<li>Windows会把%CC% CC当作变量进行翻译</li>
</ul>
<h2 id="第三章-入门程序"><a href="#第三章-入门程序" class="headerlink" title="第三章 入门程序"></a>第三章 入门程序</h2><h3 id="3-1-程序开发步骤说明"><a href="#3-1-程序开发步骤说明" class="headerlink" title="3.1 程序开发步骤说明"></a>3.1 程序开发步骤说明</h3><ul>
<li>编写、编译、运行</li>
<li>Java源程序–&gt;Java字节码文件–&gt;JVM运行</li>
<li>Javac.exe 编译器 处理后 字节码</li>
<li>Java.exe 解释器 解释字节码的内容</li>
</ul>
<h2 id="第四章-常量"><a href="#第四章-常量" class="headerlink" title="第四章 常量"></a>第四章 常量</h2><ul>
<li>常量；在程序运行期间固定不变的量。</li>
<li>常量的分类<ul>
<li>字符串常量：凡是用双引号引起来的部分叫字符串常量。“asdfas”，可以是空串</li>
<li>整数常量：直接写上数字的，没有小数点。</li>
<li>浮点数常量：直接写上数字的，有小数点。</li>
<li>字符常量：用单引号引起来的 ‘A’，不能是空字符‘’。</li>
<li>布尔常量：只有量中取值。true，false</li>
<li>空常量：null，代表没有任何数据。不能直接用来打印。syso(null)是错的。</li>
</ul>
</li>
</ul>
<h2 id="第五章-变量-amp-数据类型"><a href="#第五章-变量-amp-数据类型" class="headerlink" title="第五章 变量&amp;数据类型"></a>第五章 变量&amp;数据类型</h2><h3 id="5-1-数据类型"><a href="#5-1-数据类型" class="headerlink" title="5.1 数据类型"></a>5.1 数据类型</h3><h4 id="5-1-1-基本数据类型"><a href="#5-1-1-基本数据类型" class="headerlink" title="5.1.1 基本数据类型"></a>5.1.1 基本数据类型</h4><ul>
<li>整数<ul>
<li>byte  1个字节</li>
<li>short 2个字节</li>
<li>int   4个字节</li>
<li>long  8个字节</li>
</ul>
</li>
<li>浮点数<ul>
<li>float     4个字节</li>
<li>double    8个字节</li>
</ul>
</li>
<li>字符型<ul>
<li>char      2个字节</li>
</ul>
</li>
<li>布尔型<ul>
<li>boolean   1个字节</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Java中默认类型：整型是int，浮点类型是double</strong><br>想要精确的数字不推荐用double，用BigDemical吧。</p>
</blockquote>
<h4 id="5-1-2-引用数据类型"><a href="#5-1-2-引用数据类型" class="headerlink" title="5.1.2 引用数据类型"></a>5.1.2 引用数据类型</h4><blockquote>
<p><strong>字符串，数组，类，接口，Lambda</strong></p>
</blockquote>
<p>注意事项：</p>
<ul>
<li>字符串不是基本数据类型</li>
<li>浮点数可能是一个近似值</li>
<li>数据范围与字节数不一定相关。如float数据范围比long更大，但float是4字节，long是8字节</li>
<li>浮点数默认是double，如果一定要用float，需要加上一个后缀F(推荐大写)</li>
<li>如果是整数，默认为int，如果一定要用long，需要加上一个后缀L(推荐大写)</li>
</ul>
<h3 id="5-2-变量"><a href="#5-2-变量" class="headerlink" title="5.2 变量"></a>5.2 变量</h3><ul>
<li>变量：程序运行期间，内容可以发生改变的量</li>
<li>编译原理，左值与右值</li>
</ul>
<h3 id="5-3-强制数据类型转换-▲"><a href="#5-3-强制数据类型转换-▲" class="headerlink" title="5.3 强制数据类型转换 ▲"></a>5.3 强制数据类型转换 ▲</h3><ul>
<li>强制类型转换一般不推荐使用，因为可能发生精度损失</li>
<li>byte，short，char这三种数据类型可发生数学运算。</li>
<li>byte，short，char在运算时都会被首先提升为int类型，然后再计算。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> num1 = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">byte</span> num2 = <span class="number">50</span>;</span><br><span class="line"><span class="comment">//byte + byte --&gt; int + int</span></span><br><span class="line"><span class="keyword">int</span> result = num1 + num2;</span><br><span class="line"><span class="comment">//如果用 byte接收 需要强转</span></span><br><span class="line"><span class="keyword">byte</span> result = (<span class="keyword">byte</span>)(num1 + num2);</span><br><span class="line"><span class="keyword">short</span>同理</span><br></pre></td></tr></table></figure>

<h3 id="5-4-ASCII码表"><a href="#5-4-ASCII码表" class="headerlink" title="5.4 ASCII码表"></a>5.4 ASCII码表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 -- 48</span><br><span class="line">A -- 65</span><br><span class="line">a -- 97</span><br></pre></td></tr></table></figure>

<h3 id="5-5-数字和字符的对照关系表（编码表）"><a href="#5-5-数字和字符的对照关系表（编码表）" class="headerlink" title="5.5 数字和字符的对照关系表（编码表）"></a>5.5 数字和字符的对照关系表（编码表）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ASCII码表：American Standard Code <span class="keyword">for</span> Information Interchange</span><br><span class="line">Unicode码表：万国码。也是数字和符号对照关系，开头<span class="number">0</span>-<span class="number">127</span>部分和ASCII完全一样，但是从<span class="number">128</span>开始包含更多字符。</span><br></pre></td></tr></table></figure>

<h2 id="第六章-常用运算"><a href="#第六章-常用运算" class="headerlink" title="第六章 常用运算"></a>第六章 常用运算</h2><ul>
<li><p>一元运算符：只需要一个数据就可以进行操作的运算符。</p>
<ul>
<li>取反</li>
<li>自增</li>
<li>etc</li>
</ul>
</li>
<li><p>二元运算符：需要两个数据才可以进行操作的运算符。</p>
<ul>
<li>加法</li>
<li>减法</li>
<li>赋值</li>
</ul>
</li>
<li><p>三元运算符：需要三个数据才可以进行的运算符。</p>
<ul>
<li>变量名称 = 条件判断?表达式A : 表达式B;</li>
<li>int max = a &gt; b ? a : b;</li>
</ul>
</li>
<li><p>拓展</p>
<ul>
<li>对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么java编译器会自动隐含地为我们补上一个(byte)(short)(char).</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">short = 5 + 8;(都要是常量才行)</span><br><span class="line">等同于</span><br><span class="line">short = 13;</span><br><span class="line">先计算出的结果在进行赋值的</span><br><span class="line">称为编译器的常量优化。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="第七章-基本语法"><a href="#第七章-基本语法" class="headerlink" title="第七章 基本语法"></a>第七章 基本语法</h2><h3 id="7-1-switch语句使用的注意事项"><a href="#7-1-switch语句使用的注意事项" class="headerlink" title="7.1 switch语句使用的注意事项"></a>7.1 switch语句使用的注意事项</h3><ul>
<li>多个case后面的数值不可以重复</li>
<li>switch后面小括号中只能是下列数据类型<ul>
<li>基本数据类型 byte/short/char/int</li>
<li>引用数据类型 String字符串、enum枚举</li>
</ul>
</li>
</ul>
<h3 id="7-2-循环概述"><a href="#7-2-循环概述" class="headerlink" title="7.2 循环概述"></a>7.2 循环概述</h3><ul>
<li>for循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( 一 ; 二 ; 四 )&#123;</span><br><span class="line">    三</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(初始化表达<span class="number">1</span> ; 布尔表达式<span class="number">2</span> ; 步进表达式<span class="number">4</span>)&#123;</span><br><span class="line">    循环体<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">流程 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> --&gt; <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> --&gt; <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> --&gt;直到<span class="number">2</span>不满足为止。</span><br><span class="line">初始化语句只会执行一次。</span><br></pre></td></tr></table></figure>

<ul>
<li>增强for循环 foreach</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">float</span> x : f)&#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">将每一个f的元素赋值给x</span><br></pre></td></tr></table></figure>

<h3 id="7-3-方法重载与重写"><a href="#7-3-方法重载与重写" class="headerlink" title="7.3 方法重载与重写"></a>7.3 方法重载与重写</h3><ul>
<li>方法调用的三种格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>单独调用：方法名称(参数)</span><br><span class="line"><span class="number">2.</span>打印调用：System.out.println(方法名称(参数))</span><br><span class="line"><span class="number">3.</span>赋值调用：数据类型 变量名称 = 方法名称(参数)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法重载 Overload ▲</p>
<ul>
<li>==方法重载== ：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。</li>
<li>参数列表：个数不同，数据类型不同，顺序不同。</li>
<li>重载方法调用：JVM通过方法的参数列表，调用不同的方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">以下参数顺序不一样也是重载！</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">short</span> b)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">short</span> b,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实际上，println就是一个被重载的函数</li>
</ul>
</li>
<li><p>方法重写 Overrider </p>
<ul>
<li>子类中出现和父类中一模一样的方法(包括返回值类型,方法名,参数列表）</li>
<li>1.重写的方法必须要和父类一模一样(包括返回值类型,方法名,参数列表)</li>
<li>2.重写的方法可以使用@Override注解来标识</li>
</ul>
</li>
</ul>
<h4 id="7-3-1-重载的注意事项▲"><a href="#7-3-1-重载的注意事项▲" class="headerlink" title="7.3.1 重载的注意事项▲"></a>7.3.1 重载的注意事项▲</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">short</span> i)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(short)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">byte</span> i)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(byte)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(int)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">short</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">byte</span> ii = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> iii = <span class="number">7</span>;</span><br><span class="line">    f1(<span class="number">1</span>);  <span class="comment">// f1(int)</span></span><br><span class="line">    f1(<span class="number">1</span>);	<span class="comment">// f1(int)</span></span><br><span class="line">    f1(<span class="number">1</span>);	<span class="comment">// f1(int)</span></span><br><span class="line">    System.out.println(<span class="string">&quot;==========华丽的分割线==========&quot;</span>);</span><br><span class="line">    f1(i);	<span class="comment">// f1(short)</span></span><br><span class="line">    f1(ii);	<span class="comment">// f1(byte)</span></span><br><span class="line">    f1(iii);<span class="comment">// f1(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-数组"><a href="#7-4-数组" class="headerlink" title="7.4 数组"></a>7.4 数组</h3><h4 id="7-4-1-数组得初始化"><a href="#7-4-1-数组得初始化" class="headerlink" title="7.4.1 数组得初始化"></a>7.4.1 数组得初始化</h4><ul>
<li>动态初始化 – 指定数组长度</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">300</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>静态初始化 – 指定数组内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int [] array = new int[]&#123;1,2,3,4,5,6&#125;; // 标准格式</span><br><span class="line">int [] array = &#123;1,2,3,4,5,6&#125;; // 省略格式</span><br><span class="line">静态初始化不能拆分成</span><br><span class="line">int [] array;</span><br><span class="line">array = &#123;1,2,34&#125;;</span><br><span class="line">这样是错误得</span><br></pre></td></tr></table></figure>

<ul>
<li>总结</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">动态初始化有默认值的过程，</span><br><span class="line">整型 默认为 0</span><br><span class="line">浮点 默认为 0.0</span><br><span class="line">字符 默认为 &#x27;\u0000&#x27;</span><br><span class="line">布尔 默认为 false</span><br><span class="line">引用 默认为 null</span><br><span class="line"></span><br><span class="line">静态初始化也有，不过系统自动马上将默认值替换为了大括号当中的具体数值。</span><br></pre></td></tr></table></figure>

<h4 id="7-4-2-数组作为参数，返回值"><a href="#7-4-2-数组作为参数，返回值" class="headerlink" title="7.4.2 数组作为参数，返回值"></a>7.4.2 数组作为参数，返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cals</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    xxxx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] calculate(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">int</span> [] array = &#123;a,b&#125;;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">数组作为参数，作为返回值其实都是数组的地址值</span><br></pre></td></tr></table></figure>

<h3 id="7-5-Java内存划分"><a href="#7-5-Java内存划分" class="headerlink" title="7.5 Java内存划分"></a>7.5 Java内存划分</h3><ul>
<li>1.栈（stack）：存放的都是方法中的局部变量。方法的运行一定要在栈中运行<ul>
<li>局部变量：方法的参数，或者方法{}内部的变量</li>
<li>作用域：一旦超出作用域，立刻从栈内存当中消失</li>
</ul>
</li>
<li>2.堆（heap）：凡是new出来的东西都在堆中<ul>
<li>堆里面的数据都有默认值。默认值同上</li>
</ul>
</li>
<li>3.方法区（method area）：存储.class相关信息，包含方法的信息。</li>
<li>4.本地方法栈（native method stack）：与操作系统相关</li>
<li>5.寄存器（register）：与CPU相关</li>
</ul>
<h3 id="7-6-常见异常"><a href="#7-6-常见异常" class="headerlink" title="7.6 常见异常"></a>7.6 常见异常</h3><blockquote>
<p>ArrayIndexOfBoundsException</p>
</blockquote>
<blockquote>
<p>NullPointException</p>
</blockquote>
<blockquote>
<p>OutOfMemmory</p>
</blockquote>
<h1 id="第二部分-基础"><a href="#第二部分-基础" class="headerlink" title="第二部分 基础"></a>第二部分 基础</h1><p>类的初始化过程？？</p>
<h2 id="第一章-面向对象概述"><a href="#第一章-面向对象概述" class="headerlink" title="第一章 面向对象概述"></a>第一章 面向对象概述</h2><p>类：描述相同事物的共同特征的抽象</p>
<p>对象：具体存在的实例，是真实地。 实例==对象。</p>
<p>代码层面，必须现有类，才能创建出对象。</p>
<p>定义类的格式：</p>
<p>五大成分（自己总结的！！）如果不是五大成分，那么他就不是正确的。</p>
<p>修饰符 class 类名{</p>
<p>​    //1.成员变量（Field 描述类和对象的属性信息）</p>
<p>​    //2.成员方法（Method：描述类或者对象的行为信息）</p>
<p>​    //3.构造器（Constructor：初始化一个类的对象并返回引用）</p>
<p>​    //4.代码块</p>
<p>​    //5.内部类</p>
<p>}</p>
<p>构造器的复习：</p>
<p>​    作用：初始化一个类的对象并返回。</p>
<p>​    格式：</p>
<p>​        修饰符 类名（形参）{</p>
<p>​        }</p>
<p>​    构造器初始化对象的格式</p>
<p>​    类名 对象名称 = new 构造器()</p>
<hr>
<p>this关键字的作用：</p>
<p>​    this代表当前对象的引用</p>
<p>​    this关键字可以用在实例方法和构造器中</p>
<p>​    this用在方法中，谁调用这个方法，this就代表谁。</p>
<p>​    this用在构造器，代表构造器正在初始化那个对象的引用</p>
<p>插件一键生成无参 有参 toString</p>
<hr>
<p>封装的作用：</p>
<p>​    1.可以提高安全性</p>
<p>​    2.可以实现代码组件化</p>
<p>封装的规范：</p>
<p>​    1.建议成员变量都私有</p>
<p>​    2.提供成套的getter+setter方法暴露成员变量的取值和赋值</p>
<p><code>小结：</code>封装的核心思想，，合理隐藏，合理暴露。</p>
<hr>
<p>static关键字（重点）</p>
<p>Java通过成员变量是否有static修饰来区分是类的还是属于对象的。</p>
<p>static == 静态 == 修饰的成员（方法和成员变量）属于类本身。</p>
<p>有static，静态成员变量：属于类本身。</p>
<p>无static，实例成员变量：属于每个实例对象，必须用类的对象来访问。</p>
<p>成员方法也类似：</p>
<p>1、静态方法</p>
<p>2、实例方法</p>
<p>static修饰，属于类本身，与类加载一次，因为只有一份所以可以被类和类的对象共享。</p>
<hr>
<p>成员变量的分类和访问内存图</p>
<p><img src="D:/note/JavaEE-Study/pics/JavaStrengthen/image-20210421212413778.png" alt="image-20210421212413778"></p>
<h3 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h3><ul>
<li><strong>依赖（user-a）</strong>：一个类使用了另一个类的方法，A调用了B的方法，B出bug了，A也可能出bug，软件工程中称之为耦合。</li>
<li><strong>聚合（has-a）</strong>：一个对象将一个或者多个其它对象作为自己的成员</li>
<li><strong>继承（is-a）</strong>：</li>
</ul>
<h3 id="1-1-面向对象"><a href="#1-1-面向对象" class="headerlink" title="1.1 面向对象"></a>1.1 面向对象</h3><blockquote>
<p>当需要实现一个功能时，不关心具体的步骤，而是找一个已经具有该功能的人，来替我们做事。</p>
</blockquote>
<blockquote>
<p>什么叫面向对象：把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式【来自百度】</p>
</blockquote>
<blockquote>
<p>面向对象的基本特征：继承，封装，多态</p>
</blockquote>
<h3 id="1-2-类和对象"><a href="#1-2-类和对象" class="headerlink" title="1.2 类和对象"></a>1.2 类和对象</h3><ul>
<li>类：是一组相关 <u><em>属性和行为的集合</em></u> 。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该 类事物。现实中，描述一类事物：<ul>
<li>属性：就是该事物的状态信息。 </li>
<li>行为：就是该事物能够做什么。</li>
<li>举例：小猫。</li>
<li>属性：名字、体重、年龄、颜色。  </li>
<li>行为：走、跑、叫。</li>
</ul>
</li>
<li><strong>什么是对象</strong> <ul>
<li>对象：是一类事物的具体体现。对象是类的一个实例（对象并不是找个女朋友），必然具备该类事物的属性 和行为。</li>
<li>现实中，一类事物的一个实例：一只小猫。</li>
<li>属性：tom、5kg、2 years、yellow。   </li>
<li>行为：溜墙根走、蹦跶的跑、喵喵叫。 </li>
</ul>
</li>
</ul>
<blockquote>
<p>类与对象的关系 ：类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的。 类是对象的模板，对象是类的实体。</p>
</blockquote>
<h3 id="1-3-一个对象的内存图"><a href="#1-3-一个对象的内存图" class="headerlink" title="1.3 一个对象的内存图"></a>1.3 一个对象的内存图</h3><p>方法区中存放class信息。<br>class中的成员方法一直在方法区中。<br>堆中拿到成员方法的地址，通过地址对方法进行调用【回忆组成原理】。<br>堆将方法区中的成员变量拿到堆中（相当于copy一份），对其进行初始化值得操作。【不同对象的成员变量是独立的（非静态成员变量）】<br>main方法中得变量指向堆中的对象，并对对象进行赋值操作。<br>stack–栈，FIFO</p>
<h3 id="1-4-成员变量和局部变量"><a href="#1-4-成员变量和局部变量" class="headerlink" title="1.4 成员变量和局部变量"></a>1.4 成员变量和局部变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">局部变量和成员变量</span></span><br><span class="line"><span class="comment">1. 定义的位置不一样【重点】</span></span><br><span class="line"><span class="comment">局部变量：在方法的内部</span></span><br><span class="line"><span class="comment">成员变量：在方法的外部，直接写在类当中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 作用范围不一样【重点】</span></span><br><span class="line"><span class="comment">局部变量：只有方法当中才可以使用，出了方法就不能再用</span></span><br><span class="line"><span class="comment">成员变量：整个类全都可以通用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 默认值不一样【重点】</span></span><br><span class="line"><span class="comment">局部变量：没有默认值，如果要想使用，必须手动进行赋值</span></span><br><span class="line"><span class="comment">成员变量：如果没有赋值，会有默认值，规则和数组一样</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 内存的位置不一样（了解）</span></span><br><span class="line"><span class="comment">局部变量：位于栈内存</span></span><br><span class="line"><span class="comment">成员变量：位于堆内存</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5. 生命周期不一样（了解）[通常是这样，但是不绝对]</span></span><br><span class="line"><span class="comment">局部变量：随着方法进栈而诞生，随着方法出栈而消失</span></span><br><span class="line"><span class="comment">成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01VariableDifference</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    String name; <span class="comment">// 成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>; <span class="comment">// 局部变量</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">(<span class="keyword">int</span> param)</span> </span>&#123; <span class="comment">// 方法的参数就是局部变量</span></span><br><span class="line">        <span class="comment">// 参数在方法调用的时候，必然会被赋值的。</span></span><br><span class="line">        System.out.println(param);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> age; <span class="comment">// 局部变量</span></span><br><span class="line">        System.out.println(age); <span class="comment">// 没赋值不能用</span></span><br><span class="line"></span><br><span class="line">        System.out.println(num); <span class="comment">// 错误写法！</span></span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-访问修饰符"><a href="#1-5-访问修饰符" class="headerlink" title="1.5 访问修饰符"></a>1.5 访问修饰符</h3><blockquote>
<p><strong>private/protect/public/默认访问</strong></p>
</blockquote>
<h4 id="1-5-1-private访问属性"><a href="#1-5-1-private访问属性" class="headerlink" title="1.5.1 private访问属性"></a>1.5.1 private访问属性</h4><blockquote>
<p><strong>只有本类中可以随意访问，其他类都不行。</strong></p>
</blockquote>
<h3 id="1-6-this关键字"><a href="#1-6-this关键字" class="headerlink" title="1.6 this关键字"></a>1.6 this关键字</h3><h4 id="1-6-1-this关键字的一些概念"><a href="#1-6-1-this关键字的一些概念" class="headerlink" title="1.6.1 this关键字的一些概念"></a>1.6.1 this关键字的一些概念</h4><blockquote>
<p><strong>通过谁调用的方法谁就是this。</strong></p>
</blockquote>
<blockquote>
<p><strong>this只能在方法内部使用，且不能在静态方法中使用。为什么？看JVM。</strong></p>
</blockquote>
<blockquote>
<p><strong>类加载机制！静态的使用不必对类进行实例化。this指的是当前对象的引用。</strong></p>
</blockquote>
<h4 id="1-6-2-this关键字的一些作用"><a href="#1-6-2-this关键字的一些作用" class="headerlink" title="1.6.2 this关键字的一些作用"></a>1.6.2 this关键字的一些作用</h4><ul>
<li>在构造器中调用构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flower</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Flower</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.price = price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Flower</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(<span class="number">12</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PS:</span><br><span class="line"><span class="keyword">this</span>只能调用一个构造器</span><br><span class="line"><span class="keyword">this</span>调用的构造器要放在最前面    </span><br></pre></td></tr></table></figure>

<h3 id="1-6-匿名对象"><a href="#1-6-匿名对象" class="headerlink" title="1.6 匿名对象"></a>1.6 匿名对象</h3><h2 id="第二章-API"><a href="#第二章-API" class="headerlink" title="第二章 API"></a>第二章 API</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>API(Application Programming Interface)</code>，应用程序编程接口。</p>
<h3 id="API使用步骤"><a href="#API使用步骤" class="headerlink" title="API使用步骤"></a><code>API</code>使用步骤</h3><ul>
<li>1.打开帮助文档。</li>
<li>2.点击显示，找到索引，看到输入框。</li>
<li>3.你要找谁？在输入框里输入，然后回车。</li>
<li>4.看包。java.lang下的类不需要导包，其他需要。</li>
<li>5.看类的解释和说明。</li>
<li>6.学习构造方法。</li>
</ul>
<h2 id="第三章-字符串"><a href="#第三章-字符串" class="headerlink" title="第三章 字符串"></a>第三章 字符串</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><blockquote>
<p><strong>字符串：程序中凡是所有的双引号字符串都是String类的对象【就算没有new，也照样是】</strong></p>
</blockquote>
<h4 id="3-1-1-字符串的特点"><a href="#3-1-1-字符串的特点" class="headerlink" title="3.1.1 字符串的特点"></a>3.1.1 字符串的特点</h4><ul>
<li>字符串的内容永不可变。【常量池？】</li>
<li>因字符串不可变，故字符串可共享使用【不可变，不会出现线程安全问题】</li>
<li>字符串效果相当于char[]字符数组，但底层原理是byte[]字节数组</li>
<li>String str = “Hello” 也是字符串对象</li>
</ul>
<h4 id="3-1-2-字符串常量池"><a href="#3-1-2-字符串常量池" class="headerlink" title="3.1.2 字符串常量池"></a>3.1.2 字符串常量池</h4><blockquote>
<p><strong>字符串常量池</strong>：程序中直接写上双引号的字符串，就在字符串常量池中。从jdk1.7开始，字符串常量在堆中。【方便gc嘛？】</p>
</blockquote>
<blockquote>
<p>对于基本类型来说， == 是进行数值比较</p>
</blockquote>
<blockquote>
<p>对应用类型来说，==是进行【地址值】的比较</p>
</blockquote>
<p>就算不new 字符串直接双引号也是一个对象。故String str1 是一个对象。</p>
<p>字符串常量池中的对象保持的其实是byte数组的地址值。</p>
<p>而直接new出来的，是不在常量池中的。【具体过程看图。用new String(char型数组)有一个中转过程】<br>    char[] –&gt; byte[] –&gt; 字符串对象<br>    字符串对象再指向byte数组</p>
<p><strong>总结：双引号直接写的在常量池中，new的不在池中。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] charArray = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">    String str3 = <span class="keyword">new</span> String(charArray);</span><br><span class="line"></span><br><span class="line">    System.out.println(str1 == str2);<span class="comment">// true</span></span><br><span class="line">    System.out.println(str1 == str3);<span class="comment">// false</span></span><br><span class="line">    System.out.println(str2 == str3);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    String str4 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    String str5 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    System.out.println(str1 == str4); <span class="comment">// false</span></span><br><span class="line">    System.out.println(str4 == str5); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-字符串常用API"><a href="#3-2-字符串常用API" class="headerlink" title="3.2 字符串常用API"></a>3.2 字符串常用API</h3><h4 id="3-2-1-字符串的比较▲"><a href="#3-2-1-字符串的比较▲" class="headerlink" title="3.2.1 字符串的比较▲"></a>3.2.1 字符串的比较▲</h4><blockquote>
<p><strong>== 是进行对象的地址值比较。如果确实需要比较字符串的内容，可以使用如下的方法</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testEqual</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str1 = <span class="keyword">new</span> String(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">    String str2 = <span class="keyword">new</span> String(<span class="string">&quot;11&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String str3 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">    System.out.println(str1.equals(str2)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(str1.equals(str3)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(str1.equals(<span class="string">&quot;11&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String 对equals进行了重写！</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意事项</strong></p>
</blockquote>
<ul>
<li>如果比较双方一个常量一个变量，推荐把常量写在前面。【避免NullPointerException】</li>
<li><strong>equalsIgnoreCase</strong>忽略大小写进行比较。</li>
</ul>
<h4 id="3-2-2-字符串获取相关方法"><a href="#3-2-2-字符串获取相关方法" class="headerlink" title="3.2.2 字符串获取相关方法"></a>3.2.2 字符串获取相关方法</h4><ul>
<li>```java<ul>
<li>length</li>
<li>concat(String str) 拼接会产生新的字符串</li>
<li>charAt(int index)</li>
<li>indexOf(String str) 查找首次出现的位置，没有返回-1</li>
</ul>
public static void testGetStr(){<pre><code>String str1 = &quot;abc&quot;;
String str2 = &quot;df&quot;;
System.out.println(str1.length()); // 3
System.out.println(str1.charAt(0)); // a
System.out.println(str1.concat(str2)); // abcdf
System.out.println(str1.indexOf(&quot;ab&quot;)); // 0
System.out.println(str2.indexOf(&#39;d&#39;)); // 0
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- concat的测试▲</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public void testConcat()&#123;</span><br><span class="line">      String str1 = &quot;abc&quot;;</span><br><span class="line">      String str2 = &quot;df&quot;;</span><br><span class="line">      String concat = str1.concat(str2);</span><br><span class="line">      String concat2 = &quot;abcdf&quot;;</span><br><span class="line">      String concat3 = &quot;abcdf&quot;;</span><br><span class="line">      System.out.println(concat == concat2); // false</span><br><span class="line">      System.out.println(concat2 == concat3);// true</span><br><span class="line">  &#125;</span><br><span class="line">  concat内部返回的字符串是使用的new。故会有上述结果！</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-2-3-字符串截取、转换、分割"><a href="#3-2-3-字符串截取、转换、分割" class="headerlink" title="3.2.3 字符串截取、转换、分割"></a>3.2.3 字符串截取、转换、分割</h4><blockquote>
<p><strong>截取指定索引的数据</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSubstring</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str1 = <span class="string">&quot;abcefghig&quot;</span>;</span><br><span class="line">	<span class="comment">// beginIndex</span></span><br><span class="line">    System.out.println(str1.substring(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// beginIndex, endIndex 左闭右开</span></span><br><span class="line">    System.out.println(str1.substring(<span class="number">1</span>,str1.length()));</span><br><span class="line">    <span class="comment">// false</span></span><br><span class="line">    System.out.println(str1.substring(<span class="number">1</span>) == str1.substring(<span class="number">1</span>,str1.length()));</span><br><span class="line">&#125;</span><br><span class="line">查看源码可知 返回的是<span class="keyword">new</span> String</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>字符串转换字符数组，字节数组</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConvert</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray(); <span class="comment">// 转化为字符数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = str.getBytes(); <span class="comment">// 转化为字节数组</span></span><br><span class="line">    String replace = str.replace(<span class="string">&quot;o&quot;</span>, <span class="string">&quot;liu&quot;</span>); <span class="comment">// 把所有的o替换成liu</span></span><br><span class="line">    System.out.println(replace); <span class="comment">//hellliu wliurld</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>分割</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;aa,bb,cc&quot;</span>;</span><br><span class="line">    String[] split = str.split(<span class="string">&quot;,&quot;</span>); <span class="comment">// 里面是正则表达式</span></span><br><span class="line">    <span class="keyword">for</span> (String s : split ) &#123;</span><br><span class="line">        System.out.println(s);<span class="comment">// aa bb cc</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplit2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;aa.b.cc&quot;</span>;</span><br><span class="line">    String[] split = str.split(<span class="string">&quot;\\.&quot;</span>); <span class="comment">//用.作为划分</span></span><br><span class="line">    <span class="keyword">for</span> (String s : split ) &#123;</span><br><span class="line">        System.out.println(s);<span class="comment">// aa bb cc</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第四章-静态关键字"><a href="#第四章-静态关键字" class="headerlink" title="第四章 静态关键字"></a>第四章 静态关键字</h2><blockquote>
<p><strong>可实现数据共享。static修饰的内容不再属于对象自己，而是属于类的，所以凡是本类的对象，都共享同一份。</strong></p>
</blockquote>
<h3 id="4-1-静态概述"><a href="#4-1-静态概述" class="headerlink" title="4.1 静态概述"></a>4.1 静态概述</h3><ul>
<li><p>static修饰的成员方法是静态方法，静态方法不属于对象，而是属于类。</p>
</li>
<li><p>PS： 静态不能直接访问非静态。</p>
<ul>
<li>因为内存中是【先】有静态内容，【后】有非静态内容</li>
</ul>
</li>
<li><p>PS：静态中不能使用this。</p>
<ul>
<li><p>因为this代表当前对象，通过谁调用的方法就是当前对象。但是静态与对象无关。静态是【类名称.静态方法】</p>
</li>
<li><p>```java<br>new Object().staticMethod(); 最终会翻译成ClassName.staticMethod();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 4.1 静态代码块</span><br><span class="line"></span><br><span class="line">&gt; 格式</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class ClassName&#123;</span><br><span class="line">	static&#123;</span><br><span class="line">		静态代码块执行。</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 特点：当第一次用到本类时，静态代码块执行唯一的一次【静态代码块只执行一次】</span><br><span class="line">// 用到类就行。就是只是类名称.staticMethod()调用也是用到了类，static会被执行。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="4-1-1-静态代码块的注意事项"><a href="#4-1-1-静态代码块的注意事项" class="headerlink" title="4.1.1 静态代码块的注意事项"></a>4.1.1 静态代码块的注意事项</h4><ul>
<li>静态代码块的执行顺序与定义的顺序有关。先定义的先执行。</li>
<li>静态代码块的执行顺序优于静态方法，构造方法！【先有静态，再有堆中的对象。静态总是优于非静态。】</li>
</ul>
<h4 id="4-1-2-静态工具类Arrays"><a href="#4-1-2-静态工具类Arrays" class="headerlink" title="4.1.2 静态工具类Arrays"></a>4.1.2 静态工具类Arrays</h4><blockquote>
<p>常用方法如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Integer []array = &#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    String str = Arrays.toString(array); <span class="comment">// 转成String 可以是基本类型 如int</span></span><br><span class="line">    Arrays.sort(array); <span class="comment">// 排序 ascending 升序 可以是基本类型 如int</span></span><br><span class="line">    Arrays.sort(array, Collections.reverseOrder()); <span class="comment">// 反转，变成了降序。注意这个方法要用引用类型</span></span><br><span class="line">    System.out.println(array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>自定义类型的排序，那么这个定义的类需要有<strong>Comparable或者Comparator接口支持</strong>。</p>
</li>
<li><p><span style="color:red">拓展看下Comparable和Comparator的区别和应用</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 挖坑</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-1-3-静态工具类Math"><a href="#4-1-3-静态工具类Math" class="headerlink" title="4.1.3 静态工具类Math"></a>4.1.3 静态工具类Math</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> abs = Math.abs(-<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">double</span> ceil = Math.ceil(<span class="number">12.3</span>); <span class="comment">// 向上取整 13</span></span><br><span class="line">    <span class="keyword">double</span> floor = Math.floor(<span class="number">12.4</span>); <span class="comment">// 向下取整 12</span></span><br><span class="line">    <span class="keyword">long</span> round = Math.round(<span class="number">12.6</span>); <span class="comment">// 13 四舍五入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第五章-继承"><a href="#第五章-继承" class="headerlink" title="第五章 继承"></a>第五章 继承</h2><blockquote>
<p>继承是多态的前提，没有继承就没有多态！</p>
</blockquote>
<blockquote>
<p>继承主要解决的问题是：<strong>共性抽取</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">父类也称为基类、超类</span><br><span class="line">子类也称为：派生类</span><br><span class="line">在继承关系中：“子类就是一个父类”。也就是说，子类可以被当成父类看待</span><br><span class="line">例如父类是员工，子类是讲师，那么讲师就是一个员工。 关系 is-a。</span><br><span class="line">父类是抽象的，子类是具体的。</span><br></pre></td></tr></table></figure>

<p>被继承的类：父类/超类</p>
<p>继承父类的类：子类</p>
<p>继承的作用？</p>
<ul>
<li>提高代码复用</li>
<li>功能增强</li>
</ul>
<p>继承的特点：</p>
<ul>
<li>子类继承了一个父类，子类可以直机得到父类的属性和方法。（私有的好像无法得到？）</li>
</ul>
<hr>
<p>继承是 is a</p>
<p>组合是 hava a</p>
<hr>
<p><img src="D:/note/JavaEE-Study/pics/JavaStrengthen/oop_extend_lianxi.png" alt="image-20210422125216087"></p>
<hr>
<p><code>继承后子类不能继承的成员★★</code></p>
<p>引入：</p>
<p>​    子类继承父类，子类就得到了父类的属性和行为</p>
<p>​    但是并非所有的父类的属性和行为等子类都可继承</p>
<p>子类不能继承父类的东西</p>
<p>​    【无争议的观点】子类不能继承父类的构造器</p>
<p>​    【有争议的观点】子类能否继承父类的私有成员？</p>
<p>​    【有争议的观点】子类能否继承父类的静态成员？</p>
<h3 id="5-1-继承中成员变量的访问特点"><a href="#5-1-继承中成员变量的访问特点" class="headerlink" title="5.1 继承中成员变量的访问特点"></a>5.1 继承中成员变量的访问特点</h3><blockquote>
<p>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoExtends</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//运行时看左边。这里就是看Fu类。没有就一级一级向上找。</span></span><br><span class="line">        Fu de = <span class="keyword">new</span> DemoExtends();</span><br><span class="line">        System.out.println(de.a); <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>区分子类方法中重名的三种变量</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">局部变量 直接写</span><br><span class="line">本类的成员变量 <span class="keyword">this</span>.变量名</span><br><span class="line">父类的成员变量 <span class="keyword">super</span>.成员变量</span><br></pre></td></tr></table></figure>

<h3 id="5-2-重写和重载"><a href="#5-2-重写和重载" class="headerlink" title="5.2 重写和重载"></a>5.2 重写和重载</h3><ul>
<li>重写：在继承关系中，<strong>方法名称一样，参数列表【也一样】</strong>。覆盖、覆写 === 【没说返回值！】</li>
<li>重载：方法名称一样，参数列表【不一样】</li>
</ul>
<blockquote>
<p><strong>方法覆盖重写的特点</strong>：创建的是子类对象，则优先用子类方法</p>
</blockquote>
<ul>
<li><p>方法覆盖重写的注意事项</p>
<ul>
<li><p>1，必须保证父子类之间方法名相同，参数列表也相同</p>
</li>
<li><p>2，子类方法的返回值必须【小于等于】父类方法的返回值范围。</p>
</li>
<li><p>简而言之，参数必须要一样，且返回类型必须要兼容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类的返回类型小于等于父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为什么？ 是因为向上转型安全，向下转型不安全吗？ 百度的，不确定!</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>不管父类使用了那种参数，覆盖此方法的子类也一定要使用相同的参数。而不论父类声明的返回类型是声明，<strong>子类必须要声明返回一样的类型或该类型的子类</strong>。要记得，子类对象得保证能够执行父类得一切。</p>
</li>
<li><p>3，子类方法的权限必须【大于等于】父类方法的权限修饰符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &gt; <span class="keyword">protected</span> &gt; (<span class="keyword">default</span>) &gt; <span class="keyword">private</span></span><br><span class="line">PS : (<span class="keyword">default</span>)不是关键字<span class="keyword">default</span>，而是什么都不写，留空！</span><br></pre></td></tr></table></figure></li>
<li><p>方法重写的应用场景</p>
<ul>
<li><p><strong>设计原则</strong>：</p>
<blockquote>
<p>对于已经投入使用的类，尽量不要进行修改。推荐定义一个新的类，来重复利用其中共性内容，并且添加改动新内容。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="5-3-继承中构造方法的访问特点"><a href="#5-3-继承中构造方法的访问特点" class="headerlink" title="5.3 继承中构造方法的访问特点"></a>5.3 继承中构造方法的访问特点</h3><p>子类构造方法中默认隐含有一个super()调用，所以一定是先调用父类构造</p>
<p>只有<strong>子类构造方法才能调用父类构造方法</strong>且只能调用一个构造方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是错误的，因为只能调用一个父类的构造。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">super</span>();</span><br><span class="line">	<span class="keyword">super</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用普通方法没问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.method();</span><br><span class="line">    <span class="keyword">super</span>.qq();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this调用构造也是只能调用一个，不能循环调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Zi(int x)&#123;</span><br><span class="line">    this();</span><br><span class="line">    System.out.println(&quot;int x&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this不能循环调用【循环引用？Spring循环依赖？】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样是错误的！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;我是无参&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;int x&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>super和this不能同时显式调用.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错 因为 super or this都需要放在第一行！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;我是无参&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没问题， 父类的构造也是会执行的。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;我是无参&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-继承中-this和super的内存图"><a href="#5-4-继承中-this和super的内存图" class="headerlink" title="5.4 继承中 this和super的内存图"></a>5.4 继承中 this和super的内存图</h3><h2 id="第六章-抽象"><a href="#第六章-抽象" class="headerlink" title="第六章 抽象"></a>第六章 抽象</h2><blockquote>
<p><strong>若父类中的方法不能确定如何进行{}方法体实现，那么这就应该是一个抽象方法。</strong></p>
</blockquote>
<h3 id="6-1-抽象概述"><a href="#6-1-抽象概述" class="headerlink" title="6.1 抽象概述"></a>6.1 抽象概述</h3><ul>
<li>抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束</li>
<li>抽象类：抽象方法所在的类，必须是抽象类才行！在class之前写上abstract即可</li>
<li>default关键字</li>
</ul>
<h3 id="6-2-如何使用抽象类和抽象方法"><a href="#6-2-如何使用抽象类和抽象方法" class="headerlink" title="6.2 如何使用抽象类和抽象方法"></a>6.2 如何使用抽象类和抽象方法</h3><ul>
<li><p>不能直接创建new抽象类对象。</p>
</li>
<li><p>必须用一个子类来继承抽象父类。</p>
</li>
<li><p><strong>子类必须覆盖重写抽象父类当中所有的抽象方法。</strong></p>
<ul>
<li>子类重写时，去掉抽象方法的abstract关键字，然后补上方法体。</li>
</ul>
</li>
<li><p>创建子类对象进行使用。</p>
</li>
<li><p><strong>PS：Please attention</strong></p>
<ul>
<li><p>抽象类可以自己写构造函数</p>
</li>
<li><p>如果抽象类只有 有参构造，那么子类的构造函数一定要显示调用这个有参构造！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;:walk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Cat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>抽象类可以实例化，但是不能直接实例化。只能在子类被实例化的过程中，间接实例化。因为实例化子类的时候抽象类也会被实例化。【用的是extends关键字。父类的super会被隐式调用】</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/95406830">建议看这篇博文</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="第七章-接口"><a href="#第七章-接口" class="headerlink" title="第七章 接口"></a>第七章 接口</h2><blockquote>
<p><strong>一种公共的规范标准。【定义规范】【多个类的公共规范】</strong></p>
</blockquote>
<blockquote>
<p><strong>结构是一种引用数据类型，最重要的内容就是其中的：抽象方法</strong></p>
</blockquote>
<blockquote>
<p>接口中定义的方法<strong>默认使用public abstract修饰</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Name</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意！Notice!</strong></p>
</blockquote>
<ul>
<li>如果是<strong>Java 7</strong>那么接口中可以包含有<ul>
<li>常量</li>
<li>抽象方法</li>
</ul>
</li>
<li>如果是<strong>Java 8</strong>还可以额外包含有<ul>
<li>默认方法 public default 返回值类型 方法名称( 参数列表 ){  方法体 }</li>
<li>静态方法</li>
</ul>
</li>
<li>如果是<strong>Java 9</strong>还可以额外包含有<ul>
<li>私有方法</li>
</ul>
</li>
</ul>
<h3 id="7-1-代码示例"><a href="#7-1-代码示例" class="headerlink" title="7.1 代码示例"></a>7.1 代码示例</h3><blockquote>
<p>在任何版本的Java中，接口都能定义抽象方法。<br>格式：public abstract 返回值类型 方法名称(参数列表);</p>
</blockquote>
<ul>
<li>注意事项：<ul>
<li>接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract</li>
<li>这两个关键字修饰符，可以选择性地省略。（今天刚学，所以不推荐。）</li>
<li>方法的三要素，可以随意定义。</li>
<li><strong>如果接口的实现类没有覆盖重写接口中所有的抽象方法，那么这个类必须是抽象类！</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这也是抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这也是抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这也是抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodAbs4</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>Java 8开始，接口中允许定义默认方法【<strong>接口当中的默认方法，可以解决接口升级问题。</strong>】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口当中的默认方法，可以解决接口升级问题。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">	syso(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体解释：接口中的default可以不用被重写。如果我们要扩充接口，但是又不想更改其他已经实现接口的类，可采用default。</span></span><br></pre></td></tr></table></figure>

<p>Java 8开始，接口中允许定义静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可直接通过【接口名.staticMethod】调用！且只能用接口名调用！不能用实现类调用！</span><br></pre></td></tr></table></figure>

<p><strong>Java 9开始</strong>，接口中允许定义私有方法</p>
<p>普通私有方法，解决多个默认方法之间重复代码问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态私有方法，解决多个静态方法之间重复代码问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口中可定义常量,且可省略public static final，默认就是他！</strong>【接口中的常量必须赋值！因为有final修饰！】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">接口名.num调用！</span><br></pre></td></tr></table></figure>

<h3 id="7-2-总结"><a href="#7-2-总结" class="headerlink" title="7.2 总结"></a>7.2 总结</h3><blockquote>
<p><strong>在Java 9+版本中，接口的内容可以有：</strong></p>
</blockquote>
<ol>
<li><ul>
<li>成员变量其实是常量，格式：<br>[public] [static] [final] 数据类型 常量名称 = 数据值;<br> 注意：<br>常量必须进行赋值，而且一旦赋值不能改变。<br>常量名称完全大写，用下划线进行分隔。</li>
</ul>
</li>
<li><ul>
<li>接口中最重要的就是抽象方法，格式：<br>[public] [abstract] 返回值类型 方法名称(参数列表);<br> 注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。</li>
</ul>
</li>
<li><ul>
<li>从Java 8开始，接口里允许定义默认方法，格式：<br>[public] default 返回值类型 方法名称(参数列表) { 方法体 }<br> 注意：默认方法也可以被覆盖重写</li>
</ul>
</li>
<li><ul>
<li>从Java 8开始，接口里允许定义静态方法，格式：<br>[public] static 返回值类型 方法名称(参数列表) { 方法体 }<br> 注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法</li>
</ul>
</li>
<li><ul>
<li>从Java 9开始，接口里允许定义私有很乏，格式：<br>普通私有方法：private 返回值类型 方法名称(参数列表) { 方法体 }<br> 静态私有方法：private static 返回值类型 方法名称(参数列表) { 方法体 }<br> 注意：private的方法只有接口自己才能调用，不能被实现类或别人使用。</li>
</ul>
</li>
</ol>
<h3 id="7-3-接口的注意事项"><a href="#7-3-接口的注意事项" class="headerlink" title="7.3 接口的注意事项"></a>7.3 接口的注意事项</h3><ul>
<li>接口中不能有构造方法，不能有静态代码块</li>
<li>一个类的直接父类只有一个，但是可同时实现多个接口</li>
<li><strong>如果实现类所实现的多个接口中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</strong></li>
<li><strong>一个类如果直接父类当中的方法和接口中的默认方法产生了冲突，优先用父类当中的方法！</strong></li>
</ul>
<h2 id="第八章-多态"><a href="#第八章-多态" class="headerlink" title="第八章 多态"></a>第八章 多态</h2><blockquote>
<p><strong>extends继承或implements实现是多态性的前提！</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">多态写法，父类引用指向子类对象</span><br><span class="line">Fu obj = <span class="keyword">new</span> Zi();</span><br><span class="line">obj.method();</span><br><span class="line">obj.methodFu();</span><br></pre></td></tr></table></figure>

<h3 id="8-1-访问成员变量的两种方式"><a href="#8-1-访问成员变量的两种方式" class="headerlink" title="8.1 访问成员变量的两种方式"></a>8.1 访问成员变量的两种方式</h3><ul>
<li>直接通过对象名称访问成员变量：看等号左边是谁，优先使用谁，没有则向上找</li>
<li>间接通过成员方法访问</li>
<li>老毕在讲到多态执行问题时，结合下面的例子，给我们总结了一套口诀：“成员变量，静态方法看左边；非静态方法：编译看左边，运行看右边。”意思是：当父类变量引用子类对象时（Fu f = new Zi();），在这个引用变量f指向的对象中，他的成员变量和静态方法与父类是一致的，他的非静态方法，在编译时是与父类一致的，运行时却与子类一致（发生了复写）。</li>
<li>简而言之<ul>
<li><strong>成员变量：编译看左边，运行还看左边</strong></li>
<li><strong>成员方法：编译看左边，运行看右边</strong></li>
</ul>
</li>
</ul>
<h3 id="8-2-多态的好处"><a href="#8-2-多态的好处" class="headerlink" title="8.2 多态的好处"></a>8.2 多态的好处</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Employee one = <span class="keyword">new</span> Teacher();</span><br><span class="line">Employee two = <span class="keyword">new</span> Assistant();</span><br></pre></td></tr></table></figure>

<p><strong>无论右边new的时候换成那个子类对象，等号左边调用方法都不会变化！</strong></p>
<h3 id="8-3-对象的向上、下转型"><a href="#8-3-对象的向上、下转型" class="headerlink" title="8.3 对象的向上、下转型"></a>8.3 对象的向上、下转型</h3><ul>
<li><p>向上转型一定是安全的，没有问题的，正确的。弊端在于，对象一旦向上转型为父类，就无法调用子类原本持有的内容。</p>
</li>
<li><p>向下转型是不安全的，使用时一定要保证他本来是猫才能向下转型变成猫</p>
</li>
<li><p>instanceof进行类型判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( animal <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">	syso(<span class="string">&quot;是狗&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">一般先判断是否是该类，是才进行向下转型！</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="第九章-final"><a href="#第九章-final" class="headerlink" title="第九章 final"></a>第九章 final</h2><h3 id="9-1-final修饰类"><a href="#9-1-final修饰类" class="headerlink" title="9.1 final修饰类"></a>9.1 final修饰类</h3><p>final修饰的类是没有子孙的，但是有父亲（太监类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法被继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-final修饰方法"><a href="#9-2-final修饰方法" class="headerlink" title="9.2 final修饰方法"></a>9.2 final修饰方法</h3><p>final修饰的方法是最终方法，不能覆盖重写（override）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void method()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：对于类和方法来说，abstract关键字和final关键字不能被同时使用，因为矛盾。</p>
<ul>
<li>因为子类是一定要覆盖重写抽象方法的！</li>
</ul>
<h3 id="9-3-final修饰局部变量"><a href="#9-3-final修饰局部变量" class="headerlink" title="9.3 final修饰局部变量"></a>9.3 final修饰局部变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">3</span>; <span class="comment">// 可以</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num;</span><br><span class="line">num = <span class="number">3</span>; <span class="comment">//可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> num2;java</span><br><span class="line">    num2 = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>正确写法：只要保证有唯一一次赋值即可</strong></li>
<li><strong>对于基本类型，不可变局势变量中的数据不可变</strong></li>
<li><strong>对于引用类型，不可以就是变量中的地址值不可变</strong></li>
</ul>
<h3 id="9-4-final修饰成员变量"><a href="#9-4-final修饰成员变量" class="headerlink" title="9.4 final修饰成员变量"></a>9.4 final修饰成员变量</h3><blockquote>
<p><strong>对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变</strong></p>
</blockquote>
<ul>
<li>由于成员变量具有默认值，所以<strong>用了final之后必须手动赋值，不会再给默认值！</strong></li>
<li><strong>对于final成员变量，要么直接赋值，要用使用构造方法赋值，二者择其一。</strong></li>
</ul>
<h3 id="PS-权限修饰符"><a href="#PS-权限修饰符" class="headerlink" title="PS 权限修饰符"></a>PS 权限修饰符</h3><p><strong>default 只能同一个类，或同一个包下的进行访问。不同包的，即便是子类也不能访问！</strong></p>
<h2 id="第十章-内部类"><a href="#第十章-内部类" class="headerlink" title="第十章 内部类"></a>第十章 内部类</h2><blockquote>
<p><strong>分为成员内部类和匿名内部类</strong></p>
</blockquote>
<h3 id="10-1-如何使用成员内部类"><a href="#10-1-如何使用成员内部类" class="headerlink" title="10.1 如何使用成员内部类"></a>10.1 如何使用成员内部类</h3><blockquote>
<p>内用外，随便访问；外用内，需要内部类对象。</p>
</blockquote>
<p>外部类定义一个方法，通过这个方法获取内部类的实例对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InClass <span class="title">getInClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接new出内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutClass.InClass inClass = <span class="keyword">new</span> OutClass().<span class="function">new <span class="title">InClass</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>内部类 外部类的成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> class <span class="title">Inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">			syso(num);<span class="comment">// 内部类方法局部变量</span></span><br><span class="line">			syso(<span class="keyword">this</span>.num);<span class="comment">// 内部类成员变量</span></span><br><span class="line">			syso(Outer.<span class="keyword">this</span>.num);<span class="comment">//外部类成员变量 区分重名</span></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-2-如何使用局部内部类"><a href="#10-2-如何使用局部内部类" class="headerlink" title="10.2 如何使用局部内部类"></a>10.2 如何使用局部内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerSay</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;inner to say hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inner n = <span class="keyword">new</span> inner();</span><br><span class="line">    n.innerSay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>局部内部类访问所在方法的局部变量，那么这个局部变量必须是【有效final的】</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这样写是可以的。因为保证了num确实是不变的，final关键字是可以省略的【java8开始】。如果class前面加了一句num = 29，那就不对了，因为num改变了。*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么要这样做？</span></span><br><span class="line"><span class="comment">	这是害怕类还在，局部变量缺消失了，导致局部内部类无法访问局部变量！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerSay</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;inner to say hello&quot;</span>+num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inner n = <span class="keyword">new</span> inner();</span><br><span class="line">    n.innerSay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原因：</span></span><br><span class="line"><span class="comment">    1.new出来的对象在堆内存中</span></span><br><span class="line"><span class="comment">    2.局部变量是跟着方法走的，在栈内存中</span></span><br><span class="line"><span class="comment">    3.方法运行结束后，立刻出栈，局部变量就会立刻消失</span></span><br><span class="line"><span class="comment">    4.但是new出来的对象会在堆中持续存在，直到垃圾回收消失。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerSay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;inner to say hello&quot;</span> + num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object test = test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>局部内部类的使用场景</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当隐式的构造函数不能满足我们的需求，需要显示的构造函数时，使用局部内部类而非匿名内部类！</span></span><br><span class="line"><span class="comment">// 如果不考虑构造函数的问题，两者的功能是一样的。</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 局部内部类实现</span></span><br><span class="line">    <span class="function">Counter <span class="title">getCounter</span><span class="params">(<span class="keyword">final</span> String name)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LocalCounter</span> <span class="keyword">implements</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">LocalCounter</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">&quot;LocalCounter&quot;</span>); &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                <span class="keyword">return</span> count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalCounter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名内部类实现</span></span><br><span class="line">    <span class="function">Counter <span class="title">getCounter2</span><span class="params">(<span class="keyword">final</span> String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Counter() &#123;</span><br><span class="line">            <span class="comment">//只有一个默认的构造器。不能自行定义</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                <span class="keyword">return</span> count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalInnerClass in = <span class="keyword">new</span> LocalInnerClass();</span><br><span class="line">        Counter lucy = in.getCounter(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        Counter lucy2 = in.getCounter2(<span class="string">&quot;lucy2&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">            System.out.println(lucy.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">            System.out.println(lucy2.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-3-小结"><a href="#10-3-小结" class="headerlink" title="10.3 小结"></a>10.3 小结</h3><p>定义一个类的时候，权限修饰符规则</p>
<ul>
<li><strong>外部类： public or default</strong></li>
<li><strong>成员内部类： public protected default private</strong></li>
<li><strong>局部内部类： 什么都不能写！</strong></li>
</ul>
<h3 id="10-4-匿名内部类"><a href="#10-4-匿名内部类" class="headerlink" title="10.4 匿名内部类"></a>10.4 匿名内部类</h3><blockquote>
<p><strong>类只需要使用一次，那么可省略其定义！改而使用【匿名内部类】</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyInterface some = <span class="keyword">new</span> MyInterface()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		syso();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体例子</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoInnerPart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">testObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Object()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Override toString&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyInterface <span class="title">testObject2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;say hello!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p><strong>匿名内部类的注意事项</strong></p>
<ul>
<li>匿名内部类在创建对象的时候，只能使用唯一一次。</li>
<li>如果希望多次创建对象，而且类的内容一样的话，那么必须使用单独定义的实现类！</li>
</ul>
</li>
<li><p><strong>匿名内部类的使用场景</strong></p>
<ul>
<li>情况一： 接口、抽象类使用：相当于不用特意去写一个类去实现这个接口的方法，直接在实例化的时候就写好这个方法（接口、抽象类不能实例化，所以采用匿名内部类的方式来写）</li>
<li>情况二：当接口作为参数放在方法体里的时候，用new 接口()的方式来实例独享，则匿名内部类必须要实现这两个方法。</li>
</ul>
</li>
<li><p><strong>为什么需要内部类</strong></p>
</li>
</ul>
<blockquote>
<p>一般来说，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。</p>
</blockquote>
<blockquote>
<p>内部类最吸引人的原因是，每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。内部类允许继承多个非接口类型（类或抽象类）</p>
</blockquote>
<blockquote>
<p>个人认为允许多重继承的意思是，内部类对某个类进行重写再调用它的方法。让一个类可以同时使用两个类的特性。【继承一个类，内部类继承其他类，对必要方法进行重写！可以一个类为载体，内部使用多个内部类，从而实现多继承！】</p>
</blockquote>
<h4 id="10-5-内部类的继承"><a href="#10-5-内部类的继承" class="headerlink" title="10.5 内部类的继承"></a>10.5 内部类的继承</h4><p><strong>外部类继承另一个外部类的内部类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendInnerClass</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="comment">// public ExtendInnerClass()&#123;&#125; won&#x27;t compile  写这个构造会导致编译不成功</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtendInnerClass</span><span class="params">(WithInner w)</span></span>&#123;</span><br><span class="line">        w.<span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">        WithInner wi = <span class="keyword">new</span> WithInner();</span><br><span class="line">        ExtendInnerClass c = <span class="keyword">new</span> ExtendInnerClass(wi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内部类的覆盖</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">&quot;I am say1&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">&quot;I am walk&quot;</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendInnerClass2</span> <span class="keyword">extends</span> <span class="title">WithInner2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner2</span> <span class="keyword">extends</span> <span class="title">WithInner2</span>.<span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">&quot;I am say2&quot;</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExtendInnerClass2 class2 = <span class="keyword">new</span> ExtendInnerClass2();</span><br><span class="line">        Inner inner2 = <span class="keyword">new</span> ExtendInnerClass2().<span class="function">new <span class="title">Inner2</span><span class="params">()</span></span>;</span><br><span class="line">        inner2.say();   <span class="comment">// I am say2</span></span><br><span class="line">        inner2.walk(); <span class="comment">// I am walk</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h2><h3 id="11-1-Object"><a href="#11-1-Object" class="headerlink" title="11.1 Object"></a>11.1 Object</h3><ul>
<li><code>toString()方法</code></li>
<li><code>equals()方法</code><ul>
<li>注意，当需要比较对象时，覆写equals方法，以便于比较对象的大小。</li>
<li>当需要使用Arrays工具类进行大小比较时，需要继承Comparable。</li>
</ul>
</li>
</ul>
<h3 id="11-2-日期相关"><a href="#11-2-日期相关" class="headerlink" title="11.2 日期相关"></a>11.2 日期相关</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar采用了枚举，见名知意。可避免不必要的错误。似乎不常用，不学</span><br></pre></td></tr></table></figure>

<ul>
<li>日期类都采用单例模式？保证所有时间的一致？</li>
<li>不要求掌握的一些</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Calendar instance = Calendar.getInstance();</span><br><span class="line">    DateFormat dateInstance = DateFormat.getDateInstance(DateFormat.FULL);</span><br><span class="line">    System.out.println(dateInstance.format(<span class="keyword">new</span> Date())); <span class="comment">// 地理位置的判断？输出的中文？</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Testjava</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// G表示公元  字母大小写不能错，不知道为什么，无责任猜测，解析了字符串，提取的ascill码？</span></span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;Gyyyy MM dd&quot;</span>); <span class="comment">// 日期格式</span></span><br><span class="line">    System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Java8 提供的日期类 <strong>都是final修饰的</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Instant——它代表的是时间戳</span><br><span class="line"></span><br><span class="line">LocalDate——不包含具体时间的日期，比如2014-01-14。它可以用来存储生日，周年纪念日，入职日期等。</span><br><span class="line"></span><br><span class="line">LocalTime——它代表的是不含日期的时间</span><br><span class="line"></span><br><span class="line">LocalDateTime——它包含了日期及时间，不过还是没有偏移信息或者说时区。</span><br><span class="line"></span><br><span class="line">ZonedDateTime——这是一个包含时区的完整的日期时间，偏移量是以UTC/格林威治时间为基准的</span><br></pre></td></tr></table></figure>

<ul>
<li>Date仅仅含日期。不包含具体时间，有time的才有具体的时间（精确到时分秒）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//无时区</span></span><br><span class="line">    LocalDate now = LocalDate.now();</span><br><span class="line">    System.out.println(now); <span class="comment">// 2020-02-06</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> year = now.getYear();</span><br><span class="line">    <span class="keyword">int</span> month = now.getMonthValue();</span><br><span class="line">    Month monthE = now.getMonth();</span><br><span class="line">    <span class="keyword">int</span> day = now.getDayOfMonth();</span><br><span class="line">    System.out.println(<span class="string">&quot;year:&quot;</span>+year+<span class="string">&quot; month:&quot;</span>+month+<span class="string">&quot; day:&quot;</span>+day);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dayOfYear = now.getDayOfYear();</span><br><span class="line">    System.out.println(<span class="string">&quot;2020年的第&quot;</span>+dayOfYear+<span class="string">&quot;天&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    System.out.println(now);</span><br><span class="line">    LocalDateTime now2 = now.plusDays(<span class="number">10</span>);</span><br><span class="line">    System.out.println(now2);</span><br><span class="line"></span><br><span class="line">    LocalDateTime plus = now.plus(<span class="number">1</span>, ChronoUnit.YEARS);java</span><br><span class="line">    System.out.println(plus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>要用再查API</li>
<li>System类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Properties properties = System.getProperties(); <span class="comment">// 获取System的properties对象</span></span><br><span class="line">    Enumeration&lt;?&gt; enumeration = properties.propertyNames();<span class="comment">// 获得所有的key</span></span><br><span class="line">    <span class="keyword">while</span>(enumeration.hasMoreElements())&#123; <span class="comment">//是否还有元素</span></span><br><span class="line">        <span class="comment">// 安全的强转</span></span><br><span class="line">        Object c= enumeration.nextElement();</span><br><span class="line">        <span class="keyword">if</span>(c <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key:&quot;</span>+(String)c+<span class="string">&quot; ---value:&quot;</span>+System.getProperty((String)c));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object cc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>((cc = enumeration.nextElement()) <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key:&quot;</span>+(String)cc+<span class="string">&quot; ---javavalue:&quot;</span>+System.getProperty((String)cc));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">**回忆迭代器的元素遍历，回忆为什么迭代器遍历元素时可以进行元素移除的操作不会发生异常！**</span><br></pre></td></tr></table></figure>

<ul>
<li>arraycopy的使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] fromArray = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] toArray = &#123;<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      src      源数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      srcPos   源数组的其实位置 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      dest     目标数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      destPos  目标数组的开始位置</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      length   拷贝的长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    System.arraycopy(fromArray,<span class="number">1</span>,toArray,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;toArray.length ; i++) &#123;</span><br><span class="line">        System.out.println(toArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第十二章-集合框架"><a href="#第十二章-集合框架" class="headerlink" title="第十二章 集合框架"></a>第十二章 集合框架</h2><h3 id="0-引言（Think-in-Java-第11章-持有对象）"><a href="#0-引言（Think-in-Java-第11章-持有对象）" class="headerlink" title="0 引言（Think in Java 第11章 持有对象）"></a>0 引言（Think in Java 第11章 持有对象）</h3><blockquote>
<p><strong>Java容器类类库的用途是“保存对象”。可细分为单列集合，双列集合！</strong></p>
</blockquote>
<ul>
<li><p>Collection。一个独立元素序列</p>
</li>
<li><p>Map。一组成队的“键值对”对象，允许使用键来查找值</p>
</li>
<li><p>添加一组元素的 </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; c = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>));</span><br><span class="line">    Integer []arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 这里需要Integer类型的数组！</span></span><br><span class="line">    Collection&lt;Integer&gt; c1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(arr)); </span><br><span class="line">    <span class="keyword">for</span> (Integer i: c)</span><br><span class="line">        System.out.print(i+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> ( Integer i: c1)</span><br><span class="line">        System.out.print(i+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Integer []array = &#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    Collection&lt;Integer&gt; coll = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(array));</span><br><span class="line">    System.out.println(coll.size());</span><br><span class="line">    coll.addAll(Arrays.asList(array));</span><br><span class="line">    System.out.println(coll.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可变长参数 自动装箱拆箱</span></span><br><span class="line">    Collections.addAll(coll,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">    System.out.println(coll.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Integer []array = &#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    Collection&lt;Integer&gt; coll = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(array));</span><br><span class="line">    Iterator&lt;Integer&gt; iterator = coll.iterator();</span><br><span class="line">    <span class="comment">//迭代器遍历</span></span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123; <span class="comment">// hasNext仅仅判断是否有元素</span></span><br><span class="line">        Integer next = iterator.next(); <span class="comment">// 依稀记得有指针后移的操作 后面补充</span></span><br><span class="line">        System.out.println(next);</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这节就一个核心观点，使用泛型，安全！强制类型转换时使用instanceof进行检测！</li>
</ul>
<h3 id="12-1-List集合"><a href="#12-1-List集合" class="headerlink" title="12.1 List集合"></a>12.1 List集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 不使用多态，便于测试特有的实现方法</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ArrayList初始化时有容量。默认10.当用到了一定比例的空间会自行进行扩充</span></span><br><span class="line"><span class="comment">         * 简而言之：可变长数组！</span></span><br><span class="line"><span class="comment">         * 如果存储空间不足，会扩大至原来大小的2倍</span></span><br><span class="line"><span class="comment">         * int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span></span><br><span class="line"><span class="comment">         * 看remove方法的代码，似乎没有发现明显的当用的空间不多时，对数组大小进行缩减！</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 可变长数组代码的策略</span></span><br><span class="line"><span class="comment">         *      长度不够时进行数组长度的扩充，创建一个新的，大小时原来2-3倍的，把数组copy进行曲</span></span><br><span class="line"><span class="comment">         *      所用的空间不多时，对数组长度进行缩减。创建一个新的长度小的数组，把oldValue复制进去</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      度的把握：用了2/3时就进行数组的扩充</span></span><br><span class="line"><span class="comment">         *               元素只剩1/3（好像是1/2）时才进行数组的缩减.缩减的策略比较保守</span></span><br><span class="line"><span class="comment">         *               主要是因为程序的局部性原理！</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">        list.add(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Integer i = <span class="number">10</span>;</span><br><span class="line">    list.remove(i);<span class="comment">// remove(Object o)  这个是对象。</span></span><br><span class="line">    <span class="comment">// list.remove(10); 这个识别成了 index 所以报错</span></span><br><span class="line">    System.out.println(list.size()); <span class="comment">// 0</span></span><br><span class="line">    list.set(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">    System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">    System.out.println(list.lastIndexOf(<span class="number">10</span>));</span><br><span class="line">    <span class="comment">// list.forEach(); 函数式编程 后期补充</span></span><br><span class="line">    <span class="comment">// list.equals() 对象比较时 记得按需求考虑是否重写对象的equals方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 可充当 队列 / 栈？</span></span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    list.offer(<span class="number">100</span>);</span><br><span class="line">    System.out.println(list.getLast()); <span class="comment">// 记单词 tail 尾部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">        <span class="comment">// 插入 begin stack后进先出FIFO</span></span><br><span class="line">        list.addFirst(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后进入的在head 故获取First</span></span><br><span class="line">    System.out.println(list.getFirst());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-2-Set集合"><a href="#12-2-Set集合" class="headerlink" title="12.2 Set集合"></a>12.2 Set集合</h3><blockquote>
<p><strong>set无重复元素</strong></p>
</blockquote>
<ul>
<li><code>TreeSet</code> 有序，红黑树</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部使用的红黑树，我也不知道红黑树是啥</span></span><br><span class="line"><span class="comment">     * 二叉排序树 --&gt; AVL --&gt; 红黑树</span></span><br><span class="line"><span class="comment">     * 应该都满足，中序遍历结果是有序的！</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">        set.add((<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(set.size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : set)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>HashSet</code> 散列表，无序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">        <span class="comment">// 看不懂代码。不看了。知道散列表的基本写法就算了.</span></span><br><span class="line">        set.add((<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(set.size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : set)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对象之间用Set</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bbxx.list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类大小比较</span></span><br><span class="line"><span class="comment"> * 依据年龄 姓名进行比较</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Student&gt; set = <span class="keyword">new</span> TreeSet&lt;Student&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            set.add(<span class="keyword">new</span> Student(i+<span class="number">5</span>,i+<span class="string">&quot;s&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(<span class="keyword">new</span> Student(<span class="number">6</span>,<span class="keyword">null</span>));</span><br><span class="line">        <span class="keyword">for</span>(Student ss : set)&#123;</span><br><span class="line">            System.out.println(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 总结</span></span><br><span class="line"><span class="comment">         * TreeSet采用的红黑树。其应该是符合二叉排序树的性质。中序遍历是有序的。</span></span><br><span class="line"><span class="comment">         * 中序遍历为从小到大的顺序。所以是从小到大来输出。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * comparable的compareTo方法返回值的解释。</span></span><br><span class="line"><span class="comment">         * 返回正数表示大于。返回0等于，返回负数表示小于!</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 查看TreeSet add的源码试试 发现 看不懂！</span></span><br><span class="line"><span class="comment">         * 采取代码测试</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Student obj1 = <span class="keyword">new</span> Student(<span class="number">6</span>, <span class="string">&quot;kkx&quot;</span>);</span><br><span class="line">        Student obj2 = <span class="keyword">new</span> Student(<span class="number">6</span>, <span class="string">&quot;kkx1&quot;</span>);</span><br><span class="line">        Student obj3 = <span class="keyword">new</span> Student(<span class="number">7</span>, <span class="string">&quot;kkx3&quot;</span>);</span><br><span class="line">        Student obj4 = <span class="keyword">new</span> Student(<span class="number">8</span>, <span class="string">&quot;kkx1&quot;</span>);</span><br><span class="line">        <span class="comment">// -1 如果是表示小于那么set集合的输出顺序是obj1在前</span></span><br><span class="line">        System.out.println(obj1.compareTo(obj2));</span><br><span class="line">        set.clear();</span><br><span class="line">        set.add(obj1);</span><br><span class="line">        set.add(obj2);</span><br><span class="line">        <span class="comment">//测试结果表明 的确是小于。</span></span><br><span class="line">        <span class="keyword">for</span>(Student ss : set)&#123;</span><br><span class="line">            System.out.println(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 总结：</span></span><br><span class="line"><span class="comment">         *  comparable的compareTo方法返回值的解释。</span></span><br><span class="line"><span class="comment">         *   返回正数表示大于。返回0等于，返回负数表示小于!</span></span><br><span class="line"><span class="comment">         *   obj1.compareTo(obj2) 比较1 和 2的大小。返回正数则 obj1大</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方便操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(age, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Object obj;</span><br><span class="line">        <span class="comment">// 不属于该类</span></span><br><span class="line">        <span class="keyword">if</span> (!((obj = o) <span class="keyword">instanceof</span> Student)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对象错误&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        o = (Student) o;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.equals(o)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 优先通过年龄判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; ((Student) o).age) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 其次通过姓名判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age == ((Student) o).age) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.name==<span class="keyword">null</span> &amp;&amp; ((Student) o).name==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.name == <span class="keyword">null</span> &amp;&amp; ((Student) o).name!=<span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="keyword">this</span>.name.compareTo(((Student) o).name);</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-3-Map集合"><a href="#12-3-Map集合" class="headerlink" title="12.3 Map集合"></a>12.3 Map集合</h3><blockquote>
<p><strong>常用的有 <code>HashMap</code>和<code>TreeMap</code></strong></p>
</blockquote>
<ul>
<li><p><code>HashMap</code>相关</p>
<ul>
<li>基本原理：<code>Java1.8</code>后是 红黑树+散列表。最开始是散列表的拉链法，链长度超过八是链转为红黑树！</li>
<li><code>HashMap</code>的key可以存入null**</li>
<li>基本操作：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// map的存储 遍历  指定泛型，安全</span></span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>,<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    map.put(<span class="number">12</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    map.put(<span class="number">13</span>,<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    map.put(<span class="number">1</span>,<span class="string">&quot;DD&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map的基本遍历有两种方式</span></span><br><span class="line">    <span class="comment">// 先获取所有的key  @return a set view of the keys contained in this map</span></span><br><span class="line">    Set set = map.keySet();</span><br><span class="line">    Iterator iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(map.get(iterator.next()));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;*************华丽的分割线*************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @return a set view of the mappings contained in this map</span></span><br><span class="line">    <span class="comment">// 记不清就点进去看他的返回值回忆具体操作</span></span><br><span class="line">    Set set1 = map.entrySet();</span><br><span class="line">    Iterator iterator1 = set1.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator1.hasNext())&#123;</span><br><span class="line">        <span class="comment">// Map.Entry&lt;Integer, String&gt; 内部接口</span></span><br><span class="line">        Map.Entry&lt;Integer, String&gt; next = (Map.Entry&lt;Integer, String&gt;)iterator1.next();</span><br><span class="line">        System.out.println(next.getKey()+<span class="string">&quot;==&quot;</span>+next.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>PS</strong>：开始没必要学太细，第17章有深入理解集合的内容！</p>
<p><strong><code>HashMap</code>对象的key、value值均可为null。且<code>HashMap</code>是线程不安全的</strong></p>
<p><strong><code>HahTable</code>对象的key、value值均不可为null。且<code>HashTable</code>是线程安全的</strong>，put方法用synchronized锁了！好多方法也用synchronized锁了。如remove这些方法！</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Hashtable&lt;Integer, String&gt; table = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="comment">// 测试时 发现 key也不能为null，key为null时，没有对应的处理策略</span></span><br><span class="line">    table.put(<span class="keyword">null</span>,<span class="string">&quot;ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map的存储 遍历  指定泛型，安全</span></span><br><span class="line">    HashMap map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>,<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    map.put(<span class="number">12</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    map.put(<span class="number">13</span>,<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    map.put(<span class="number">1</span>,<span class="string">&quot;DD&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果key为null时有处理策略的 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span></span><br><span class="line">    map.put(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><code>TreeMap</code>基本内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 盲猜 TreeMap的key有二叉排序树的性质 中序遍历为从小到大 内部采用的红黑树。</span></span><br><span class="line">    <span class="comment">// 暂时用二叉排的性质去理解。</span></span><br><span class="line">    <span class="comment">// String 内部的排序 比较的时ASCII码值 Unicode包含ASCII的所有码值</span></span><br><span class="line">    TreeMap&lt;String, String&gt; map = <span class="keyword">new</span> TreeMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;B123B&quot;</span>,<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;23BB&quot;</span>,<span class="string">&quot;DD&quot;</span>);</span><br><span class="line">    Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = entries.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, String&gt; next = iterator.next();</span><br><span class="line">        <span class="comment">// 有时候不用泛型 代码返回值就是舒服</span></span><br><span class="line">   System.out.println(next.getKey()+<span class="string">&quot;:&quot;</span>+next.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Properties集合</p>
<blockquote>
<p><code>HashTable</code>的子类。常用于存储一些配置信息。回忆<code>properties</code>文件，好像是的。还有一个properties流？果不其然，有load方法传入的对象是输入流！</p>
</blockquote>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">// 仅仅可以为String，应该是专门为配置文件所产生的一个map</span></span><br><span class="line">    properties.setProperty(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;kkx&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    Set&lt;Map.Entry&lt;Object, Object&gt;&gt; entries = properties.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;Object, Object&gt;&gt; iterator = entries.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;Object, Object&gt; next = iterator.next();</span><br><span class="line">        System.out.println(next.getKey()+<span class="string">&quot;:&quot;</span>+next.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    Runtime runtime = Runtime.getRuntime();java</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="12-4-集合工具类"><a href="#12-4-集合工具类" class="headerlink" title="12.4 集合工具类"></a>12.4 集合工具类</h3><p>集合工具类 Collections：排序、复制、翻转等操作</p>
<p>数据工具类 Arrays：排序、复制、翻转等操作，Arrays.sort(数组)</p>
<p>排序默认是字典顺序，从小到大。</p>
<blockquote>
<p><strong>Collections</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collections.max(list);</span><br><span class="line">Collections.min(list);</span><br><span class="line">Collections.binarySearch(list,find_value);</span><br><span class="line">Collections.shuffle(list); <span class="comment">// 洗牌，打乱数据的顺序</span></span><br><span class="line">Collections.reverse(list); <span class="comment">// 反转</span></span><br><span class="line">Collections.swap(list,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">// 2  3 位置的数据交换</span></span><br><span class="line">Collections.replaceAll(list,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;A&quot;</span>); <span class="comment">// 所有小写a替换成大写A</span></span><br><span class="line">Collections.fill(list,<span class="string">&quot;h&quot;</span>); <span class="comment">// 全部填充为h</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Arrays</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与Collections没什么区别</span></span><br></pre></td></tr></table></figure>

<h3 id="12-5-比较器"><a href="#12-5-比较器" class="headerlink" title="12.5 比较器"></a>12.5 比较器</h3><p>用户自定义对象需要排序的话就需要比较器了~</p>
<p>自定义比较器：</p>
<ul>
<li>Comparable：内部比较器，需要修改被比较的对象Person</li>
<li>Comparator：外部比较器，不需要修改被比较的对象Person</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部比较器</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回值</span></span><br><span class="line"><span class="comment">    1  正数 当前对象大 [降序，怎么理解，，，]</span></span><br><span class="line"><span class="comment">    0  一样大</span></span><br><span class="line"><span class="comment">    -1 负数 当前对象小，传入的对象大</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    这样记忆吧。假设当前对象位置是0。</span></span><br><span class="line"><span class="comment">    当前对象大，返回1，新对象就在1了，降序，就是大--&gt;小</span></span><br><span class="line"><span class="comment">    当前对象小，返回-1，那么新对象就插在-1处，就是：小--&gt;大</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>思路：将比较的对象（Person）实现Comparable接口，重写compareTo方法，在该方法内写比较的逻辑。重点返回值是：-1，0，1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部比较器，无侵入性，传给集合</span></span><br><span class="line"><span class="comment">// 这种没必要记，写个demo测一下就可以了~~~</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myxx</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1,Object o2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 强转</span></span><br><span class="line">        <span class="keyword">return</span> s1.age - s2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第十三章-异常"><a href="#第十三章-异常" class="headerlink" title="第十三章 异常"></a>第十三章 异常</h2><h2 id="第十四章-注解"><a href="#第十四章-注解" class="headerlink" title="第十四章 注解"></a>第十四章 注解</h2><h2 id="第十五章-IO流"><a href="#第十五章-IO流" class="headerlink" title="第十五章 IO流"></a>第十五章 IO流</h2><blockquote>
<p>IO流可大致分为字节流和字符流。字节是按字节进行输入输出的，适用于各种文件。字符流是按字符进行输入输出的，适用于文本文件。</p>
</blockquote>
<blockquote>
<p><strong>IO流文件的创建读取，采用相对路径是以当前项目为基准的！</strong></p>
</blockquote>
<ul>
<li>输入流：其他地方向内存中输入。     xx—&gt;内存</li>
<li>输出流：从内存中输出到其他地方。 内存—&gt;其他</li>
</ul>
<h3 id="15-1-字节流"><a href="#15-1-字节流" class="headerlink" title="15.1 字节流"></a>15.1 字节流</h3><p>无论何种文件，都是以二进制（字节）的形式存储在计算机中。可操作Computer中的任何文件。</p>
<p><strong>字节流通常以<code>InputStream</code>或<code>OutputStream</code>结尾</strong></p>
<h4 id="15-1-1-文件的输入（读取文件）"><a href="#15-1-1-文件的输入（读取文件）" class="headerlink" title="15.1.1 文件的输入（读取文件）"></a>15.1.1 文件的输入（读取文件）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 通过类加载器获得classpath下的文件（就是src目录下的文件）</span></span><br><span class="line">    InputStream in1 = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    InputStream in2 = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\xx\\JavaDay08( IO )\\src\\test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 断言是否为空 不为空 说明找到了文件</span></span><br><span class="line">    Assert.assertNotNull(in2);</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((b = in1.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>)b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>关于文件的路径问题</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、对于File类构造方法，他需要的传入的是一个“路径名字符串”，而并不是一个单纯的文件名，对吧兄弟。</span><br><span class="line"></span><br><span class="line">2、对于jvm来说，在classloader加载时候，你所以存放的d.txt也会随classloader进行加载，因此他们属于同级目录。</span><br><span class="line"></span><br><span class="line">3、如果楼主真心想采用d.txt来读取的话。可以使用classloader加载原理来读取。</span><br><span class="line"></span><br><span class="line">此方法需要注意，静态方法（通过当前的classloader加载的类来获取当前d.txt被加载的路径）</span><br></pre></td></tr></table></figure>

<h4 id="15-1-2-文件的输出（写入）"><a href="#15-1-2-文件的输出（写入）" class="headerlink" title="15.1.2 文件的输出（写入）"></a>15.1.2 文件的输出（写入）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 只写文件是默认创建在与src同级目录。就是a.txt的目录和src同级</span></span><br><span class="line">    FileOutputStream fos1 = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 写绝对路径的话</span></span><br><span class="line">    FileOutputStream fos2 = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E://a.txt&quot;</span>);</span><br><span class="line">    String str = <span class="string">&quot;!23&quot;</span>;</span><br><span class="line">    <span class="comment">// 直接写一个字节数组</span></span><br><span class="line">    fos1.write(str.getBytes());</span><br><span class="line">    <span class="comment">// 一个一个字节写</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">        fos2.write(bytes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 追加写入</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn3</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// public FileOutputStream(String name, boolean append) append = true 追加写入</span></span><br><span class="line">    FileOutputStream fio = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;aaaa.txt&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    fio.write(<span class="string">&quot;liujiawei&quot;</span>.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-1-3-文件的复制"><a href="#15-1-3-文件的复制" class="headerlink" title="15.1.3 文件的复制"></a>15.1.3 文件的复制</h4><ul>
<li>获取输入流，将内容读入内存</li>
<li>获取输出流，将读入的内容写到磁盘</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn4</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建输入流 准备读入文件</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E://note.docx&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 创建输出流 准备写文件到外存</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copyNote.docx&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 逐步将读到的文件 写到外存</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((b = fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">        fos.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">    fis.close();</span><br><span class="line">    fos.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn5</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 加强版，依次读一串。</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E://note.docx&quot;</span>);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copy2Note.docx&quot;</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> read = fis.read(bytes);</span><br><span class="line">    <span class="keyword">while</span>((read = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        fos.write(bytes,<span class="number">0</span>,bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line">    fis.close();</span><br><span class="line">    fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-1-4-字节缓冲流"><a href="#15-1-4-字节缓冲流" class="headerlink" title="15.1.4 字节缓冲流"></a>15.1.4 字节缓冲流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn6</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 字节缓冲流 看源码可以知道 bf默认有一个8192的字节数组。</span></span><br><span class="line">    <span class="comment">// bis读取时一次读取8192字节</span></span><br><span class="line">    <span class="comment">// bos 写入时 write(len) 写入指定长度的数据。 bis的buff字节数组用volatile修饰了，应该是给当前线程的xx</span></span><br><span class="line">    <span class="comment">// 查看资源用的，bos写入时好获得要写入的字节数组</span></span><br><span class="line">    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E://note.docx&quot;</span>));</span><br><span class="line">    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;note3.docx&quot;</span>));</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len = bis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">        bos.write(len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-2-字符流"><a href="#15-2-字符流" class="headerlink" title="15.2 字符流"></a>15.2 字符流</h3><ul>
<li>为什么出现字符流？</li>
</ul>
<blockquote>
<p>有些是好几个字节组成一个字符，一个一个字节读，输出的数据可能不对！文件的复制时，由于是连续的操作，所以没出现问题！（同时，一个一个字节的读取，写入，频繁的进行系统调用，在申请调用上太费时了。）</p>
</blockquote>
<ul>
<li>小例子</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn7</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Properties properties = System.getProperties();</span><br><span class="line">    Enumeration&lt;?&gt; enumeration = properties.propertyNames();</span><br><span class="line">    <span class="keyword">while</span> (enumeration.hasMoreElements())&#123;</span><br><span class="line">        String o = (String) enumeration.nextElement();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到当前系统的默认编码格式 得到的是UTF-8</span></span><br><span class="line">    System.out.println(System.getProperty(<span class="string">&quot;file.encoding&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn8</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;详细信息显示&quot;</span>;</span><br><span class="line">    <span class="comment">//using the platform&#x27;s default charset</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line">    <span class="keyword">byte</span>[] bytess = str.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    <span class="comment">// U8</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;bytes.length ; i++) &#123;</span><br><span class="line">        System.out.print(bytes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;\r\n&quot;</span>+<span class="string">&quot;*****************&quot;</span>);</span><br><span class="line">    <span class="comment">// GBK</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;bytess.length ; i++) &#123;</span><br><span class="line">        System.out.print(bytess[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>字符流 = 字节流 + 编码表</strong></p>
</blockquote>
<blockquote>
<p>用字节流复制文本文件时，文本文件的中文没有问题。原因是最终底层操作会自动进行字节拼接成中文，如何识别中文呢？</p>
</blockquote>
<blockquote>
<p>汉字在存储时，无论时那种编码存储，第一个字节都是负数！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码验证</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn9</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\Eclipse_javaee_workspace\\JavaSE\\JavaDay08( IO )\\src\\test.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fisRead = fis.read();</span><br><span class="line">    fis.close();</span><br><span class="line">    System.out.println((<span class="keyword">char</span>)fisRead+<span class="string">&quot;:&quot;</span>+fisRead); <span class="comment">// 乱码 ä:228</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;**************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\Eclipse_javaee_workspace\\JavaSE\\JavaDay08( IO )\\src\\test.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">int</span> readerRead = reader.read();</span><br><span class="line">    System.out.println((<span class="keyword">char</span>)readerRead+<span class="string">&quot;:&quot;</span>+readerRead);<span class="comment">// 不乱码 中:20013</span></span><br><span class="line"></span><br><span class="line">    reader.close();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">20013</span>; <span class="comment">//</span></span><br><span class="line">    System.out.println((<span class="keyword">char</span>)i);<span class="comment">// 输出“中”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>汉字的码值很大！字节流的返回值在-1到255直接，无法正确识别大的数值。</li>
</ul>
<h4 id="15-2-1-字符流的输出（写入文本文件）"><a href="#15-2-1-字符流的输出（写入文本文件）" class="headerlink" title="15.2.1 字符流的输出（写入文本文件）"></a>15.2.1 字符流的输出（写入文本文件）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;charTest.txt&quot;</span>));</span><br><span class="line">    osw.write(<span class="number">97</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  cbuf  Buffer of characters</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  off   Offset from which to start writing characters</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  len   Number of characters to write 写入的数据的数目 写len个</span></span><br><span class="line"><span class="comment">     * 其他的大同小异 不赘述</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">char</span>[] ch = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>&#125;;</span><br><span class="line">    osw.write(ch,<span class="number">5</span>,<span class="number">2</span>);</span><br><span class="line">    osw.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn9</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    String absolutePath = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>).getAbsolutePath();</span><br><span class="line">    System.out.println(absolutePath);<span class="comment">//</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * E:\Eclipse_javaee_workspace\JavaSE\JavaDay08(IO)\. 打印当前文件的路径。</span></span><br><span class="line"><span class="comment">     * 如果用 new FileInputStream(&quot;test.txt&quot;) 他是从    E:\Eclipse_javaee_workspace\JavaSE\JavaDay08(IO)\.这里找！</span></span><br><span class="line"><span class="comment">     * 而test.txt实际在E:\Eclipse_javaee_workspace\JavaSE\JavaDay08(IO)\src\test.txt</span></span><br><span class="line"><span class="comment">     * 路径不一致，所以找部分指定文件！</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\Eclipse_javaee_workspace\\JavaSE\\JavaDay08(IO)\\src\\test.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fisRead = fis.read();</span><br><span class="line">    fis.close();</span><br><span class="line">    System.out.println((<span class="keyword">char</span>)fisRead+<span class="string">&quot;:&quot;</span>+fisRead); <span class="comment">// 乱码 ä:228</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;**************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\Eclipse_javaee_workspace\\JavaSE\\JavaDay08(IO)\\src\\test.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">int</span> readerRead = reader.read();</span><br><span class="line">    System.out.println((<span class="keyword">char</span>)readerRead+<span class="string">&quot;:&quot;</span>+readerRead);<span class="comment">// 不乱码 中:20013</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>获取src下的文件请用类加载器进行加载！</strong></p>
</blockquote>
<h4 id="15-2-2-字符流的输入（读取到内存）"><a href="#15-2-2-字符流的输入（读取到内存）" class="headerlink" title="15.2.2 字符流的输入（读取到内存）"></a>15.2.2 字符流的输入（读取到内存）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn3</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    FileReader r = <span class="keyword">new</span> FileReader(<span class="string">&quot;charTest.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> read = r.read();</span><br><span class="line">    System.out.println(read);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-3-字符缓冲流的使用"><a href="#15-3-字符缓冲流的使用" class="headerlink" title="15.3 字符缓冲流的使用"></a>15.3 字符缓冲流的使用</h4><blockquote>
<p><strong>与字节缓冲流类似，也是用到了装饰模式，且内部有一个8192大小的数组（不过是char数组）</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 读文本到内存中</span></span><br><span class="line">    BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;bw.txt&quot;</span>));</span><br><span class="line">    bw.write(<span class="string">&quot;hwllo woafasdfs&quot;</span>);</span><br><span class="line">    bw.newLine();</span><br><span class="line">    bw.write(<span class="string">&quot;asfhashfasfhoihasff&quot;</span>);</span><br><span class="line">    bw.newLine();</span><br><span class="line">    bw.flush();</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;bw.txt&quot;</span>));</span><br><span class="line">    System.out.println(br.readLine());</span><br><span class="line">    bw.close();</span><br><span class="line">    br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-3-File类概述"><a href="#15-3-File类概述" class="headerlink" title="15.3 File类概述"></a>15.3 File类概述</h3><h4 id="15-3-1-概述"><a href="#15-3-1-概述" class="headerlink" title="15.3.1 概述"></a>15.3.1 概述</h4><blockquote>
<p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 </p>
</blockquote>
<p><strong>注意：</strong></p>
<p><strong>一个点 . 表示当前目录</strong></p>
<p><strong>两个点  .. 表示上一级目录</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File fil = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">System.out.println(fil.isDirectory() + <span class="string">&quot;:&quot;</span>+fil.getAbsolutePath());</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">System.out.println(file.isDirectory()+<span class="string">&quot;:&quot;</span>+file.getAbsolutePath());</span><br></pre></td></tr></table></figure>

<ul>
<li>要求<ul>
<li>梳理File的基本操作</li>
<li>遍历指定目录的所有文件（单级）</li>
<li>遍历指定目录的所有文件（多级）</li>
<li>复制单级目录文件</li>
<li>复制多级目录文件</li>
<li><code>JDK7</code>的异常处理</li>
</ul>
</li>
<li>File的基本操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* File概述 及其基本操作</span></span><br><span class="line"><span class="comment">* Java文件类以抽象的方式代表文件名和目录路径名。该类主要用于文件和目录的创建、文件的查找和文件的删除等。</span></span><br><span class="line"><span class="comment">* File对象代表磁盘中实际存在的文件和目录。OS中文件和目录似乎是一个性质。Linux中将目录看作一种特殊的文件</span></span><br><span class="line"><span class="comment">*      回忆FCB 及其处理策略（OS）</span></span><br><span class="line"><span class="comment">*      回忆文件的存储方式（OS）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 与IO流一致，默认为相对路径。</span></span><br><span class="line">    File file= <span class="keyword">new</span> File(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists()) file.createNewFile();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// E:\Eclipse_javaee_workspace\JavaSE\JavaDay08( IO )\file.txt</span></span><br><span class="line">    System.out.println(file.getAbsolutePath()); </span><br><span class="line">    System.out.println(file.isAbsolute()); <span class="comment">// false</span></span><br><span class="line">    System.out.println(file.isDirectory()); <span class="comment">// false</span></span><br><span class="line">    System.out.println(file.isFile());  <span class="comment">// true</span></span><br><span class="line">    System.out.println(file.toString());<span class="comment">// file.txt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历指定目录的所有文件（单级别目录）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历单级文件夹下的所有文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// E:\Eclipse_javaee_workspace\JavaSE\JavaDay08( IO )</span></span><br><span class="line">    System.out.println(file.getAbsolutePath());</span><br><span class="line">    System.out.println(file.isDirectory());<span class="comment">// false</span></span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="comment">// E:\Eclipse_javaee_workspace\JavaSE\JavaDay08( IO )\.</span></span><br><span class="line">    System.out.println(file2.getAbsolutePath());</span><br><span class="line">    System.out.println(file2.isDirectory());<span class="comment">// true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">    String[] list = file2.list();</span><br><span class="line">    <span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历指定目录的所有文件（多级）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 遍历指定文件夹下的所有文件。仅输出文件名称+文件绝对路径</span></span><br><span class="line"><span class="comment">* 递归</span></span><br><span class="line"><span class="comment">* 遇到目录就继续访问</span></span><br><span class="line"><span class="comment">* 遇到文件就打印输出</span></span><br><span class="line"><span class="comment">* 递归的判断条件是是否为目录</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得单曲目录 即项目名的目录 xxx\JavaSE\JavaDay08( IO )\.</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    getAllFile(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(file == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">if</span>(files == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (File tempFile : files) &#123;</span><br><span class="line">        <span class="comment">// 不存在传入null</span></span><br><span class="line">        <span class="keyword">if</span> (tempFile.isDirectory()) &#123;</span><br><span class="line">            getAllFile(tempFile);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;fileName = &quot;</span> + tempFile.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>复制单级目录文件<ul>
<li>找到源文件</li>
<li>找到目的地，目的地不存在则创建</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    File dest = <span class="keyword">new</span> File(<span class="string">&quot;E:\\copyTemp&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!dest.exists()) dest.mkdirs();</span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">for</span> (File tempFile : files) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tempFile.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// 执行复制操作</span></span><br><span class="line">            copyFile(<span class="keyword">new</span> File(file,tempFile.getName()), <span class="keyword">new</span> File(dest, tempFile.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src  源文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest 目的文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(File src, File dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(src));</span><br><span class="line">         BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(dest));) &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b);</span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>复制多级目录<ul>
<li>递归遍历源文件夹</li>
<li>当遇到文件时则进行复制</li>
<li>遇到文件夹时则继续遍历</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1.遍历源文件。</span></span><br><span class="line"><span class="comment">*      遍历过程中，如果遇到的是文件夹，则在dest创建对应的文件夹</span></span><br><span class="line"><span class="comment">*      遇到的是文件，则在dest创建对应的文件。</span></span><br><span class="line"><span class="comment">*      注意路径的保存</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn7</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;E://copy2&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file1.exists()) file1.mkdirs();</span><br><span class="line">    copy(file,file1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(File src, File dest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File[] files = src.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (files == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (File temp : files) &#123;</span><br><span class="line">        String curName = temp.getName();</span><br><span class="line">        <span class="keyword">if</span> (temp.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// 如果是目录 则创建 创建后递归遍历</span></span><br><span class="line">            File file = copyDirectory(dest, curName);</span><br><span class="line">            copy(<span class="keyword">new</span> File(src,curName),file);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 是文件则复制文件，该层递归结束</span></span><br><span class="line">            copyFile(<span class="keyword">new</span> File(src, curName), <span class="keyword">new</span> File(dest, curName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> File <span class="title">copyDirectory</span><span class="params">(File dest, String curName)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(dest, curName);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists()) file.mkdir();</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>jdk7</code>的异常处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(File src, File dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(src));</span><br><span class="line">         BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(dest));) &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b);</span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-4-标准输入输出流"><a href="#15-4-标准输入输出流" class="headerlink" title="15.4 标准输入输出流"></a>15.4 标准输入输出流</h3><h4 id="15-4-1-标准输入流"><a href="#15-4-1-标准输入流" class="headerlink" title="15.4.1 标准输入流"></a>15.4.1 标准输入流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = System.in;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 模拟Scanner读入一个char 读入String</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 只能安全键盘录入字节</span></span><br><span class="line">    InputStream in = System.in;</span><br><span class="line">    <span class="comment">// 转换流 装饰模式</span></span><br><span class="line">    InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">    <span class="comment">// -1 到 0xFFFF</span></span><br><span class="line">    <span class="keyword">int</span> read = isr.read();</span><br><span class="line">    <span class="comment">// 可以安全地读入一个中文</span></span><br><span class="line">    System.out.println((<span class="keyword">char</span>)read);</span><br><span class="line">    <span class="comment">// 读一个串地话，自己设置char数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-4-2-标准输出流"><a href="#15-4-2-标准输出流" class="headerlink" title="15.4.2 标准输出流"></a>15.4.2 标准输出流</h4><blockquote>
<p><strong>客户端的输入内容，直接写入文本？？！！重定向牛批</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PrintStream out = System.out;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 标准输入流的重定向</span></span><br><span class="line"><span class="comment">* 从键盘输入 打印到文本中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    PrintStream printStream = <span class="keyword">new</span> PrintStream(<span class="string">&quot;target.txt&quot;</span>);</span><br><span class="line">    System.setOut(printStream);</span><br><span class="line">    String str = <span class="string">&quot;999&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(!str.equals(<span class="string">&quot;exit&quot;</span>))&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        str = sc.next();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-4-打印流-用于写入数字，写入对象哈希值什么的"><a href="#15-4-打印流-用于写入数字，写入对象哈希值什么的" class="headerlink" title="15.4 打印流====用于写入数字，写入对象哈希值什么的"></a>15.4 打印流====用于写入数字，写入对象哈希值什么的</h3><h4 id="15-4-1-字节打印流"><a href="#15-4-1-字节打印流" class="headerlink" title="15.4.1 字节打印流"></a>15.4.1 字节打印流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PrintStream</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn6</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xxx.txt&quot;</span>),<span class="keyword">true</span>);</span><br><span class="line">    ps.println(<span class="number">99</span>);</span><br><span class="line">    ps.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-4-2-字符打印流"><a href="#15-4-2-字符打印流" class="headerlink" title="15.4.2 字符打印流"></a>15.4.2 字符打印流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 字符打印流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn4</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;a.x&quot;</span>));</span><br><span class="line">    printWriter.write(<span class="number">99</span>);</span><br><span class="line">    printWriter.close();</span><br><span class="line">    <span class="comment">// 不刷新看一看</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn5</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// true 调用 print println时自动刷新 而且写入的时99 不进行转型（char）99 也可以写入对象？</span></span><br><span class="line">    PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;a.txt&quot;</span>),<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 写入数字</span></span><br><span class="line">    printWriter.println(<span class="number">99</span>);</span><br><span class="line">    <span class="comment">// 写入对象的哈希值</span></span><br><span class="line">    printWriter.println(<span class="keyword">new</span> Object());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-5-其他流对象"><a href="#15-5-其他流对象" class="headerlink" title="15.5 其他流对象"></a>15.5 其他流对象</h3><h4 id="15-5-1-对象序列化"><a href="#15-5-1-对象序列化" class="headerlink" title="15.5.1 对象序列化"></a>15.5.1 对象序列化</h4><ul>
<li>用于将不常用的又不能销毁的对象存入文本，要用时在从文本读取。可以节约内存？</li>
<li>类想要被序列化需要实现**<code>Serializable</code>**接口</li>
<li>类的个别字段不想被序列化的话使用<strong>transient</strong>关键字</li>
<li>若因为类进行了更改导致反序列化失败，如何解决？<ul>
<li>定义一个<code>private static final long serialVersionUID = -6849794470754660L;</code>进行是否是同一个类的判断</li>
<li>无责任猜测：应该是计算了类的信息指纹，用信息指纹的比较来判断是否是同一个类。【密码学】</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 测试序列化流的基本方法</span></span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;objectDemo.txt&quot;</span>));</span><br><span class="line">    oos.writeObject(<span class="keyword">new</span> Student(<span class="string">&quot;hello1&quot;</span>,<span class="number">52</span>));</span><br><span class="line">    oos.writeObject(<span class="keyword">new</span> Student(<span class="string">&quot;hello2&quot;</span>,<span class="number">52</span>));</span><br><span class="line">    oos.writeObject(<span class="keyword">new</span> Student(<span class="string">&quot;hello3&quot;</span>,<span class="number">52</span>));</span><br><span class="line">    oos.flush();</span><br><span class="line">    oos.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取序列化对象</span></span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;objectDemo.txt&quot;</span>));</span><br><span class="line">    Student o = (Student) ois.readObject();</span><br><span class="line">    System.out.println(o.toString());</span><br><span class="line">    ois.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果对象被更改了，能否再次正确读出？ 无法正确读出！！</span></span><br><span class="line"><span class="comment">// 怎么办？ 使用private static final long serialVersionUID = -6849794470754660L; 标识是否是同一个对象</span></span><br><span class="line"><span class="comment">// 不仅识别了，多余的方法还可以调用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;objectDemo.txt&quot;</span>));</span><br><span class="line">    Student o = (Student) ois.readObject();</span><br><span class="line">    Object o1 = ois.readObject();</span><br><span class="line">    Object o2 = ois.readObject();java</span><br><span class="line">        <span class="comment">// 应该报错吧</span></span><br><span class="line">        Object o3 = ois.readObject();</span><br><span class="line">    o.say();</span><br><span class="line">    System.out.println(o.toString());</span><br><span class="line">    ois.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754660L</span>;</span><br><span class="line">    <span class="comment">// 不想被序列化的字段用transient</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是多余的方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-5-2-Properties与IO流的结合"><a href="#15-5-2-Properties与IO流的结合" class="headerlink" title="15.5.2 Properties与IO流的结合"></a>15.5.2 Properties与IO流的结合</h4><ul>
<li>用于配置文件，防止硬编码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Properties与IO流的结合使用</span></span><br><span class="line"><span class="comment"> *  之前看他的方法 发现有传入IO对象的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 存入数据！  想一想数据库连接池的配置文件，就是这么个意思。防止硬编码。</span></span><br><span class="line">        <span class="comment">// 我真是个小天才</span></span><br><span class="line">        Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">        p.setProperty(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line">        p.setProperty(<span class="string">&quot;jdbc&quot;</span>,<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        p.store(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;PropertiesDemo.properties&quot;</span>),<span class="string">&quot;无备注&quot;</span>);</span><br><span class="line"></span><br><span class="line">        p.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;PropertiesDemo.properties&quot;</span>));</span><br><span class="line">        String name = p.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第十六章-线程"><a href="#第十六章-线程" class="headerlink" title="第十六章 线程"></a>第十六章 线程</h2><blockquote>
<p><strong>进程与线程的概念，看操作系统课本！看以前做的笔记，画的思维导图。</strong></p>
</blockquote>
<ul>
<li><p>多线程的实现方式</p>
<ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
</ul>
</li>
<li><p>线程调度模型</p>
<ul>
<li>分时调度模型：所有线程轮流使用CPU使用权，平均分配每个线程占用CPU的时间（RR）</li>
<li>抢占式调度模型：优先让优先级高的线程使用CPU，优先级相同则随机选取一个。优先级高的线程获取CPU的时间更多。</li>
<li>我记得操作系统里有一个调度模型：<strong>找书看一下 “多级反馈队列”</strong> <strong>汤子瀛 P94</strong></li>
</ul>
</li>
<li><p>线程优先级的设置</p>
<ul>
<li><code>getPriority()</code>获得此线程的优先级</li>
<li><code>setPriority()</code>更改此线程的优先级</li>
<li>优先级高，仅仅代表获取<code>cpu</code>的几率高！回忆OS防止进程饥饿！</li>
</ul>
</li>
<li><p>线程控制</p>
<ul>
<li><code>sleep(long millis)</code>：使当前正在执行的线程暂停<code>millis</code>毫秒</li>
<li>join()：等待这个线程死亡。<code>A.join(),</code>只有A这个线程执行完毕后，后面的代码/线程才会执行</li>
<li><strong><code>setDaemon(boolean on)</code>：将线程标记为守护线程，当运行的线程为守护线程是，Java虚拟机将退出【其他线程执行完毕后，如果剩下的都是守护线程，则<code>jvm</code>不会等待守护线程执行完，会直接退出！】</strong></li>
</ul>
</li>
<li><p>线程同步</p>
<ul>
<li>回忆OS的<code>pv</code>操作！</li>
<li>线程同步案例</li>
<li>线程同步的关键字synchronized锁，volatile保证数据可见但是不保证数据的准确性【回忆os磁盘的延迟写，cache的写回法什么的】</li>
</ul>
</li>
<li><p>线程安全类 </p>
<ul>
<li><code>StringBuffer</code>【字符串的拼接，编译器会自动优化！我测试过！】</li>
<li>Vector</li>
<li><code>Hashtable</code>===键值都不能为null。【Properties也是线程安全的】</li>
</ul>
</li>
<li><p>Lock锁 <code>jdk5</code>提供</p>
<ul>
<li><code>ReentrantLock()</code></li>
</ul>
</li>
<li><p><code>ThreadLocal</code>===Java线程本地存储</p>
</li>
</ul>
<h3 id="16-1-线程的运行"><a href="#16-1-线程的运行" class="headerlink" title="16.1 线程的运行"></a>16.1 线程的运行</h3><p>方式一：继承Thread类</p>
<ul>
<li>为什么要重写run方法？<ul>
<li>因为run方法是用来封装被线程执行的代码</li>
</ul>
</li>
<li>run方法和start方法的区别<ul>
<li>run封装线程执行的代码，直接调用，相当于普通方法调用</li>
<li>start，启动线程，然后由<code>jvm</code>调用此线程的run方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程抢夺CPU权限，交替执行。回忆CPU是如何分配的？ FIFS SJF RR</span></span><br><span class="line">        MyThread myThread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread myThread2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread1.start();</span><br><span class="line">        myThread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二：实现Runnable接口</p>
<ul>
<li>相比于继承Thread，实现Runnable接口的优势<ul>
<li>避免了Java单继承的局限性【多继承可以用内部类实现】</li>
<li>适合多个相同程序的代码去处理同一个资源。【Thread用静态定义资源也可以】，把线程和程序的代码，数据，进行了有效分类，较好体现了面向对象的设计思想！<ul>
<li>数据，代码分离体现在哪里？？？</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="16-2-线程的控制"><a href="#16-2-线程的控制" class="headerlink" title="16.2 线程的控制"></a>16.2 线程的控制</h3><h4 id="16-2-1-join"><a href="#16-2-1-join" class="headerlink" title="16.2.1 join()"></a>16.2.1 join()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyThread m1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    MyThread m2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    MyThread m3 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    m1.setName(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    m2.setName(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    m3.setName(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    m1.start();</span><br><span class="line">    m2.start();</span><br><span class="line">    m3.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    MyThread m1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    MyThread m2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    MyThread m3 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    m1.setName(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    m2.setName(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    m3.setName(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    m1.start();</span><br><span class="line">    m1.join();</span><br><span class="line">    System.out.println(<span class="string">&quot;hello  world&quot;</span>);</span><br><span class="line">    m2.start();</span><br><span class="line">    m3.start();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.getPriority());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="16-2-2-daemon"><a href="#16-2-2-daemon" class="headerlink" title="16.2.2 daemon()"></a>16.2.2 daemon()</h4><blockquote>
<p>设置当前线程为守护线程！当只剩守护线程时，jvm会退出，不会等待守护线程执行完毕</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非守护线程全部执行后 守护线程不一定能执行完毕，可能会被jvm直接终止</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyThread m1 = <span class="keyword">new</span> MyThread();<span class="comment">// for 10</span></span><br><span class="line">    MyThread2 m2 = <span class="keyword">new</span> MyThread2();<span class="comment">// for 100</span></span><br><span class="line">    MyThread2 m3 = <span class="keyword">new</span> MyThread2();<span class="comment">// for 100</span></span><br><span class="line">    m1.setName(<span class="string">&quot;大哥&quot;</span>);</span><br><span class="line">    m2.setName(<span class="string">&quot;守护大哥一号&quot;</span>);</span><br><span class="line">    m3.setName(<span class="string">&quot;守护大哥二号&quot;</span>);</span><br><span class="line">    m2.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    m3.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    m1.start();</span><br><span class="line">    m2.start();</span><br><span class="line">    m3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-3-线程的同步"><a href="#16-3-线程的同步" class="headerlink" title="16.3 线程的同步"></a>16.3 线程的同步</h3><h4 id="16-3-1-使用synchronized"><a href="#16-3-1-使用synchronized" class="headerlink" title="16.3.1 使用synchronized"></a>16.3.1 使用synchronized</h4><ul>
<li>synchronize（）中的应该就是充当信号量的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SaleTicket sale = <span class="keyword">new</span> SaleTicket();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(sale, <span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(sale, <span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(sale, <span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * OS中所谓的管程</span></span><br><span class="line"><span class="comment">         * OS中pv操作心得：pv中包裹的不影响同步的代码尽可能地少，多了影响程序性能。</span></span><br><span class="line"><span class="comment">         * java多线程应该也是如此！</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;出售了一张，还有&quot;</span> + (--ticket) + <span class="string">&quot;张&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="16-3-2-同步代码块与同步方法"><a href="#16-3-2-同步代码块与同步方法" class="headerlink" title="16.3.2 同步代码块与同步方法"></a>16.3.2 同步代码块与同步方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 同步方法！ 看视频！</span></span><br></pre></td></tr></table></figure>

<p>同步方法默认用this或者当前类class对象作为锁；<br>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；<br>同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用 synchronized（object）{代码内容}进行修饰；</p>
<hr>
<h3 id="16-4-Lock锁"><a href="#16-4-Lock锁" class="headerlink" title="16.4 Lock锁"></a>16.4 Lock锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// PV 细想-</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;出售了一张，还有&quot;</span> + (--ticket) + <span class="string">&quot;张&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-5-生产者-消费者"><a href="#16-5-生产者-消费者" class="headerlink" title="16.5 生产者 消费者"></a>16.5 生产者 消费者</h3><blockquote>
<p><strong>生产者生产，消费者消费。有同步有互斥。</strong></p>
</blockquote>
<ul>
<li>empty 告诉生产者还可以放多少</li>
<li>full 告诉消费者还可以拿多少</li>
<li>同时只能一个拿或一个放</li>
<li>不能拿/放则等待 用wait()</li>
<li>有东西了，可以拿了就notify() == 【应该是随机唤醒一个等待的线程，可以指定唤醒某个吗？】</li>
</ul>
<h2 id="第十七章-网络编程"><a href="#第十七章-网络编程" class="headerlink" title="第十七章 网络编程"></a>第十七章 网络编程</h2><h3 id="17-1-网络编程入门"><a href="#17-1-网络编程入门" class="headerlink" title="17.1 网络编程入门"></a>17.1 网络编程入门</h3><ul>
<li>网络编程<ul>
<li>在网络通信写一下，实现网络互连的不同计算机上，进行数据交换。</li>
</ul>
</li>
<li>网络编程三要素<ul>
<li>IP地址。为计算机指定标识（即IP地址）</li>
<li>端口。用于区分一台计算机的不同程序。如：A程序网络通信就用xx端口。</li>
<li>协议。网络通信需要遵从的通信规则【常见协议有 UDP协议和TCP协议】</li>
</ul>
</li>
</ul>
<h3 id="17-2-IP地址"><a href="#17-2-IP地址" class="headerlink" title="17.2 IP地址"></a>17.2 IP地址</h3><p><code>IP地址分为 IPv4和IPv6</code></p>
<ul>
<li>IPv4 地址4字节 4*8=32位</li>
<li>IPv6 地址128位地址长度，每16字节一组，分成8组十六进制数</li>
</ul>
<p><code>常见命令【windows】</code></p>
<ul>
<li>ipconfig</li>
<li>ping IP地址</li>
</ul>
<h4 id="17-2-1-InetAddress"><a href="#17-2-1-InetAddress" class="headerlink" title="17.2.1 InetAddress"></a>17.2.1 InetAddress</h4><blockquote>
<p><strong>IP地址的获取和操作，InetAddress表示Internet协议（IP）地址</strong></p>
</blockquote>
<ul>
<li>getHostName() 获得主机名称</li>
<li>getHostAddress() 返回文本显示中的IP地址字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">    <span class="comment">// 通过计算机名称得到InetAddress对象</span></span><br><span class="line">    InetAddress byAddress = InetAddress.getByName(<span class="string">&quot;DESKTOP-R0ENAIP&quot;</span>);</span><br><span class="line">    <span class="comment">// 获得主机地址</span></span><br><span class="line">    String hostAddress = byAddress.getHostAddress();</span><br><span class="line">    System.out.println(hostAddress);</span><br><span class="line">    <span class="comment">// 获得主机名称</span></span><br><span class="line">    String hostName = byAddress.getHostName();</span><br><span class="line">    System.out.println(hostName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-3-端口"><a href="#17-3-端口" class="headerlink" title="17.3 端口"></a>17.3 端口</h3><ul>
<li>端口：设备上应用程序的唯一标识</li>
<li>端口号：用两个字节表示的整数。范围是0到65535.其中0到1023被用于一些知名的网络服务和应用。普通程序建议使用1024以上的端口号，防止端口被占用启动失败！</li>
</ul>
<h3 id="17-4-协议（UDP）"><a href="#17-4-协议（UDP）" class="headerlink" title="17.4 协议（UDP）"></a>17.4 协议（<code>UDP</code>）</h3><blockquote>
<p><strong>协议：计算机网络中，连接和通信的规则称之为网络通信协议</strong></p>
</blockquote>
<h4 id="17-4-1-UDP协议"><a href="#17-4-1-UDP协议" class="headerlink" title="17.4.1 UDP协议"></a>17.4.1 <code>UDP</code>协议</h4><ul>
<li>用户数据报协议（User Datagram Protocol）</li>
<li><code>UDP</code>是无连接通信协议。数据传输时发送端和接收端不建立逻辑。回忆计组和计网的相关内容。发送和接受都不确认对面有没有人。<code>UDP</code>协议资源消耗小，通信效率高，常用于音频，视频和普通数据的传输！</li>
<li><code>UDP</code>是无连接性，不保证数据的完整性。传输重要数据不建议使用<code>UDP</code>.</li>
</ul>
<h4 id="17-4-2-UDP通信原理"><a href="#17-4-2-UDP通信原理" class="headerlink" title="17.4.2 UDP通信原理"></a>17.4.2 UDP通信原理</h4><p>UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象因此对于基于UDP协议的通信双方而已，没有所谓的客户端，服务器的概念。</p>
<h4 id="17-4-3-UDP发送，接收数据的步骤"><a href="#17-4-3-UDP发送，接收数据的步骤" class="headerlink" title="17.4.3 UDP发送，接收数据的步骤"></a>17.4.3 UDP发送，接收数据的步骤</h4><blockquote>
<p><strong>先有接收端，再有发送端！</strong></p>
</blockquote>
<p><strong>发送数据的步骤</strong></p>
<ul>
<li>创建发送端的套接字对象（DatagramSocket）</li>
<li>创建数据，并把数据打包</li>
<li>调用DatagramSocket对象的发送方法</li>
<li>关闭发送端</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="string">&quot;你好，我是xxx&quot;</span>.getBytes();</span><br><span class="line">    InetAddress byName = InetAddress.getByName(<span class="string">&quot;DESKTOP-R0ENAIP&quot;</span>);</span><br><span class="line">    DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bytes,<span class="number">0</span>,bytes.length,byName,<span class="number">8888</span>);</span><br><span class="line">    dp.setData(bytes,<span class="number">0</span>,bytes.length);</span><br><span class="line">    ds.send(dp);</span><br><span class="line">    ds.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接收数据的步骤</strong></p>
<ul>
<li>创建接收端的Socket对象（DatagramSocke）</li>
<li>创建一个数据包，用于接收数据</li>
<li>调用DatagramSocke的方法接收数据</li>
<li>解析数据包，把数据在控制台显示</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="string">&quot;你好，我是xxx&quot;</span>.getBytes();</span><br><span class="line">    InetAddress byName = InetAddress.getByName(<span class="string">&quot;DESKTOP-R0ENAIP&quot;</span>);</span><br><span class="line">    DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bytes,<span class="number">0</span>,bytes.length,byName,<span class="number">8888</span>);</span><br><span class="line">    dp.setData(bytes,<span class="number">0</span>,bytes.length);</span><br><span class="line">    ds.send(dp);</span><br><span class="line">    ds.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS : 不记得具体的xx，就点进源码去看构造方法上面的注释！！</p>
<h3 id="17-5-协议（TCP）"><a href="#17-5-协议（TCP）" class="headerlink" title="17.5 协议（TCP）"></a>17.5 协议（TCP）</h3><h4 id="17-5-1-TCP通信原理"><a href="#17-5-1-TCP通信原理" class="headerlink" title="17.5.1 TCP通信原理"></a>17.5.1 TCP通信原理</h4><p>TCP协议是一种可靠的网络协议，它在通信的两端各建立一个Socket对象，从而在通信的两端形成网络虚拟链路，一旦建立了虚拟的网络链路，两端的程序就可以通过虚拟链路进行通信！</p>
<blockquote>
<p><strong>Java对基于TCP协议的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流进行网络通信</strong></p>
</blockquote>
<h4 id="17-5-2-TCP发送数据"><a href="#17-5-2-TCP发送数据" class="headerlink" title="17.5.2 TCP发送数据"></a>17.5.2 TCP发送数据</h4><ul>
<li><p>创建客户端的Socket对象（Socket）</p>
<ul>
<li>```java<br>Socket socket = new Socket(“192.168.1.106”,8888);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 获取输出流，写数据</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    OutputStream os = socket.getOutputStream();</span><br><span class="line">    os.write(&quot;TCP我来了&quot;.getBytes());</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>释放资源</p>
<ul>
<li>```java<br>socket.close();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 17.5.3 TCP接收数据</span><br><span class="line"></span><br><span class="line">- 创建服务器端的Socket对象**（ServerSocket）**</span><br><span class="line">  - `ServerSocket(int port)`  指定端口即可</span><br><span class="line">- 监听客户端连接，返回一个Socket对象</span><br><span class="line">  - `Socket.accept();`</span><br><span class="line">- 获取输入流，读数据，把数据显示在控制台</span><br><span class="line">  - `InputStream getInputStream()`</span><br><span class="line">- 释放资源</span><br><span class="line">  - `void close()`</span><br><span class="line">- TCP读数据的方法是阻塞式的</span><br><span class="line">- 解决办法：自定义结束标记；使用`shutdownOutput（）`方法【推荐】</span><br><span class="line"></span><br><span class="line">**第一版代码**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class ClientDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 发送数据 内存向外 输出流</span><br><span class="line">        Socket socket = new Socket(&quot;192.168.1.106&quot;,8888);</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(&quot;TCP我来了&quot;.getBytes());</span><br><span class="line">        socket.close();</span><br><span class="line">        // 有用有三次握手的确认，所以需要客户端 服务器端都开启才行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ServerDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ServerSocket s = new ServerSocket(8888);</span><br><span class="line">        Socket accept = s.accept();</span><br><span class="line">        // 可以用xx流一次读一行！</span><br><span class="line">        InputStream is = accept.getInputStream();</span><br><span class="line">        byte[] bytes = new byte[4096];</span><br><span class="line">        int read = is.read(bytes, 0, bytes.length);</span><br><span class="line">        System.out.println(new String(bytes, 0, read));</span><br><span class="line">        accept.close();</span><br><span class="line">        s.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>第二版代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 发送数据 内存向外 输出流</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;192.168.1.106&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;TCP我来了&quot;</span>.getBytes());</span><br><span class="line">        socket.close();</span><br><span class="line">        <span class="comment">// 有用有三次握手的确认，所以需要客户端 服务器端都开启才行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket s = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket accept = s.accept();</span><br><span class="line">        <span class="comment">// 构造方法中要传入一个Reader对象,带Reader后缀的都继承了Reader</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(accept.getInputStream()));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        accept.close();</span><br><span class="line">        s.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-6-上传文件到服务器"><a href="#17-6-上传文件到服务器" class="headerlink" title="17.6 上传文件到服务器"></a>17.6 上传文件到服务器</h3><ul>
<li>客户端，读取文件，并逐一发送数据</li>
<li>服务器端，接收数据</li>
<li>由于网络传输，服务器端是一直在等待客户端的数据的，所以会一直等。当客户端数据传输完毕后，给出停止标记！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;192.168.1.106&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;demo5.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes, <span class="number">0</span>, bytes.length)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 停止自身的Output 这个写了，对方才知道 不要一直获取了，可以跳槽while循环</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;文件上传完毕了！要通知服务器关闭了！&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> read = socket.getInputStream().read(b, <span class="number">0</span>, b.length);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(b, <span class="number">0</span>, read));</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">        Socket accept = server.accept();</span><br><span class="line">        InputStream inputStream = accept.getInputStream();</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;Server.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes, <span class="number">0</span>, bytes.length)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            fos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        accept.shutdownInput();<span class="comment">// 停止input</span></span><br><span class="line">        System.out.println(<span class="string">&quot;文件接收完毕&quot;</span>);</span><br><span class="line">        accept.getOutputStream().write(<span class="string">&quot;完成了&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        fos.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        accept.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模拟Tomcat"><a href="#模拟Tomcat" class="headerlink" title="模拟Tomcat"></a>模拟Tomcat</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bbxx.tomcat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求相应html文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSDemo3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义类路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String WEB_ROOT;</span><br><span class="line">    <span class="comment">// 定义默认的读取端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String URL = <span class="string">&quot;404.html&quot;</span>;</span><br><span class="line">    <span class="comment">// 默认端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT = <span class="number">8888</span>;</span><br><span class="line">    <span class="comment">// 读取类信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InputStream INPUTSTREAM = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 读完WebContent下的静态文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> File FILE_STATIC = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 状态码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> CODE = <span class="number">404</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信息</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        WEB_ROOT = BSDemo3.class.getClassLoader().getResource(<span class="string">&quot;&quot;</span>).getPath() + <span class="string">&quot;WebContent&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            INPUTSTREAM = <span class="keyword">new</span> FileInputStream(WEB_ROOT + <span class="string">&quot;//web.properties&quot;</span>);</span><br><span class="line">            System.out.println(WEB_ROOT);</span><br><span class="line">            FILE_STATIC = <span class="keyword">new</span> File(WEB_ROOT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(PORT);</span><br><span class="line">        Socket accept = serverSocket.accept();</span><br><span class="line">        URL = getURL(accept);</span><br><span class="line">        setCodeForStatic(URL);</span><br><span class="line">        publicResponse(accept.getOutputStream(),CODE);</span><br><span class="line">        FileResponse(accept.getOutputStream());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得请求的URL;</span></span><br><span class="line"><span class="comment">     * 请求路径在这里 GET /4654 HTTP/1.1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> socket</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getURL</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">        String str = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((str = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.contains(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">                str = str.replace(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;HTTP/1.1&quot;</span>, <span class="string">&quot;&quot;</span>).trim();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code         状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publicResponse</span><span class="params">(OutputStream outputStream, <span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        String codeStr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">200</span>) codeStr = code + <span class="string">&quot; OK&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">404</span>) codeStr = code + <span class="string">&quot; Not Found&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream.write((<span class="string">&quot;HTTP/1.1 &quot;</span> + codeStr + <span class="string">&quot;OK\n&quot;</span>).getBytes());</span><br><span class="line">            outputStream.write(<span class="string">&quot;Content-Type:text/html;charset=utf-8&quot;</span>.getBytes());</span><br><span class="line">            outputStream.write(<span class="string">&quot;Server:Apache-Coyote/1.1\n&quot;</span>.getBytes());</span><br><span class="line">            outputStream.write(<span class="string">&quot;\n\n&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;公共请求头输出失败！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将文件传输到浏览器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FileResponse</span><span class="params">(OutputStream outputStream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader bf = <span class="keyword">new</span> BufferedReader</span><br><span class="line">                (<span class="keyword">new</span> InputStreamReader</span><br><span class="line">                        (<span class="keyword">new</span> FileInputStream(WEB_ROOT + File.separator + URL)));) &#123;</span><br><span class="line">            String content = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((content = bf.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                outputStream.write(content.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            bf.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据URL设置相应码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCodeForStatic</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Map&lt;String, String&gt; map = getURLMapStatic();</span><br><span class="line">            String s = map.get(url);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>) CODE = <span class="number">404</span>;</span><br><span class="line">            <span class="keyword">else</span> CODE = <span class="number">200</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得所有的静态URL， key是文件名称，value是绝对路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">getURLMapStatic</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; URLMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        File[] files = FILE_STATIC.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.getName().contains(<span class="string">&quot;html&quot;</span>)) &#123;</span><br><span class="line">                URLMap.put(f.getName(), f.getAbsolutePath());</span><br><span class="line">                System.out.println(f.getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> URLMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得所有动态URL(Java代码),key是名称，value是包全名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">getURLMapDymical</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; URLMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> URLMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载配置文件中的动态web文件信息 key是名称，value是类全名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">getProperties</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(in);</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第十八章-反射"><a href="#第十八章-反射" class="headerlink" title="第十八章 反射"></a>第十八章 反射</h2><h3 id="18-0-类加载器前置知识概述"><a href="#18-0-类加载器前置知识概述" class="headerlink" title="18.0 类加载器前置知识概述"></a>18.0 类加载器前置知识概述</h3><p><strong>类加载的时机</strong></p>
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包括：</p>
<p>加载，验证，准备，解析，初始化，使用和卸载 七个阶段</p>
<h4 id="18-0-1-加载"><a href="#18-0-1-加载" class="headerlink" title="18.0.1 加载"></a><strong>18.0.1 加载</strong></h4><p>加载是类加载过程的一个阶段，加载阶段需要完成以下三件事情</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区，这个类的各种数据的访问入口。</li>
</ul>
<p>任何类被使用时，系统都会为之建立一个java.lang.Class对象</p>
<h4 id="18-0-2-连接"><a href="#18-0-2-连接" class="headerlink" title="18.0.2 连接"></a><strong>18.0.2 连接</strong></h4><ul>
<li><p>验证阶段：用于检测被加载的类是否有正确的内部结构【符合JVM规范】。【不是必要阶段，可省略】</p>
</li>
<li><p>准备阶段：负责为类的类变量分配内存，设置默认初始化值。</p>
<ul>
<li><p>这时候进行的内存分配仅包含类变量（被static修饰的变量），不包括实例变量，实例变量将会在对象实例化时随对象一起分配在Java堆中。</p>
</li>
<li><p>这里的初始值“通常情况”下时数据类型的零值</p>
</li>
<li><p>```java<br>public staatic int value = 123<br>value在准备阶段过后 初始值为0，而非123</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 解析阶段：将常量池内的符号引用替换为直接引用</span><br><span class="line"></span><br><span class="line">  - 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。与虚拟机的内存布局无关</span><br><span class="line">  - 直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。与虚拟机的内存布局有关。如果有直接引用了，那么目标一定在内存中！</span><br><span class="line"></span><br><span class="line">#### 18.0.3 初始化</span><br><span class="line"></span><br><span class="line">类加载过程的最后一步。到了初始化阶段，才开始执行类中定义的Java程序代码（或者是是字节码）</span><br><span class="line"></span><br><span class="line">**对类变量进行初始化**</span><br><span class="line"></span><br><span class="line">**类的初始化步骤**</span><br><span class="line"></span><br><span class="line">- 假如类还未被加载和连接，则程序先加载并连接该类</span><br><span class="line">- 假如该类的直接父类还未被初始化，则先初始化其直接父类</span><br><span class="line">- 假如父类中有初始化语句，则系统依次执行这些初始化语句</span><br><span class="line"></span><br><span class="line">**类的初始化时机**【视频中的】</span><br><span class="line"></span><br><span class="line">- 创建类的实例</span><br><span class="line">- 调用类的类方法</span><br><span class="line">- 访问类或接口的类的变量，或者为该类变量赋值</span><br><span class="line">- 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</span><br><span class="line">- 初始化某个类的子类</span><br><span class="line">- 直接使用java.exe命令运行某个主类</span><br><span class="line"></span><br><span class="line">### 18.1 类加载器</span><br><span class="line"></span><br><span class="line">#### **18.1.1 类加载器作用**</span><br><span class="line"></span><br><span class="line">- 负责将.class文件加载到内存中，并为之生成对应的java.lang.Class对象</span><br><span class="line"></span><br><span class="line">#### **18.1.2 JVM的类加载机制**</span><br><span class="line"></span><br><span class="line">- 全盘负责：当一个类加载器负责加载某个Class时，该Class所依赖和引用的其他Class也将由该类加载器负责载入，除非显示使用另一个类加载器来载入</span><br><span class="line">- 父类委托：当一个类加载器负责某个Class时，先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</span><br><span class="line">- 缓存机制：保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜索该Class，只有当缓存中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存储到缓存区。</span><br><span class="line"></span><br><span class="line">#### **18.1.3 ClassLoader：**</span><br><span class="line"></span><br><span class="line">- 负责加载类的对象</span><br><span class="line"></span><br><span class="line">#### **18.1.4 Java运行时的内置类加载器**</span><br><span class="line"></span><br><span class="line">- **Bootstrap class loader**：它是虚拟机的内置类加载器，通常表示为null，并且没用父</span><br><span class="line">- **Platform class loader**：平台类加载器可以看到所有平台类，平台类包括由平台类加载器或其祖先定义的JavaSE平台API，其实现类和JDK特定的运行时类</span><br><span class="line">- **System class loader**：也被称为应用程序类加载器，与平台类加载器不同，系统类加载器通常定义应用程序类路径，模块路径和JDK特定工具上的类</span><br><span class="line">- 类加载器的继承关系：System的父加载器为Platform，而Platform的父加载器为Bootstrap</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Test</span><br><span class="line">public void fn1()&#123;</span><br><span class="line">    // 获得系统加载</span><br><span class="line">    ClassLoader c = ClassLoader.getSystemClassLoader();</span><br><span class="line">    System.out.println(c);//sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line"></span><br><span class="line">    //获得父类加载</span><br><span class="line">    ClassLoader c2 = c.getParent();</span><br><span class="line">    System.out.println(c2);//sun.misc.Launcher$ExtClassLoader@4a574795</span><br><span class="line"></span><br><span class="line">    //获得父类加载</span><br><span class="line">    ClassLoader c3 = c2.getParent();</span><br><span class="line">    System.out.println(c3);// null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="18-2-反射概述"><a href="#18-2-反射概述" class="headerlink" title="18.2 反射概述"></a>18.2 反射概述</h3><p>​        Java的反射机制是指在运行时去获取一个类的变量和方法信息，然后通过获取到的信息来创建对象，从而调用方法的一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍然可以扩展。</p>
<h3 id="18-3-反射操作"><a href="#18-3-反射操作" class="headerlink" title="18.3 反射操作"></a>18.3 反射操作</h3><h4 id="18-3-1-获取Class类的对象"><a href="#18-3-1-获取Class类的对象" class="headerlink" title="18.3.1 获取Class类的对象"></a>18.3.1 获取Class类的对象</h4><p>要使用反射，先要获取该类的字节码文件对象</p>
<ul>
<li>使用类的class属性获取Class对象</li>
<li>调用对象的getClass()方法，该方法是Object类中的方法，所有Java对象都可以调用该方法</li>
<li>使用Class类中的静态方法forName(String className) 传入的是完整包名路径</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getClazz</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 最方便</span></span><br><span class="line">    Class&lt;Student&gt; c1 = Student.class;</span><br><span class="line">    Class&lt;Student&gt; c2 = Student.class;</span><br><span class="line">    System.out.println(c1 == c2); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    Student s = <span class="keyword">new</span> Student();</span><br><span class="line">    Class&lt;? extends Student&gt; c3 = s.getClass();</span><br><span class="line">    System.out.println(c2 == c3); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 灵活 可以把xx写在配置文件中</span></span><br><span class="line">    Class&lt;?&gt;  c4 = Class.forName(<span class="string">&quot;com.bbxx.demo1.Student&quot;</span>);</span><br><span class="line">    System.out.println(c3 == c4); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="18-3-2-获取构造方法"><a href="#18-3-2-获取构造方法" class="headerlink" title="18.3.2 获取构造方法"></a>18.3.2 获取构造方法</h4><ul>
<li><strong>自行查看api【暴力访问时需要setAccessible（true）】</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConstructors</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;Student&gt; c1 = Student.class;</span><br><span class="line">    <span class="comment">// 获得指定的构造方法</span></span><br><span class="line">    Constructor&lt;Student&gt; con1 = c1.getConstructor(String.class,String.class,<span class="keyword">int</span>.class);</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    Student student = con1.newInstance(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;swx&quot;</span>, <span class="number">15</span>);</span><br><span class="line">    System.out.println(student);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得所有非私有构造方法</span></span><br><span class="line">    Constructor&lt;?&gt;[] con2 = c1.getConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor c: con2 )&#123;</span><br><span class="line">        System.out.println(c.getParameterTypes().length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力反射</span></span><br><span class="line">    Constructor&lt;Student&gt; c3 = c1.getDeclaredConstructor(String.class);</span><br><span class="line">    <span class="comment">// 取消访问检查</span></span><br><span class="line">    c3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Student s3 = c3.newInstance(<span class="string">&quot;xx&quot;</span>);</span><br><span class="line">    System.out.println(s3.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="18-3-3-获取成员变量"><a href="#18-3-3-获取成员变量" class="headerlink" title="18.3.3  获取成员变量"></a>18.3.3  获取成员变量</h4><table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">方法说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>getFields（）</code></td>
<td align="center">获得所有公共字段（public修饰的）</td>
</tr>
<tr>
<td align="center"><code>getDeclaredFields（）</code></td>
<td align="center">获得所有字段（包括protected private）</td>
</tr>
<tr>
<td align="center"><code>age.set(student,18);</code></td>
<td align="center">为student对象的age字段设置值18</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFiled</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;Student&gt; stu = Student.class;</span><br><span class="line">    <span class="comment">// 获得所有公有字段。public修饰的</span></span><br><span class="line">    Field[] fields = stu.getFields();</span><br><span class="line">    <span class="keyword">for</span> (Field f: fields) &#123;</span><br><span class="line">        System.out.println(f.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;**********&quot;</span>);</span><br><span class="line">    <span class="comment">// 获得所有字段 包括 protected private</span></span><br><span class="line">    Field[] declaredFields = stu.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field f: declaredFields) &#123;</span><br><span class="line">        System.out.println(f.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;**********&quot;</span>);</span><br><span class="line">    <span class="comment">// 给student对象的age字段赋值为18</span></span><br><span class="line">    Student student = stu.newInstance();</span><br><span class="line">    Field age = stu.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    age.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    age.set(student,<span class="number">18</span>);</span><br><span class="line">    System.out.println(student.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="18-3-4-获取成员方法"><a href="#18-3-4-获取成员方法" class="headerlink" title="18.3.4 获取成员方法"></a>18.3.4 获取成员方法</h4><table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Method[] getMethods()</code></td>
<td align="left">返回所有公共成员方法对象的数组，包 括继承的</td>
</tr>
<tr>
<td align="left"><code>Method[] getDeclaredMethods()</code></td>
<td align="left">返回所有成员方法对象的数组，不包括 继承的</td>
</tr>
<tr>
<td align="left"><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></td>
<td align="left">返回单个公共成员方法对象</td>
</tr>
<tr>
<td align="left"><code>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code></td>
<td align="left">返回单个成员方法对象</td>
</tr>
</tbody></table>
<h4 id="18-3-5-反射越过泛型检查"><a href="#18-3-5-反射越过泛型检查" class="headerlink" title="18.3.5 反射越过泛型检查"></a>18.3.5 反射越过泛型检查</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refelectDemo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// list.add(&quot;123&quot;); 抱错，有泛型检查</span></span><br><span class="line">    Class&lt;? extends ArrayList&gt; clazz = list.getClass();</span><br><span class="line">    <span class="comment">// 是Object.class</span></span><br><span class="line">    Method add = clazz.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">    add.invoke(list,<span class="string">&quot;asdf&quot;</span>);</span><br><span class="line">    System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第十九章-函数式编程"><a href="#第十九章-函数式编程" class="headerlink" title="第十九章 函数式编程"></a>第十九章 函数式编程</h2><h3 id="19-1-体验Lambda表达式"><a href="#19-1-体验Lambda表达式" class="headerlink" title="19.1 体验Lambda表达式"></a>19.1 体验Lambda表达式</h3><h3 id="19-2-Lambda表达式的标准格式"><a href="#19-2-Lambda表达式的标准格式" class="headerlink" title="19.2 Lambda表达式的标准格式"></a>19.2 Lambda表达式的标准格式</h3><ul>
<li><p>Lambda表达式的代码分析</p>
<ul>
<li>() 里面没用内容，可以看成是方法形式参数为空！</li>
<li><strong>-&gt;</strong> 用箭头指向后面要做的事情！</li>
<li>{ } 包含一段代码，称之为代码块，可以看成是方法体中的内容！</li>
</ul>
</li>
<li><p>Lambda表达式的格式</p>
<ul>
<li>格式：（形式参数）-&gt; （代码）。</li>
<li>形式参数：如果有多个参数，参数之间用逗号隔开；如果没用参数，留空即可。</li>
<li><strong>-&gt;</strong> ：由英文中画线和大于符号组成，固定写法，代表指向动作。</li>
<li>代码块：是我们具体要做的事情，也就是以前我们写法的方法体内容。</li>
</ul>
</li>
</ul>
<h3 id="19-3-Lambda表达式的练习"><a href="#19-3-Lambda表达式的练习" class="headerlink" title="19.3 Lambda表达式的练习"></a>19.3 Lambda表达式的练习</h3><ul>
<li><p>使用前提</p>
<ul>
<li>有一个接口</li>
<li>接口中有且仅有一个抽象方法</li>
</ul>
</li>
<li><p>练习一</p>
<ul>
<li>定义一个接口Eatable，里面定义一个抽象方法：void eat（）；</li>
<li>定义一个测试类，测试类中提供两个方法<ul>
<li>一个是useEatable（Eatable e）</li>
<li>一个是主方法，在主方法中调用useEatable</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EatableImpl</span> <span class="keyword">implements</span> <span class="title">Eatable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat eat eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EatableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 常规方式</span></span><br><span class="line">        EatableImpl eatable = <span class="keyword">new</span> EatableImpl();</span><br><span class="line">        useEatable(eatable);</span><br><span class="line">        <span class="comment">// 匿名内部类写法</span></span><br><span class="line">        useEatable(<span class="keyword">new</span> Eatable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat eat eat&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 记忆方法</span></span><br><span class="line"><span class="comment">         *  因为只有一个抽象方法，所以不用写方法名称！</span></span><br><span class="line"><span class="comment">         *  （）没用参数就空着，有就写！</span></span><br><span class="line"><span class="comment">         *  -&gt;&#123;&#125;指向要执行的代码块</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        useEatable(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useEatable</span><span class="params">(Eatable e)</span> </span>&#123;</span><br><span class="line">        e.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>练习二</p>
<ul>
<li>定义一个接口Flyable，里面定义一个抽象方法：void fly（String s）；</li>
<li>定义一个测试类，测试类中提供两个方法<ul>
<li>一个是<code>useFlyable（Flyable f）</code></li>
<li>一个是主方法，在主方法中调用useFlyable</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyableImpl</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fly fly fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        useFlyable((String str) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            System.out.println(<span class="string">&quot;Fly&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出</span></span><br><span class="line"><span class="comment">         * 风和日丽，晴空万里123</span></span><br><span class="line"><span class="comment">         * Fly</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 风和日丽，晴空万里被赋值给了lambda表达式中的String str。两个参数的情形也是一样的 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useFlyable</span><span class="params">(Flyable e,String s)</span> </span>&#123;</span><br><span class="line">        e.fly(<span class="string">&quot;风和日丽，晴空万里&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-4-Lambda表达式的省略模式"><a href="#19-4-Lambda表达式的省略模式" class="headerlink" title="19.4 Lambda表达式的省略模式"></a>19.4 Lambda表达式的省略模式</h3><p><strong>（）中的数据类型可以省略！但是有多个参数的情况下，不能只省略一个！要省略就都省略！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （）中的数据类型可以省略！</span></span><br><span class="line">useFlyable((s) -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    System.out.println(<span class="string">&quot;Fly&quot;</span>);</span><br><span class="line">&#125;,<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>（）中如果参数只有一个，那么小括号可以省略</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useFlyable(s -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;,<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>如果代码块的语句只有一条，可以省略大括号和分号</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useFlyable(s -&gt; System.out.println(s) ,<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果有return，renturn也要省略掉</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userAddable((x,y) -&gt; x+y);</span><br></pre></td></tr></table></figure>

<h3 id="19-5-Lambda-表达式的注意事项"><a href="#19-5-Lambda-表达式的注意事项" class="headerlink" title="19.5 Lambda 表达式的注意事项"></a>19.5 Lambda 表达式的注意事项</h3><ul>
<li><p>使用lambda必须要有接口，并且接口中有且仅有一个抽象方法</p>
</li>
<li><p>必须有上下文环境，才能推导出Lambda对于的接口</p>
<ul>
<li>根据局部变量的赋值得知Lambda对应的接口：Runnable r = () -&gt; System.out.println(“Lambda表达式”)；</li>
<li>根据调用方法的参数得知Lambda对应的接口：new Thread( () - &gt;System.out.println(“Lambda表达式”) ).start();</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        useInter(() -&gt; System.out.println(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">        <span class="comment">// 直接写没用上下文环境 直接生成本地变量是Runnable</span></span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">                System.out.println(<span class="string">&quot;hello world 2&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useInter</span><span class="params">(Inter i)</span> </span>&#123;</span><br><span class="line">        i.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-6-Lambda表达式和你们内部类的区别"><a href="#19-6-Lambda表达式和你们内部类的区别" class="headerlink" title="19.6 Lambda表达式和你们内部类的区别"></a>19.6 Lambda表达式和你们内部类的区别</h3><ul>
<li>匿名内部类调用方法的形参可以是：类，抽象类，接口</li>
<li>Lambda调用方法的形参必须是接口</li>
<li>匿名内部类编译时会生成一个单独的class文件。lambda表达式不会，它对应的字节码会在运行时动态生成。</li>
</ul>
<h2 id="第二十章-接口组成更新"><a href="#第二十章-接口组成更新" class="headerlink" title="第二十章 接口组成更新"></a>第二十章 接口组成更新</h2><h4 id="概述：接口的组成"><a href="#概述：接口的组成" class="headerlink" title="概述：接口的组成"></a><strong>概述：接口的组成</strong></h4><ul>
<li><p>常量</p>
<ul>
<li>```<br>public static final<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 抽象方法</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    public abstract</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>默认方法（jdk 8）</p>
<ul>
<li>```<br>public default void walk(){ System.out.println(“hello”); }<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - **default可以不被重写。方便在不影响已有接口的情况下更新接口**</span><br><span class="line"></span><br><span class="line">- 静态方法（jdk 8）</span><br><span class="line"></span><br><span class="line">- 私有方法（jdk 9）</span><br><span class="line"></span><br><span class="line">### 20.1 方法引用</span><br><span class="line"></span><br><span class="line">在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿参数做操作</span><br><span class="line"></span><br><span class="line">若在Lambda中所指的的操作方案，已经有地方存在相同的方案，这时候是没用必要再写重复逻辑的。</span><br><span class="line"></span><br><span class="line">那如何使用已经存在的方案？</span><br><span class="line"></span><br><span class="line">使用方法引用来使用已经存在的方案！</span><br><span class="line"></span><br><span class="line">- 方法引用符号</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public interface Animal &#123;</span><br><span class="line">    void say(Object o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Printable &#123;</span><br><span class="line">    void printString(String s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PrintableDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 常规写法</span><br><span class="line">        userPrintable(s -&gt; System.out.println(s));</span><br><span class="line">        // 方法引用符 ，：：   其实方法应用是直接把参数传给了这个方法【print】</span><br><span class="line">        userPrintable(System.out::print);</span><br><span class="line">        // 可推导的就是可省略的</span><br><span class="line">        useAnimal(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 我要打印数据</span><br><span class="line">    private static void userPrintable(Printable p) &#123;</span><br><span class="line">        p.printString(&quot;hehahhh&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void useAnimal(Animal a)&#123;</span><br><span class="line">        a.say(new Object());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h5 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h5><ul>
<li><p>格式：类名：：静态方法</p>
</li>
<li><p>示例：Integer::parseInt（）</p>
</li>
</ul>
</li>
<li><p>练习</p>
<ul>
<li>定义一个接口（Converter），定义抽象方法int convert(String s)</li>
<li>定义测试类</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Convert</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">convert</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        useConver(Integer::parseInt,<span class="string">&quot;105&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// lambda表达式被类方法替代的时候，它的形式参数全部传递给静态方法作为参数！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useConver</span><span class="params">(Convert c,String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> convert = c.convert(str);</span><br><span class="line">        System.out.println(convert*<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>特定对象的实例方法引用</strong></p>
<ul>
<li>格式：对象：：成员方法</li>
<li>示例：“HelloWorld”.toUpperCase</li>
</ul>
</li>
<li><h5 id="类的任意对象的实例方法引用"><a href="#类的任意对象的实例方法引用" class="headerlink" title="类的任意对象的实例方法引用"></a>类的任意对象的实例方法引用</h5><ul>
<li><p>格式：类名：：成员方法</p>
</li>
<li><p>示例：String::substring</p>
</li>
<li><p>格式：类名：：成员方法</p>
</li>
<li><p>示例：String::substring</p>
</li>
</ul>
</li>
<li><h5 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h5><ul>
<li><p>格式：<strong>类名::new</strong> ，</p>
</li>
<li><p>示例： () -&gt; new ArrayList<String>() 等价于 ArrayList<String>::new，代码示例：</p>
</li>
<li><p>```java<br>Supplier&lt;List<String>&gt; supplier1= () -&gt; new  ArrayList<String>();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 20.1 函数式接口</span><br><span class="line"></span><br><span class="line">有且仅有一个抽象方法的接口</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface MyInterface &#123;</span><br><span class="line">    void say();</span><br><span class="line">    default void saa()&#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以不写注解，但是写注解可以检测到是否只有一个抽象方法，安全些。</span><br><span class="line">// 如果接口时函数式接口，编译通过！</span><br><span class="line">// 建议加上这个注解</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="20-1-1-函数式接口作为返回值"><a href="#20-1-1-函数式接口作为返回值" class="headerlink" title="20.1.1 函数式接口作为返回值"></a>20.1.1 函数式接口作为返回值</h4><p><strong>return 推到式就可以了</strong></p>
<h4 id="20-1-2-常用的函数式接口"><a href="#20-1-2-常用的函数式接口" class="headerlink" title="20.1.2 常用的函数式接口"></a>20.1.2 常用的函数式接口</h4><ul>
<li><p><code>Java8</code>在<code>java.util.function</code>包下预定义了大量的函数式接口</p>
</li>
<li><p><strong>Supplier接口</strong></p>
<ul>
<li>Supplier<T>：包含一个无参的方法</li>
<li>T get（）：获得结果</li>
<li>该方法不需要参数，它会按照某种实现逻辑（由Lambda表达式实现）返回一个数据</li>
<li>Supplier<T>接口也被称为生产型接口，如果我们指定了接口的泛型式是什么类型，那么接口中的get（）方法就会产生什么类型的数据供我们使用！</li>
<li><strong>简单说来，他就是一个容易，用来存Lambda表达式生成的数据的。可用get方法得到这个生成的数据</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupplierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String string = getString(() -&gt; <span class="string">&quot;lqx&quot;</span>);<span class="comment">// 生成String</span></span><br><span class="line">        Integer integer = getInteger(() -&gt; <span class="number">20</span> + <span class="number">50</span>);<span class="comment">// 生成int</span></span><br><span class="line">        System.out.println(string);</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成Supplier示例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Supplier&lt;Student&gt; s1 = Student::<span class="keyword">new</span>; <span class="comment">// 生成 对象放进去</span></span><br><span class="line">        Student student = s1.get(); <span class="comment">// 获得这个对象</span></span><br><span class="line">        System.out.println(student.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回integer</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title">getInteger</span><span class="params">(Supplier&lt;Integer&gt; sup)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回String</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(Supplier&lt;String&gt; sup)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>Consumer接口</strong></p>
<ul>
<li>Consumer<T>：包含两个方法</li>
<li>void accept(T t)：对给的的参数执行此操作</li>
<li>default Consumer<T>andThen(Consumer after)：返回一个组合的Consumer，依次执行此操作，然后执行after操作</li>
<li>Consumer<T>接口也被称为消费型接口，它消费数据的数据类型由泛型指定</li>
<li><strong>大概意思就是，你定义消费规则。然后调用它的消费方法，他会按这个消费规则进行消费</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Consumer&lt;Integer&gt; c = x -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        c.accept(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>Predicate接口</strong></p>
<ul>
<li><p>Predicate 接口是一个谓词型接口，其实，这个就是一个类似于 bool 类型的判断的接口。</p>
</li>
<li><p>Predicate常用的四个方法</p>
<ul>
<li><p>```java<br>boolean test(T t) 对给定参数进行逻辑判断，判断表达式由Lambda实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  default Predicate&lt;T&gt;negate(); 返回一个逻辑的否定， 对应逻辑非</span><br></pre></td></tr></table></figure></li>
<li><p>```java<br>default Predicate<T>and(Predicate other) 返回一个组合逻辑判断，对应短路与</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  default Predicate&lt;T&gt;or(Predicate other) 返回一个组合判断，对应短路或</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Predicate常用于判断参数是否满足xx条件</strong></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Predicate&lt;String&gt; pre = (s) -&gt;  s .equals(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">        System.out.println(pre.test(<span class="string">&quot;ss&quot;</span>));</span><br><span class="line">        System.out.println(pre.negate().test(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Predicate&lt;String&gt; pre1 = (s) -&gt;  s .equals(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">        Predicate&lt;String&gt; pre2 = (s) -&gt;  s .equals(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">        <span class="comment">// test(参数) 这个参数是赋值给s的 pre1 和 pre2 是否都等于hello</span></span><br><span class="line">        System.out.println(pre1.and(pre2).test(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Predicate&lt;String&gt; pre1 = (s) -&gt;  s .equals(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">        Predicate&lt;String&gt; pre2 = (s) -&gt;  s .equals(<span class="string">&quot;123&quot;</span>) ;</span><br><span class="line">        <span class="comment">// 把hello 赋值给s pre1 和 pre2 是否满足他们的比较关系</span></span><br><span class="line">        System.out.println(pre1.or(pre2).test(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用lambda筛选数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] strArray = &#123;<span class="string">&quot;理解,30&quot;</span>, <span class="string">&quot;wul123i,20&quot;</span>,<span class="string">&quot;wui,20&quot;</span>&#125;;</span><br><span class="line">    ArrayList&lt;String&gt; strings = myFilter(strArray, s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>].length() &gt;= <span class="number">2</span>, s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt; <span class="number">23</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;ss&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s : strings)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">myFilter</span><span class="params">(String[] strArray, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : strArray) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre1.and(pre2).test(s)) &#123;</span><br><span class="line">            list.add(s);</span><br><span class="line">            System.out.println(<span class="string">&quot;asfs&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>Function接口</strong></p>
<ul>
<li><p>Function 接口是一个功能型接口，是一个转换数据的作用。</p>
</li>
<li><p>Function 接口实现 <code>apply</code> 方法来做转换。</p>
</li>
<li><p>常用方法</p>
<ul>
<li>R apply（T t）将此函数应用于给定的参数</li>
<li>default<V> Function andThen(Function after) ：返回一个组合函数，首先将函数应用于输入，然后将after函数应用于结果</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        convert(<span class="string">&quot;132&quot;</span>, Integer::parseInt);</span><br><span class="line">        convert(<span class="string">&quot;132&quot;</span>, Integer::parseInt);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接使用 String是传入数据的类型，Integer是apply处理后返回的数据类型</span></span><br><span class="line">        Function&lt;String,Integer&gt; fn = (s)-&gt;Integer.parseInt(s)*<span class="number">10</span>;</span><br><span class="line">        Integer apply = fn.apply(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">        System.out.println(apply);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要求 把一个字符串转换为int类型并乘以10输出</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">convert</span><span class="params">(String s, Function&lt;String,Integer&gt; fun)</span></span>&#123;</span><br><span class="line">        Integer apply = fun.apply(s);</span><br><span class="line">        System.out.println(apply*<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="20-3-体验Stream流"><a href="#20-3-体验Stream流" class="headerlink" title="20.3 体验Stream流"></a>20.3 体验Stream流</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;兆三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;科学三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;学习三&quot;</span>);</span><br><span class="line">        <span class="comment">// stream 筛选出符合条件的数据进行输出</span></span><br><span class="line">        list.stream().filter((ss) -&gt; ss.length() == <span class="number">3</span>).forEach(ss -&gt; System.out.println(ss));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-4-Stream流的简单Demo"><a href="#20-4-Stream流的简单Demo" class="headerlink" title="20.4 Stream流的简单Demo"></a>20.4 Stream流的简单Demo</h3><p><strong>Stream流的使用</strong></p>
<ul>
<li><p>生成流</p>
<ul>
<li>通过数据源（集合，数组等）生成流</li>
<li><code>list.stream();</code></li>
</ul>
</li>
<li><p>中间操作</p>
<ul>
<li>一个流后面可以跟0个或多个中间操作，其主要是打开流，然后返回一个新的流，交给下一个操作使用</li>
<li><code>filter()</code></li>
</ul>
</li>
<li><p>终结操作</p>
<ul>
<li><p><strong>一个流只能有一个终结操作，当这个操作执行后流会被关闭</strong>【forEach是void，无返回值的意思】</p>
</li>
<li><p>```java<br>public class StreamDemo {</p>
<pre><code>@Test
public void fn1() &#123;
    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
    list.add(&quot;张三&quot;);
    list.add(&quot;李三&quot;);
    list.add(&quot;兆三&quot;);
    list.add(&quot;科学三&quot;);
    list.add(&quot;学习三&quot;);
    // stream 筛选出符合条件的数据进行输出
    list.stream().filter((ss) -&gt; ss.length() == 3).forEach(ss -&gt; System.out.println(ss));
    Stream&lt;String&gt; stringStream = list.stream().filter((ss) -&gt; ss.length() == 3);
    Assert.assertNotNull(stringStream);// 通过测试，不为空
    stringStream.forEach(System.out::print);
    Assert.assertNotNull(stringStream);// 通过测试，不为空
&#125;

@Test
public void fn4() &#123;
    ArrayList&lt;String&gt; arr = new ArrayList&lt;&gt;();
    arr.add(&quot;1111&quot;);
    arr.add(&quot;2222&quot;);
    arr.add(&quot;3333&quot;);
    arr.add(&quot;4444&quot;);
    arr.add(&quot;5555&quot;);
    arr.add(&quot;6666&quot;);
    arr.add(&quot;7777&quot;);
    Stream&lt;String&gt; limit = arr.stream().limit(5);
    Stream&lt;String&gt; skip = arr.stream().skip(3);
    Stream&lt;String&gt; concat = Stream.concat(limit, skip);
    // stream has already been operated upon or closed
    // concat.forEach(System.out::println);
    System.out.println(&quot;***********&quot;);
    concat.distinct().forEach(System.out::println);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 20.5 Stream流的生成方式</span><br><span class="line"></span><br><span class="line">#### **20.5.1 Stream流的常见生成方式**</span><br><span class="line"></span><br><span class="line">- Collection体系的集合可以使用默认方法stream（）生成流</span><br><span class="line">  - default Stream&lt;E&gt;() stream()</span><br><span class="line">- Map体系的集合间接生成流</span><br><span class="line">- 数组可以通过Stream接口的静态方法of(T ...value)生成流</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Test</span><br><span class="line">public void fn1() &#123;</span><br><span class="line">    // Collection的 直接生成流</span><br><span class="line">    ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();</span><br><span class="line">    Stream&lt;String&gt; arrStream = arr.stream();</span><br><span class="line"></span><br><span class="line">    HashSet&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">    Stream&lt;String&gt; setStream = set.stream();</span><br><span class="line"></span><br><span class="line">    // Map体系间接的生成流</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; mapStream = map.entrySet().stream();</span><br><span class="line">    mapStream.filter(s -&gt; s.getKey().length() &gt; 2).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    // 数组变为Stream流</span><br><span class="line">    String[] str = &#123;&quot;12313&quot;, &quot;asda&quot;&#125;;</span><br><span class="line">    Stream&lt;String&gt; strSteam1 = Stream.of(str);</span><br><span class="line">    Stream&lt;String&gt; strSteam2 = Stream.of(&quot;123&quot;, &quot;!231&quot;, &quot;!!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="20-5-2-中间流操作"><a href="#20-5-2-中间流操作" class="headerlink" title="20.5.2 中间流操作"></a>20.5.2 中间流操作</h4><ul>
<li><p><strong>filter</strong>：过滤，满足条件的保留，不满足的不保留。传入的是Predicate</p>
</li>
<li><p><strong>limit</strong>：取前xx个元素</p>
</li>
<li><p><strong>skip</strong>：跳过前xx个元素</p>
</li>
<li><p><strong>concat</strong>：<code>concat(Steam a,Stream b)</code> 合并a，b两个流</p>
</li>
<li><p><strong>distinct</strong>：基于<code>hashCode（）</code>和<code>equals（）</code>去重</p>
</li>
<li><p><strong>sorted</strong>：<strong>按照指的规则排序，无参数按照自然排序，有参数按照指的排序规则</strong></p>
<ul>
<li>```java<br>sorted(Comparator&lt;? super T&gt; comparator)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **mapToInt**：将xx转为intStream</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>forEach</strong>：遍历元素</p>
<ul>
<li><p>属于终结方法</p>
</li>
<li><p>```java<br>void forEach(Consumer&lt;? super T&gt; action);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **count**：返回元素总和</span><br><span class="line"></span><br><span class="line">  - 属于终结方法</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">// filter操作</span><br><span class="line">@Test</span><br><span class="line">public void fn2()&#123;</span><br><span class="line">    ArrayList&lt;Object&gt; arr = new ArrayList&lt;Object&gt;();</span><br><span class="line">    arr.add(new Object());</span><br><span class="line">    arr.add(new Object());</span><br><span class="line">    arr.add(&quot;!@#123&quot;);</span><br><span class="line">    //  Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</span><br><span class="line">    // 进行布尔判断，为真就保存？</span><br><span class="line">    arr.stream().filter(s-&gt;(s instanceof String)).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// limit和skip操作</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        arr.add(<span class="string">&quot;qeasfsa&quot;</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;789&quot;</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;/45662*&quot;</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;/asfg*&quot;</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;/阿斯弗*&quot;</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;/撒法发*&quot;</span>);</span><br><span class="line">        <span class="comment">// limit 取前三个元素</span></span><br><span class="line">        arr.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        <span class="comment">// skip 跳过前3个元素</span></span><br><span class="line">        arr.stream().skip(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;**********&quot;</span>);</span><br><span class="line">        <span class="comment">// 跳过两个，剩下的前三个输出</span></span><br><span class="line">        arr.stream().skip(<span class="number">2</span>).limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concat 和 distinct</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arr.add(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;2222&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;3333&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;4444&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;5555&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;6666&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;7777&quot;</span>);java</span><br><span class="line">        Stream&lt;String&gt; limit = arr.stream().limit(<span class="number">5</span>);</span><br><span class="line">    Stream&lt;String&gt; skip = arr.stream().skip(<span class="number">3</span>);</span><br><span class="line">    Stream&lt;String&gt; concat = Stream.concat(limit, skip);</span><br><span class="line">    <span class="comment">// stream has already been operated upon or closed</span></span><br><span class="line">    <span class="comment">// concat.forEach(System.out::println);</span></span><br><span class="line">    System.out.println(<span class="string">&quot;***********&quot;</span>);</span><br><span class="line">    concat.distinct().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sorted</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arr.add(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;22122&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;3332333&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;4123444&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;a5555&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;6dsf666&quot;</span>);</span><br><span class="line">    arr.add(<span class="string">&quot;7ds777&quot;</span>);</span><br><span class="line">    <span class="comment">//在测试一次</span></span><br><span class="line">    <span class="comment">// arr.stream().sorted().forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认从小到大排序。返回正数代表大！</span></span><br><span class="line">    arr.stream().sorted((s1, s2) -&gt; s1.length() - s2.length()).forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;***&quot;</span>);</span><br><span class="line">    <span class="comment">// 反过来就是从大到小</span></span><br><span class="line">    arr.stream().sorted((s1,s2)-&gt; s2.length()-s1.length()).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mapToInt</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;12&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;32&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;45&quot;</span>);</span><br><span class="line">    IntStream intStream = list.stream().mapToInt(Integer::parseInt);</span><br><span class="line">    <span class="keyword">int</span> sum = intStream.sum();</span><br><span class="line">    intStream.forEach(System.out::println);</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="20-5-3-Stream流的收集操作"><a href="#20-5-3-Stream流的收集操作" class="headerlink" title="20.5.3 Stream流的收集操作"></a>20.5.3 Stream流的收集操作</h4><p>对数据使用Stream流的方式进行操作后，把流中的数据收集到集合中</p>
<ul>
<li>R collect（Collector c）</li>
<li>参数是一个Collector接口</li>
<li>常用方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;12&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;32&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;45&quot;</span>);</span><br><span class="line">    <span class="comment">// 收集到List中</span></span><br><span class="line">    Stream&lt;String&gt; stream = list.stream().filter(s -&gt; s.length() &gt; <span class="number">3</span>);</span><br><span class="line">    List&lt;String&gt; collect = stream.collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集到Set中</span></span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    set.add(<span class="string">&quot;!2312313&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;!13&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;!453&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;!231&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;!412&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; Setstream = set.stream().filter(s -&gt; s.length() &gt; <span class="number">5</span>);</span><br><span class="line">    Setstream.collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集到Map中</span></span><br><span class="line">    <span class="comment">// 定义一个字符串数组，每一个字符串数据由姓名数据和年龄数据组合而成</span></span><br><span class="line">    String[] arra = &#123;<span class="string">&quot;xx,18&quot;</span>, <span class="string">&quot;ljw,20&quot;</span>, <span class="string">&quot;lh,23&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 得到年龄大于等于20的</span></span><br><span class="line">    Stream&lt;String&gt; age = Stream.of(arra).filter(s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt; <span class="number">19</span>);</span><br><span class="line">    <span class="comment">// 姓名作为key 年龄作为value</span></span><br><span class="line">    <span class="comment">// age.collect(key,value);</span></span><br><span class="line">    <span class="comment">// 年龄大于等于20的被封装成了map</span></span><br><span class="line">    Map&lt;String, String&gt; collect1 = age.collect(Collectors.toMap(s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>], s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]));</span><br><span class="line">    Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream1 = collect1.entrySet().stream();</span><br><span class="line">    stream1.forEach( s -&gt; System.out.println(s.getKey() + <span class="string">&quot;:&quot;</span> + s.getValue()) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二十一-JDBC"><a href="#二十一-JDBC" class="headerlink" title="二十一 JDBC"></a>二十一 JDBC</h2><h3 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h3><p>在 src 下放配置文件 <code>c3p0-config.xml</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/jdbc_demo<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>用 C3P0 获取数据库连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C3P0Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection connection = dataSource.getConnection();</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(<span class="string">&quot;select * from student&quot;</span>);</span><br><span class="line">        ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">            System.err.println(resultSet.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-Druid"><a href="#使用-Druid" class="headerlink" title="使用 Druid"></a>使用 Druid</h3><p>配置文件 druid.properties</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql:///jdbc_demo</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure>

<p>用 Druid 获取数据库连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">        properties.load(is);</span><br><span class="line">        DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        Connection connection = dataSource.getConnection();</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(<span class="string">&quot;select * from student&quot;</span>);</span><br><span class="line">        ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            System.out.println(resultSet.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resultSet == <span class="keyword">null</span>) resultSet.close();</span><br><span class="line">        <span class="keyword">if</span> (preparedStatement == <span class="keyword">null</span>) preparedStatement.close();</span><br><span class="line">        <span class="keyword">if</span> (connection == <span class="keyword">null</span>) connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"><span class="keyword">import</span> com.bbxx.nature.Student;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spring的jdbc模板操作</span></span><br><span class="line"><span class="comment"> * 需要依赖一个数据源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SprintJDBCTemplate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(DataSourceUtils.getDataSource());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> update = jdbcTemplate.update(<span class="string">&quot;update student set name=&#x27;xxx&#x27; where id=4&quot;</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> update = jdbcTemplate.update(<span class="string">&quot;insert into student(name,phone,address) values(?,?,?)&quot;</span>, <span class="string">&quot;liuj&quot;</span>, <span class="string">&quot;11112312&quot;</span>, <span class="string">&quot;aor you kou&quot;</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> liuj = jdbcTemplate.update(<span class="string">&quot;delete from student where name=?&quot;</span>, <span class="string">&quot;liuj&quot;</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>, liuj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只能是单个数据。封装为map集合。key为字段名，value为字段值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">querySingleForMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = jdbcTemplate.queryForMap(<span class="string">&quot;select * from student where id=?&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(map.keySet().size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多条结果集</span></span><br><span class="line"><span class="comment">     * 每天结果都封装为map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryListMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(<span class="string">&quot;select * from student&quot;</span>);</span><br><span class="line">        maps.stream().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Student&gt; query = jdbcTemplate.query(<span class="string">&quot;select * from student&quot;</span>, <span class="keyword">new</span> RowMapper&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Student <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                Student student = <span class="keyword">new</span> Student();</span><br><span class="line">                student.setId(resultSet.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                student.setAddress(resultSet.getString(<span class="string">&quot;address&quot;</span>));</span><br><span class="line">                student.setPhone(resultSet.getString(<span class="string">&quot;phone&quot;</span>));</span><br><span class="line">                student.setName(resultSet.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span> student;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 函数式编程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;Student&gt; query1 = jdbcTemplate.query(<span class="string">&quot;select * from student&quot;</span>, (resultSet,i)-&gt;&#123;</span><br><span class="line">            Student student = <span class="keyword">new</span> Student();</span><br><span class="line">            student.setId(resultSet.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">            student.setName(resultSet.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            student.setPhone(resultSet.getString(<span class="string">&quot;phone&quot;</span>));</span><br><span class="line">            student.setAddress(resultSet.getString(<span class="string">&quot;address&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> student;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        query1.stream().forEach(s-&gt;&#123;</span><br><span class="line">            System.out.println(s.getName()+s.getPhone());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String sql, RowMapper&lt;T&gt; rowMapper</span></span><br><span class="line"><span class="comment">     * 也可以传这个BeanPropertyRowMapper 用反射进行映射。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryList2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Student&gt; query = jdbcTemplate.query(<span class="string">&quot;select * from student&quot;</span>, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Student&gt;(Student.class));</span><br><span class="line">        query.stream().forEach(s-&gt;&#123;</span><br><span class="line">            System.out.println(s.getName());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryForObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Integer integer = jdbcTemplate.queryForObject(<span class="string">&quot;select count(1) from student&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataSourceUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties properties = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        InputStream is = DataSourceUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(is);</span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>) is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">            DataSource dataSource = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第三部分-加强"><a href="#第三部分-加强" class="headerlink" title="第三部分 加强"></a>第三部分 加强</h1><h2 id="第一章-枚举"><a href="#第一章-枚举" class="headerlink" title="第一章 枚举"></a>第一章 枚举</h2><h3 id="1-1-枚举的使用Demo"><a href="#1-1-枚举的使用Demo" class="headerlink" title="1.1 枚举的使用Demo"></a>1.1 枚举的使用Demo</h3><p>下面看一段骚气的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">judge</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;AAA&quot;</span>.equals(str))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AAA&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;BBB&quot;</span>.equals(str))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BBB&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;CCC&quot;</span>.equals(str))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CCC&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;DDD&quot;</span>.equals(str))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DDD&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>条件一多 就要该源码【扩展性弱】，有没有解决办法</li>
<li>代码看起来不优雅，有没有解决办法</li>
</ul>
<p><strong>枚举！</strong></p>
<blockquote>
<p><strong>第一版，用枚举替代if else</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接用枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RoleOperation1</span> </span>&#123;</span><br><span class="line">    ADMIN_POWER,</span><br><span class="line">    NORMAL_POWER,</span><br><span class="line">    SUPER_POWER</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为有返回值 所以这样定义</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RoleOperation2</span> </span>&#123;</span><br><span class="line">    ADMIN_POWER() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Admin power&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    NORMAL_POWER() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Normal power&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUPER_POWER() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Super power&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为有统一的方法，所以用接口定义规则</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">op</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  漂亮的枚举代码，虽然看起来长，复杂，但是拓展性特别强！</span></span><br><span class="line"><span class="comment">// 下面就是见证奇迹的时刻，优雅地用枚举替代if else。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RoleOperation</span> <span class="keyword">implements</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    ADMIN_POWER() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">op</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Admin power&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    NORMAL_POWER() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">op</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Normal power&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUPER_POWER() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">op</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Super power&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如此优雅的代码！！</span></span><br><span class="line">    <span class="comment">// 还有用工厂模式 策略模式的。感觉都不如枚举来的优雅。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">judge</span><span class="params">(String role)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RoleOperation.valueOf(role).op();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-枚举的常用方法"><a href="#1-2-枚举的常用方法" class="headerlink" title="1.2 枚举的常用方法"></a>1.2 枚举的常用方法</h3><table>
<thead>
<tr>
<th>values()</th>
<th>以数组形式返回枚举类型的所有成员</th>
</tr>
</thead>
<tbody><tr>
<td>valueOf()</td>
<td>将普通字符串转换为枚举实例</td>
</tr>
<tr>
<td>compareTo()</td>
<td>比较两个枚举成员在定义时的顺序</td>
</tr>
<tr>
<td>ordinal()</td>
<td>获取枚举成员的索引位置</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举中一些常用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeFunc</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Color[] values = Color.values();</span><br><span class="line">        <span class="keyword">for</span> (Color c : values) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  将普通字符串实例转换为枚举</span></span><br><span class="line">        Color blue = Color.valueOf(<span class="string">&quot;BLUE&quot;</span>);</span><br><span class="line">        System.out.println(blue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Color.BLUE.ordinal());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     public final int compareTo(E o) &#123;</span></span><br><span class="line"><span class="comment">     *         Enum&lt;?&gt; other = (Enum&lt;?&gt;)o;</span></span><br><span class="line"><span class="comment">     *         Enum&lt;E&gt; self = this;</span></span><br><span class="line"><span class="comment">     *         if (self.getClass() != other.getClass() &amp;&amp; // optimization</span></span><br><span class="line"><span class="comment">     *             self.getDeclaringClass() != other.getDeclaringClass())</span></span><br><span class="line"><span class="comment">     *             throw new ClassCastException();</span></span><br><span class="line"><span class="comment">     *         return self.ordinal - other.ordinal;</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// RED 和 BLUE比较， RED小于BLUE 返回负数 ；equals返回0；大于返回 正数</span></span><br><span class="line">        System.out.println(Color.RED.compareTo(Color.BLUE)); <span class="comment">// -1</span></span><br><span class="line">        System.out.println(Color.RED.compareTo(Color.GREEN));<span class="comment">// -2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Color.RED);</span><br><span class="line">        <span class="comment">// output RED</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    RED, BLUE, GREEN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二章-比较对象"><a href="#第二章-比较对象" class="headerlink" title="第二章 比较对象"></a>第二章 比较对象</h2><p><strong>Comparator和Comparable</strong></p>
<p>Comparable接口/ Comparator接口</p>
<ul>
<li>Comparator  函数式接口 jdk1.8引入</li>
<li>Comparable 普通接口</li>
</ul>
<h2 id="第三章-单元测试"><a href="#第三章-单元测试" class="headerlink" title="第三章 单元测试"></a>第三章 单元测试</h2><h3 id="3-1-单元测试的优点"><a href="#3-1-单元测试的优点" class="headerlink" title="3.1 单元测试的优点"></a>3.1 单元测试的优点</h3><p>保证的程序代码的正确性【语法上了逻辑上】。</p>
<h3 id="3-2单元测试的使用"><a href="#3-2单元测试的使用" class="headerlink" title="3.2单元测试的使用"></a>3.2单元测试的使用</h3><p>@Test</p>
<ul>
<li>@Before 无论Test是否出现异常，都会执行 【初始化资源】</li>
<li>@After 无论Test是否出现异常，都会执行 【销毁资源】</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JunitDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OutputStream outputStream;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO 流初始化完毕了&quot;</span>);</span><br><span class="line">        outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;junit.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单元测试判断数据的正确性</span></span><br><span class="line"><span class="comment">     * 一般用Assert里面的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 断言不为null  不是null则成功</span></span><br><span class="line">        Assert.assertNotNull(outputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO 流关闭了&quot;</span>);</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-单元测试原理"><a href="#3-3-单元测试原理" class="headerlink" title="3.3 单元测试原理"></a>3.3 单元测试原理</h3><h2 id="第四章-反射"><a href="#第四章-反射" class="headerlink" title="第四章 反射"></a>第四章 反射</h2><h3 id="4-1-反射概述"><a href="#4-1-反射概述" class="headerlink" title="4.1 反射概述"></a>4.1 反射概述</h3><p>反射可以把类的各个组成部分封装为其他对象。</p>
<p>反射，Java的高级特性，流行的框架基本都是基于反射的思想写成的。</p>
<p>Java反射机制是在程序的运行过程中，对于任何一个类，都能够知道它的所有属性和方法；对于任意一个对象，都能够知道它的所有属性和方法，**<span style="color:green">这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。</span>**</p>
<p>Java反射机制主要提供了以下这几个功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所有的成员变量和方法</li>
<li>在运行时调用任意一个对象的方法</li>
</ul>
<h3 id="4-2-反射的基本操作"><a href="#4-2-反射的基本操作" class="headerlink" title="4.2 反射的基本操作"></a>4.2 反射的基本操作</h3><h4 id="4-2-1-获取成员变量"><a href="#4-2-1-获取成员变量" class="headerlink" title="4.2.1 获取成员变量"></a>4.2.1 获取成员变量</h4><ul>
<li><code>File[] getFileds()</code> // <strong>获得所有公有字段，包括继承的</strong></li>
<li><code>Filed getFiled(String name)</code> // 获取指定name的</li>
<li><code>Filed[] getDeclaredFileds() </code>// 获取该类自己声明的，包括私有</li>
<li><code>Filed[] getDeclaredFileds(String name)</code> // 获取指定名称的</li>
</ul>
<h4 id="4-2-2-获取构造方法"><a href="#4-2-2-获取构造方法" class="headerlink" title="4.2.2 获取构造方法"></a>4.2.2 获取构造方法</h4><ul>
<li><p><code>Constructor&lt;?&gt;[] getConstructors()</code> // 获得所有公有构造器</p>
</li>
<li><p><code>Constructor&lt;?&gt; getConstructor(Class&lt;?&gt;...parameterTypes)</code> //获得指定参数的公有构造器</p>
</li>
<li><p><code>Constructor&lt;?&gt;[]getDeclaredConstructors()</code>// 获得所有私有构造器</p>
</li>
<li><p><code>Constructor&lt;T&gt;[]getDeclaredConstructors()</code>//  得指定参数的构造器【包括public~~~private 】</p>
</li>
</ul>
<h4 id="4-2-3-获取成员方法"><a href="#4-2-3-获取成员方法" class="headerlink" title="4.2.3 获取成员方法"></a>4.2.3 获取成员方法</h4><ul>
<li><p><code>Method[] getMethods()</code> // <strong>获得所有public修饰的方法，包括继承的</strong></p>
</li>
<li><p><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code> // 获得指定名称和参数类型的public修饰的方法</p>
</li>
<li><p><code>Method[] getDeclaredMethods()</code> //获得所有的私有方法</p>
</li>
<li><p><code>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code> // 获得指定名称和参数类型的方法</p>
</li>
</ul>
<h4 id="4-2-4-获取类名"><a href="#4-2-4-获取类名" class="headerlink" title="4.2.4 获取类名"></a>4.2.4 获取类名</h4><ul>
<li><code>String getName()</code> // 获得类全名<code>com.bbxx.junits.Son</code></li>
</ul>
<h4 id="4-2-5-几个重要的类"><a href="#4-2-5-几个重要的类" class="headerlink" title="4.2.5 几个重要的类"></a>4.2.5 几个重要的类</h4><blockquote>
<p><strong>Class类</strong></p>
</blockquote>
<p>每定义一个<code>java</code> <code>class</code> 实体都会产生一个Class对象。我们编写一个类，编译完成后，在生成的 <code>.class</code>文件中，就会产生一个Class对象，这个Class对象用于表示这个类的类型信息。Class中没有公共构造器，即Class对象不能被实例化。</p>
<blockquote>
<p><strong>Field类</strong></p>
</blockquote>
<p>Field类提供类或接口中单独字段的信息，以及对单独字段的动态访问。</p>
<blockquote>
<p><strong>Method类</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke(Object obj, Object... args)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>ClassLoader</code>类</strong></p>
</blockquote>
<p><strong><span style="color:green">ClassLoader类加载器！类加载器用来把类（class）装载进JVM的。ClassLoader使用的双亲委派模型来搜索加载类的，这个模型也就是双亲委派模型。</span></strong></p>
<p><strong><code>ClassLoader</code>的类继承图如下：</strong></p>
<img src="D:\69546\Documents\pics\JavaStrengthen\classLoader.png" style="float:left">

<h3 id="4-3-动态代理"><a href="#4-3-动态代理" class="headerlink" title="4.3 动态代理"></a>4.3 动态代理</h3><h4 id="4-3-1-作用"><a href="#4-3-1-作用" class="headerlink" title="4.3.1 作用"></a>4.3.1 作用</h4><p>运行时，动态创建一组指定的接口的实现类对象！（在运行时，创建实现了指定的一组接口的对象）</p>
<p>动态代理对比其他方法增强方式</p>
<img src="D:\69546\Documents\pics\JavaStrengthen\proxy.png" style="float:left">

<h4 id="4-3-2-基本Demo"><a href="#4-3-2-基本Demo" class="headerlink" title="4.3.2 基本Demo"></a>4.3.2 基本Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Object o = 方法(<span class="keyword">new</span> Class[]&#123; A.class, B.class &#125;)</span><br><span class="line">o 它实现了A和B两个接口！</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object proxyObject = Proxy.newProxyInstance(ClassLoader classLoader, Class[] interfaces, InvocationHandler h);</span><br></pre></td></tr></table></figure>

<ul>
<li>方法的作用：动态创建实现了interfaces数组中所有指定接口的实现类对象！</li>
<li><code>ClassLoader</code>：类加载器！<ul>
<li>它是用来加载器的，把.class文件加载到内存，形成Class对象！</li>
</ul>
</li>
<li><code>Class[ ] interfaces</code>：指定要实现的接口们。</li>
<li><code>InvocationHandler</code>：代理对象的所有方法（个别不执行，一般<code>nativate</code>方法不会执行，但是<code>hashCode</code>却会执行，好奇怪）都会调用<code>InvocationHadnler</code>的<code>invoke()</code>方法</li>
<li>动态代理的作用<ul>
<li>最终是学习<code>AOP</code>（面向切面编程），它与装饰者模式有点相似，它比装饰者模式更灵活（潜在含义，动态代理更难！）</li>
</ul>
</li>
</ul>
<p><strong>动态代理基本Demo</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">IBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;getName&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 获得类加载器</span></span><br><span class="line">        ClassLoader classLoader = person.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 获得被代理对象实现的接口</span></span><br><span class="line">        Class[] interfaces = person.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 实例化一个处理器 用于增强方法用的</span></span><br><span class="line">        InvocationHandler h = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                method.invoke(person, args);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        IBase p = (IBase) Proxy.newProxyInstance(classLoader, interfaces, h);</span><br><span class="line">        <span class="comment">// 获得代理类的名称 com.sun.proxy.$Proxy0</span></span><br><span class="line">        System.out.println(p.getClass().getName());</span><br><span class="line">        p.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-3-invoke解释"><a href="#4-3-3-invoke解释" class="headerlink" title="4.3.3 invoke解释"></a>4.3.3 invoke解释</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>这个invoke什么时候被调用？</strong></p>
<ul>
<li>在调用代理对象所实现接口中的方法时被调用！</li>
</ul>
<p><strong>参数解释</strong></p>
<ul>
<li><code>Object proxy</code>：当前对象，即代理对象！在调用谁的方法！</li>
<li><code>Method method</code>：当前被调用的方法（目标方法）</li>
<li><code>Object [ ] args</code>：实参</li>
<li>返回的是方法的返回值。</li>
</ul>
<img src="D:\69546\Documents\pics\JavaStrengthen\invoke_explain.png" style="float:left">

<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        ClassLoader classLoader = person.getClass().getClassLoader();</span><br><span class="line">        Class[] interfaces = person.getClass().getInterfaces();</span><br><span class="line">        System.out.println(interfaces.length);</span><br><span class="line">        InvocationHandler h = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Object retVal = method.invoke(person, args);</span><br><span class="line">                 <span class="comment">// 这个返回了，方法才有返回值 </span></span><br><span class="line">                <span class="keyword">return</span> retVal; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        IBase p = (IBase) Proxy.newProxyInstance(classLoader, interfaces, h);</span><br><span class="line">        p.say();</span><br><span class="line">        <span class="comment">// invoke返回null的话，这里的输出就是null</span></span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-模拟AOP"><a href="#4-4-模拟AOP" class="headerlink" title="4.4 模拟AOP"></a>4.4 模拟<code>AOP</code></h3><p><code>Spring AOP</code>，感受一下什么叫增强内容可变！</p>
<ul>
<li><code>ProxyFactory</code> 代理工厂</li>
<li><code>IBeforeAdvice</code> 前置通知接口【方法执行前调用前置】</li>
<li><code>IAfterAdvice</code> 后置通知接口【方法执行后调用后置】</li>
<li><code>IWaiter</code> 服务员类接口</li>
<li><code>ManWaiterImple</code> 具体的服务员类【对他进行增强】</li>
</ul>
<h2 id="第五章-注解"><a href="#第五章-注解" class="headerlink" title="第五章 注解"></a>第五章 注解</h2><p><strong>注解也叫元数据</strong>。是一种代码级别的说明，JDK1.5引入的特性，与类，接口，枚举是在同一层次。<strong>可声明在包，类，字段，方法，局部变量，方法参数等的前面</strong>，对这些元素进行说明。</p>
<p><strong>作用分类：</strong></p>
<p>1.代码分析，通过代码里标识的元数据对代码进行分析【结合反射技术】</p>
<p>2.编译检查，通过代码里标识的元数据让编译器能够实现机泵的编译检查【Override】</p>
<p>3.编写文档，通过代码里标识的元数据生成文档【生成文档doc文档】</p>
<h3 id="5-1-内置注解"><a href="#5-1-内置注解" class="headerlink" title="5.1 内置注解"></a>5.1 内置注解</h3><ul>
<li><code>Override</code>：检测被标注的是否继承自父类</li>
<li><code>Deprecated</code>：表示方法过时</li>
<li><code>SuppressWarnings</code>：压制警告<ul>
<li>一般传递参数all</li>
</ul>
</li>
</ul>
<h3 id="5-2-自定义注解"><a href="#5-2-自定义注解" class="headerlink" title="5.2 自定义注解"></a>5.2 自定义注解</h3><blockquote>
<p><strong>元注解<code>public @interface annotationName&#123;&#125;</code></strong></p>
</blockquote>
<p>反编译发现，本质就是一个接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> <span class="keyword">extends</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-1-属性的返回值"><a href="#5-2-1-属性的返回值" class="headerlink" title="5.2.1 属性的返回值"></a>5.2.1 属性的返回值</h4><p><strong>基本数据类型    String    枚举    注解    以上类型的数组</strong></p>
<h4 id="5-2-2-赋值问题"><a href="#5-2-2-赋值问题" class="headerlink" title="5.2.2 赋值问题"></a>5.2.2 赋值问题</h4><p>设置默认值<code>String sex() default &quot;1&quot;;</code></p>
<p>使用注解，数组类型的赋值 <code>str=&#123;xx,xx,xx&#125;</code>，若数组中只有一个，大括号可省略。回忆Spring中注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 基本数据类型</span><br><span class="line">		* String</span><br><span class="line">		* 枚举</span><br><span class="line">		* 注解</span><br><span class="line">		* 以上类型的数组</span><br></pre></td></tr></table></figure>

<h3 id="5-3-元注解"><a href="#5-3-元注解" class="headerlink" title="5.3 元注解"></a>5.3 元注解</h3><blockquote>
<p><strong>用于描述注解的注解</strong></p>
</blockquote>
<p><code>@Target</code>：描述注解的位置</p>
<ul>
<li><code>ElementType</code>取值<ul>
<li>TYPE：可以作用于类上</li>
<li>METHOD：可以作用于方法上</li>
<li>FIELD：可以作用于成员变量上</li>
</ul>
</li>
</ul>
<p><code>@Retention</code>：描述注解是被保留的阶段</p>
<p><code>@Retention(RetentionPolicy.RUNTIME)</code>：当前被描述的注解，会保留到class字节码文件中，并被<code>JVM</code>读取到</p>
<p><code>@Documented</code>：描述注解是否被抽取到api文档中</p>
<p><code>@Inherited</code>：描述注解是否被子类继承</p>
<h3 id="5-4-注解的解析"><a href="#5-4-注解的解析" class="headerlink" title="5.4 注解的解析"></a>5.4 注解的解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Pro &#123;</span><br><span class="line">    <span class="function">String <span class="title">className</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">methodName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pro(className = &quot;com.bbxx.Demo1&quot;,methodName = &quot;show1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefelectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解析注解</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;RefelectDemo&gt; refelectDemoClass = RefelectDemo.class;</span><br><span class="line">        Pro annotation = refelectDemoClass.getAnnotation(Pro.class);</span><br><span class="line">        String s = annotation.className();</span><br><span class="line">        String s1 = annotation.methodName();</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(s);</span><br><span class="line">        Object o = aClass.newInstance();</span><br><span class="line">        Method declaredMethod = aClass.getDeclaredMethod(s1);</span><br><span class="line">        declaredMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        declaredMethod.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第六章-类加载器"><a href="#第六章-类加载器" class="headerlink" title="第六章 类加载器"></a>第六章 类加载器</h2><h3 id="6-1-分类"><a href="#6-1-分类" class="headerlink" title="6.1 分类"></a>6.1 分类</h3><p><code>ClassLoad</code>分类</p>
<ul>
<li>引导 类加载器—–&gt;负责加载类库 rt中的jar 【最高，Bootstrap】</li>
<li>扩展 类加载器—–&gt;负责加载扩展jar包  ext下的都是扩展jar</li>
<li>系统 类加载器—–&gt;应用下的类，包含开发人员写的类和三方jar包【最低】</li>
</ul>
<p><code>ClassLoad</code>有个双亲委派模型，会先问父   类加载器/上级类加载器，向上级委托，没有就自己加载，没找到就抛出<code>ClassNotFound</code>。永远不会出现类库中的类被系统加载器加载，应用下的类 被引导加载。</p>
<p>委托父加载器加载，父可以加载就让父加载。父无法加载时再自己加载。</p>
<ul>
<li>可避免类的重复加载，父类加载器已经加载了该类时，就没必要子<code>ClassLoader</code>再加载一次了/</li>
<li>考虑到安全因素，<code>java</code>核心<code>api</code>中定义类型不会被随意替换。</li>
</ul>
<h3 id="6-2-类加载的顺序"><a href="#6-2-类加载的顺序" class="headerlink" title="6.2 类加载的顺序"></a>6.2 类加载的顺序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123; <span class="comment">// 系统加载</span></span><br><span class="line">        <span class="comment">// 也由系统加载</span></span><br><span class="line">        A a = <span class="keyword">new</span> A(); </span><br><span class="line">        <span class="comment">// 也由系统加载 （从系统开始匹配，最终会委托上去， ...由引导加载）</span></span><br><span class="line">        String s = <span class="keyword">new</span> String();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span>&#123; <span class="comment">// 引导加载， String类，类库中的</span></span><br><span class="line">    <span class="keyword">private</span> Integer i;<span class="comment">// 直接引导加载，毕竟无法委托了！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实还得分线程，每个线程都有一个当前的类加载器来负责加载类。</p>
<h3 id="6-3-流程"><a href="#6-3-流程" class="headerlink" title="6.3 流程"></a>6.3 流程</h3><p>基础阶段 <strong>了解</strong>，中级阶段 <strong>熟悉</strong>，高级阶段，<strong>不清楚</strong>。</p>
<p>继承<code>ClassLoader</code>类完成自定义类加载器。自定义类加载器一般是为了加载网络上的类，class在网络中传输，为了安全，那么class需要加密，需要自定义类加载器来加载（对class做解密工作）</p>
<p><code>ClassLoader</code>加载类都是通过==<code>loadClass()</code>==方法来完成的。<code>loadClass()</code>方法的工作流程如下：</p>
<ul>
<li>调用==<code>findLoadedClass()</code>==方法查看该类是否已经被加载过了，如果该类没有加载过，那么这个方法返回null。</li>
<li>判断<code>findLoadedClass()</code>返回的是否为null,如果不是null那么直接返回，可避免同一个类被加载两次。</li>
<li>如果<code>findLoadedClass()</code>返回的是null, 那么就启动代理模式（委托机制），即调用上级的<code>loadClass()</code>方法，获取上级的方法是<code>getParent()</code>，当然上级可能还有上级，这个动作就一直向上走；（==双亲委派机制==，tomcat破坏了双亲委派模型）</li>
<li>如果<code>getParent().loadClass()</code>返回的不是null，这说明上级加载成功了，那么就加载结果；</li>
<li>如果上级返回的是null，说明需要自己出手，<code>loadClass()</code>方法会调用本类的<code>findClass()</code>方法来加载类</li>
<li>这说明我们只需要重写<code>ClassLoader</code>的<code>findClass()</code>方法，这就可以了！如果重写了<code>loadClass()</code>方法覆盖了代理模式！</li>
</ul>
<p>我们要自定义一个类加载器，只需要继承<code>ClassLoader</code>类。然后重写它的<code>findClass()</code>方法即可。在<code>findClass()</code>中我们需要完成如下的工作！</p>
<ul>
<li>找到class文件，把它加载到一个byte[]中</li>
<li>调用<code>defineClass()</code>方法，把byte[]传递给这个方法即可</li>
</ul>
<h3 id="6-4-自定义类加载器"><a href="#6-4-自定义类加载器" class="headerlink" title="6.4 自定义类加载器"></a>6.4 自定义类加载器</h3><blockquote>
<p><strong>文件类加载器</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String directory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String _directory, ClassLoader paraent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(paraent);</span><br><span class="line">        <span class="keyword">this</span>.directory = _directory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 把类名转为目录</span></span><br><span class="line">            String file = directory + File.separator + name.replace(<span class="string">&quot;.&quot;</span>, File.separator) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            <span class="comment">// 构建输入流</span></span><br><span class="line">            InputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] byteArray = baos.toByteArray();</span><br><span class="line">            fis.close();</span><br><span class="line">            baos.close();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, byteArray, <span class="number">0</span>, byteArray.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>热部署，越过双亲委派，就是不用<code>loadClass</code> 用<code>findClass</code></p>
<blockquote>
<p><strong>复杂例子</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类加载器学习</span></span><br><span class="line"><span class="comment"> * 注意maven中的单元测试只能写在 test下面！</span></span><br><span class="line"><span class="comment"> * 字节码文件请自己生成一个 然后调用对应的方法哦！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类加载器的地盘，指明加载那个地方的class文件</span></span><br><span class="line">    <span class="keyword">private</span> String classpath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassLoaderDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassLoaderDemo</span><span class="params">(String classpath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classpath = classpath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoaderDemo classLoaderDemo = <span class="keyword">new</span> ClassLoaderDemo();</span><br><span class="line">        classLoaderDemo.fun2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行字节码的非静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoaderDemo classLoaderDemo = <span class="keyword">new</span> ClassLoaderDemo(<span class="string">&quot;D:\\&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = classLoaderDemo.loadClass(<span class="string">&quot;org.example.classloader.ClassLoaderTest&quot;</span>);</span><br><span class="line">        <span class="comment">// loaderSay是一个非静态方法，需要一个实例调用</span></span><br><span class="line">        Method loaderSay = clazz.getMethod(<span class="string">&quot;loaderSay&quot;</span>);</span><br><span class="line">        ClassLoaderTest o = (ClassLoaderTest) clazz.newInstance();</span><br><span class="line">        <span class="comment">// 非静态方法需要一个实例进行调用</span></span><br><span class="line">        loaderSay.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行字节码的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoaderDemo classLoaderDemo = <span class="keyword">new</span> ClassLoaderDemo(<span class="string">&quot;D:\\&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = classLoaderDemo.loadClass(<span class="string">&quot;org.example.classloader.ClassLoaderTest&quot;</span>);</span><br><span class="line">        <span class="comment">// loaderSay是一个非静态方法，需要一个实例调用</span></span><br><span class="line">        Method loaderSay = clazz.getMethod(<span class="string">&quot;loaderStaticFunction&quot;</span>);</span><br><span class="line">        <span class="comment">// 静态方法不用实例</span></span><br><span class="line">        String result = (String) loaderSay.invoke(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写这个方法即可</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 自定义的方法，通过类名找到class文件，把文件加载到一个字节数组中</span></span><br><span class="line">            <span class="keyword">byte</span>[] datas = getClassData(name);</span><br><span class="line">            <span class="keyword">if</span> (datas == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;类没有找到：&quot;</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, datas, <span class="number">0</span>, datas.length);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;类找不到:&quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String name) &#123;</span><br><span class="line">        <span class="comment">// 把名字换成文件夹的名字</span></span><br><span class="line">        name = name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;\\&quot;</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        File classFile = <span class="keyword">new</span> File(classpath, name);</span><br><span class="line">        System.out.println(classFile.getAbsoluteFile());</span><br><span class="line">        <span class="keyword">return</span> readClassData(classFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] readClassData(File classFile) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!classFile.exists()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(classFile);</span><br><span class="line">            bytes = fis.readAllBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-5-Tomcat类加载器"><a href="#6-5-Tomcat类加载器" class="headerlink" title="6.5 Tomcat类加载器"></a>6.5 Tomcat类加载器</h3><p>tomcat提供了两种类加载器。</p>
<p><strong>第一种 服务器类加载器</strong></p>
<ul>
<li>${CATALINA-HOME}\lib\，tomcat类加载器，它负责加载下面的类</li>
</ul>
<p><strong>第二种 应用类加载器</strong></p>
<ul>
<li>${CONTEXT}\WEB-INF\lib  </li>
<li>${CONTEXT}\WEB-INF\classes</li>
</ul>
<p><strong>总结</strong></p>
<p>tomcat破坏了双亲委派模型</p>
<p>引导</p>
<p>扩展</p>
<p>系统</p>
<p>服务器类加载器：先自己动手，然后再去委托</p>
<p>应用类加载器：先自己动手，然后再去委托</p>
<img src="D:\69546\Documents\pics\JavaStrengthen\tomcat_classLoader.png" style="float:left">

<h2 id="第七章-并发"><a href="#第七章-并发" class="headerlink" title="第七章 并发"></a>第七章 并发</h2><h3 id="7-1-注意"><a href="#7-1-注意" class="headerlink" title="7.1 注意"></a>7.1 注意</h3><blockquote>
<p><strong>不要调用Thread类或Runnable对象的run方法</strong>。直接调用run方法会在同一个线程中执行—-不会启动新的线程。调用<code>Thread.start()</code>方法会创建一个执行run方法的新线程。</p>
</blockquote>
<blockquote>
<p><strong>线程的六种状态</strong></p>
</blockquote>
<ul>
<li>New：新建</li>
<li>Runnable：可运行【可能在运行 或 准备运行】</li>
<li>Blocked：【阻塞】</li>
<li>Waiting：【等待】</li>
<li>Timed waiting：【具有指定等待时间的等待线程的线程状态。一个线程处于定时等待状态，这是由于调用了以下方法中的一种，具有指定的正等待时间】</li>
<li>Terminated：【终止】</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread内部的枚举类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>lock和unlock，unlock要放在finally中，确保锁可以被释放。</strong></p>
</blockquote>
<blockquote>
<p><strong>可重入锁，获得锁的方法（代码）可以调用持有相同锁的方法</strong></p>
</blockquote>
<blockquote>
<p><strong><code>ReentrantLock()</code></strong></p>
</blockquote>
<ul>
<li>公平锁和非公平锁。</li>
<li>公平锁倾向于选择等待时间长的线程，这种策略可能严重影响性能。</li>
<li>一般选择非公平锁。</li>
</ul>
<blockquote>
<p><span style="color:green"><strong>Condition，用<code>ReentrantLock()</code>的实例对象获得Condition对象</strong></span></p>
</blockquote>
<ul>
<li><code>await()</code> 将该线程放在这个条件的等待集中，<span style="color:green"><strong>并放弃锁！</strong></span></li>
<li><code>singalAll()</code> 激活等待这个条件的所有线程，把他们从等待集中移出，让他们重新成为可运行的线程！</li>
<li><code>singal()</code> 从该条件的等待集中随机选取一个从等待集中移出，让他们重新成为可运行的线程！</li>
<li><span style="color:green"><strong>用if做条件判断不合适，存在虚假唤醒的问题，用while。【<code>JDK</code>注释中有说明】</strong></span></li>
</ul>
<blockquote>
<p><strong>synchronized</strong></p>
</blockquote>
<blockquote>
<p><strong>线程就是一个单独的资源类，没有任何附属的操作。</strong></p>
</blockquote>
<blockquote>
<p><strong>线程局部变量 <code>ThreadLocal</code></strong></p>
</blockquote>
<ul>
<li><code>ThreadLocal.withInitial()</code>为函数式编程提供的方法</li>
</ul>
<p><strong>Unsafe类啊！</strong></p>
<h2 id="第八章-网络编程"><a href="#第八章-网络编程" class="headerlink" title="第八章 网络编程"></a>第八章 网络编程</h2><p>采用windows的<code>telent</code>工具作为客户端进行发起连接。</p>
<h3 id="8-1-入门"><a href="#8-1-入门" class="headerlink" title="8.1 入门"></a>8.1 入门</h3><blockquote>
<p><strong>Client</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试服务器连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// jdk 7 try catch用法</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="keyword">var</span> socket = <span class="keyword">new</span> Socket(<span class="string">&quot;time-a.nist.gov&quot;</span>, <span class="number">13</span>)) &#123;</span><br><span class="line">            <span class="keyword">var</span> scanner = <span class="keyword">new</span> Scanner(socket.getInputStream());</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">                System.out.println(scanner.nextLine() + <span class="string">&quot;==&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException, UnsupportedEncodingException </span>&#123;</span><br><span class="line">        String host = <span class="string">&quot;www.bilibili.com&quot;</span>;</span><br><span class="line">        InetAddress[] localhosts = InetAddress.getAllByName(host);</span><br><span class="line">        <span class="keyword">for</span> (InetAddress tmp : localhosts) &#123;</span><br><span class="line">            System.out.println(tmp.getHostAddress());</span><br><span class="line">            System.out.println(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket();</span><br><span class="line">        socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;time-a.nist.gov&quot;</span>, <span class="number">13</span>), <span class="number">10000</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(socket.getInputStream());</span><br><span class="line">        <span class="comment">// Scanner类不是很熟悉</span></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            System.out.println(scanner.nextLine());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        fun3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Server</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器端的 inputStream 和 outPutStream</span></span><br><span class="line"><span class="comment">     * inPutStream 输入流，输入到Server</span></span><br><span class="line"><span class="comment">     * outPutStream 输出流，输出到client</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8189</span>);</span><br><span class="line">        Socket accept = serverSocket.accept();</span><br><span class="line">        <span class="comment">// 控制台读入数据</span></span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(accept.getInputStream(), StandardCharsets.UTF_8);</span><br><span class="line">        <span class="comment">// 输出 IO流还是不熟悉 类的组合太复杂了</span></span><br><span class="line">        <span class="comment">// PrintWriter out = new PrintWriter(new OutputStreamWriter(accept.getOutputStream(), StandardCharsets.UTF_8), true);</span></span><br><span class="line">        OutputStreamWriter out = <span class="keyword">new</span> OutputStreamWriter(accept.getOutputStream(), StandardCharsets.UTF_8);</span><br><span class="line">        out.write(<span class="string">&quot;connected&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!done &amp;&amp; in.hasNextLine()) &#123;</span><br><span class="line">            <span class="comment">// 控制台输入数据</span></span><br><span class="line">            String line = in.nextLine();</span><br><span class="line">            <span class="comment">// 输出到客户端</span></span><br><span class="line">            out.write(<span class="string">&quot;Echo:&quot;</span> + line);</span><br><span class="line">            out.flush();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;BYE&quot;</span>.equals(line.trim())) done = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第九章-Servlet3-0"><a href="#第九章-Servlet3-0" class="headerlink" title="第九章 Servlet3.0"></a>第九章 Servlet3.0</h2><ul>
<li>注解</li>
<li>文件上传</li>
<li>异步处理 需要 <code>asyncSupported=true</code>，有过滤器的话，过滤器也要设置<code>asyncSupported = true</code></li>
</ul>
<p>使用型特性就是在保护你的Java职业生涯。</p>
<h3 id="9-1-注解替代xml"><a href="#9-1-注解替代xml" class="headerlink" title="9.1 注解替代xml"></a>9.1 注解替代<code>xml</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/index.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        request.setAttribute(<span class="string">&quot;data&quot;</span>, fakeData());</span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/demo.jsp&quot;</span>).forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;User&gt; <span class="title">fakeData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        users.addAll(Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;111&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;222&quot;</span>, <span class="string">&quot;222&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;333&quot;</span>, <span class="string">&quot;333&quot;</span>)));</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-异步响应"><a href="#9-2-异步响应" class="headerlink" title="9.2 异步响应"></a>9.2 异步响应</h3><p>异步响应如果不设置编码格式 可能会导致异步失败（有乱码，异步可能会失败；主要是告诉它响应文本是什么。）测试了一下，的确是设置好响应文本即可。</p>
<p>异步响应如果过滤器这些东西没有设置为异步状态，也会导致异步失败</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 类型 异常报告</span><br><span class="line">* 消息 当前链的筛选器或servlet不支持异步操作。</span><br><span class="line">* 描述 服务器遇到一个意外的情况，阻止它完成请求</span><br><span class="line"></span><br><span class="line">错误的原因就是过滤器没有设置  asyncSupported = true</span><br></pre></td></tr></table></figure>

<p><strong>代码案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/async&quot;, asyncSupported = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] getOutPutChar(String str) &#123;</span><br><span class="line">        <span class="keyword">return</span> str == <span class="keyword">null</span> ? <span class="string">&quot;   2020年 10月24日，祝各位程序员节日快乐！ 2020-1024=996，想不到吧！&quot;</span>.toCharArray() : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 不加设置响应的类型的话，就无法异步。</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        AsyncContext asyncContext = request.startAsync(request, response);</span><br><span class="line">        threadOutPut(asyncContext, response, getOutPutChar(<span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> asyncContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStr    需要输出给浏览器的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">threadOutPut</span><span class="params">(AsyncContext asyncContext, HttpServletResponse response, <span class="keyword">char</span>[] outputStr)</span> </span>&#123;</span><br><span class="line">        asyncContext.start(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                PrintWriter print = response.getWriter();</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">600</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c : outputStr) &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">180</span>);</span><br><span class="line">                    print.print(c); print.flush();</span><br><span class="line">                &#125;</span><br><span class="line">                asyncContext.complete();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                asyncContext.complete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-文件上传"><a href="#9-3-文件上传" class="headerlink" title="9.3 文件上传"></a>9.3 文件上传</h3><blockquote>
<p><strong>几个重要的API</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- request.getPart(<span class="string">&quot;file_name&quot;</span>) <span class="comment">// 获得文件对象Part</span></span><br><span class="line">- part.getName() <span class="comment">// 获得文件上传时的 name &lt;input name=&quot;xx&quot;&gt; 中的name</span></span><br><span class="line">- part.getSize() <span class="comment">// 获得文件的大小</span></span><br><span class="line">- part.getSubmittedFileName() <span class="comment">// 获得提交的文件的名字。上传的是 demo.txt 那么得到的就是 demo.txt</span></span><br><span class="line">- part.getInputStream(); <span class="comment">// 获得文件输入流。</span></span><br><span class="line"></span><br><span class="line">获取文件输入流后，在用输出流 存入磁盘。</span><br></pre></td></tr></table></figure>

<p><strong>文件上传的简单Demo</strong></p>
<p>文件上传用绝对路径【公司】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/upload&quot;)</span></span><br><span class="line"><span class="meta">@MultipartConfig</span> <span class="comment">// 表示它支持文件上传</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        Part part = request.getPart(<span class="string">&quot;file_name&quot;</span>);</span><br><span class="line">        System.out.println(part.getName());</span><br><span class="line">        System.out.println(part.getSize());</span><br><span class="line">        System.out.println(part.getSubmittedFileName());</span><br><span class="line">        InputStream inputStream = part.getInputStream();</span><br><span class="line">        <span class="comment">// new FileOutputStream(&quot;filename&quot;) 这样是无法定位位置的，不能正常存储？</span></span><br><span class="line">        <span class="comment">//D:\citespace.projects.txt</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D://&quot;</span> + part.getSubmittedFileName());</span><br><span class="line">        <span class="comment">// citespace.projects.txt</span></span><br><span class="line">        <span class="comment">// FileOutputStream fos = new FileOutputStream(part.getSubmittedFileName());</span></span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        inputStream.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    enctype 说明有文件要提交过去</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/Tomcat/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file_name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="第十章-双亲委派"><a href="#第十章-双亲委派" class="headerlink" title="第十章 双亲委派"></a>第十章 双亲委派</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>class文件通过<strong>类加载器</strong>装载至JVM中的。为了防止内存中存放在多份同样的字节码，使用了双亲委派机制（它不会自己去尝试加载类，而是把请求委托给父加载器去完成，依次向上，避免重复加载字节码）</p>
<p>JDK中的本地方法类一般由根加载器（Bootstrap loader）装载；JDK中内部实现的扩展类一般由扩展加载器（ExtClassLoader）实现装载；而程序中的类文件则由系统加载器（AppClassLoader）实现装载。</p>
<img src="D:/note/JavaEE-Study/pics/JavaStrengthen/jvm/ClassLoader.jpg">

<h3 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h3><p>只要加载类的时候，不是从 App ClassLoader –&gt; Ext ClassLoader –&gt; BootStrap ClassLoader 这个顺序查找，就是打破了双亲委派机制。</p>
<p>加载class核心的方法在LoaderClass类的loadClass方法上（双亲委派机制的核心实现），只要我们定义个 ClassLoader，重写 loadClass 方法（不按照往上开始寻找类加载器），那就算是打破双亲委派机制了。</p>
<blockquote>
<p><strong>Tomcat打破双亲委派机制</strong></p>
</blockquote>
<p>我们部署传统javaweb项目是，把war包放到tomcat的webapp下，这意味着一个tomcat可以运行多个web应用程序；</p>
<hr>
<p>假设有两个Web应用程序，它们都有一个类，叫做User，并且它们的类全限定名都一样，如都是 <code>com.yyy.User</code>，但是他们的具体实现是不一样的。那么tomcat如何保证它们是不会冲突的？<strong>tomcat为每个Web应用创建一个类加载实例（WebAppClassLoader），该加载器重写了 loadClass 方法，优先加载当前应用目录下的嘞，如果当前找不到了，才一层一层往上找</strong>，这样就做到了Web应用层级的隔离。</p>
<hr>
<p>并不是Web应用程序下的所有依赖都需要隔离的，比如 Redis 就可以 Web 应用之间共享（有需要的话），因为如果版本相同，没必要每个Web应用程序都独自加载一份。具体做法是：Tomcat 在 WebAppClassLoader 上加了个父类加载器 （Shared ClassLoader），<strong>如果 WebAppClassLoader 自身没有加载到某个类，就委托 SharedClassLoader 去加载（把需要应用程序之间需要共享的类放到一个共享目录下，Share ClassLoader 读共享目录的类即可</strong>）。</p>
<p>为了隔绝Web应用程序与Tomcat本身的类，又有类加载器（CatalinaClassLoader）来装载 Tomcat 本身的依赖。如果 Tomcat 本身的依赖和 Web 应用还需要共享，那么还有类加载器（CommonClassLoader）来装载而达到共享。各个类加载器的加载目录可以到 Tomcat 的 catalina.properties 配置文件上查看。</p>
<hr>
<blockquote>
<p>Tomcat的类加载结构图</p>
</blockquote>
<img src="D:/note/JavaEE-Study/pics/JavaStrengthen/jvm/Tomcat_ClassLoader.jpg">

<blockquote>
<p>JDBC破坏了双亲委派？</p>
</blockquote>
<p>JDBC定义了接口，具体实现类由各个厂商进行实现。</p>
<p>类加载的规则如下：如果一个类由类加载器A加载，那么这个类的依赖类也是由相同的类加载器加载。</p>
<p>使用JDBC的时候，是使用 DriverManager 进而获取 Connection，DriverManager 在 java.sql 包下，显然是由 BootStrap 类加载器进行装载。当我们使用 DriverManager.getConnection() 时，得到的一定是厂商实现的类，<strong>但 BootStrap ClassLoader 无法加载到各个厂商实现的类</strong>，因为这些实现类没在 java 包中。DriverManager 的解决方案时 在 DriverManager 初始化的时候， 得到<strong>线程上下文加载器</strong>，去获取 Connection 的时候，是使用线程上下文加载器去加载 Connection 的，<strong>而这里的线程上下文加载器实际上还是 App ClassLoader</strong>，所以在获取 Connection 的时候，还是先找 Ext ClassLoader 和 BootStrap ClassLoader，只不过这两加载器肯定加载不到的，最终会由App ClassLoader进行加载！</p>
<p>有人觉得本应由 BootStrao ClassLoader 进行加载的 却改成 线程上下文加载器加载 就觉得破坏了。</p>
<p>有人觉得虽然改成了线程上下文加载器 但是依旧遵守 依次往上找父类加载器进行加载，都找不到时才由自己加载，认为<strong>原则</strong>上时没变的。</p>
<p>不重要好吧！理解为什么重要！</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>前置知识</strong>：JDK中默认类加载器有三个：AppClassLoader、Ext ClassLoader、BootStrap ClassLoader。AppClassLoader的父加载器为Ext ClassLoader、Ext ClassLoader的父加载器为BootStrap ClassLoader。这里的父子关系并不是通过继承实现的，而是组合。</p>
<p><strong>什么是双亲委派机制</strong>：加载器在加载过程中，先把类交由父类加载器进行加载，父类加载器没找到才由自身加载。</p>
<p><strong>双亲委派机制目的</strong>：为了防止内存中存在多份同样的字节码（安全）</p>
<p><strong>类加载规则</strong>：如果一个类由类加载器A加载，那么这个类的依赖类也是由「相同的类加载器」加载。</p>
<p><strong>如何打破双亲委派机制</strong>：自定义ClassLoader，重写loadClass方法（只要不依次往上交给父加载器进行加载，就算是打破双亲委派机制）</p>
<p><strong>打破双亲委派机制案例</strong>：Tomcat</p>
<ol>
<li>为了Web应用程序类之间隔离，为每个应用程序创建WebAppClassLoader类加载器</li>
<li>为了Web应用程序类之间共享，把ShareClassLoader作为WebAppClassLoader的父类加载器，如果WebAppClassLoader加载器找不到，则尝试用ShareClassLoader进行加载</li>
<li>为了Tomcat本身与Web应用程序类隔离，用CatalinaClassLoader类加载器进行隔离，CatalinaClassLoader加载Tomcat本身的类</li>
<li>为了Tomcat与Web应用程序类共享，用CommonClassLoader作为CatalinaClassLoader和ShareClassLoader的父类加载器</li>
<li>ShareClassLoader、CatalinaClassLoader、CommonClassLoader的目录可以在Tomcat的catalina.properties进行配置</li>
</ol>
<p><strong>线程上下文加载器</strong>：由于类加载的规则，很可能导致父加载器加载时依赖子加载器的类，导致无法加载成功（BootStrap ClassLoader无法加载第三方库的类），所以存在「线程上下文加载器」来进行加载。</p>
<h2 id="第十一章-Java内存模型"><a href="#第十一章-Java内存模型" class="headerlink" title="第十一章 Java内存模型"></a>第十一章 Java内存模型</h2><blockquote>
<p>Java内存模型概述</p>
</blockquote>
<p>Java的内存模型 Java Memory Model，简称JMM，本身是一种抽象的概念，实际上并不存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p>
<p>JMM关于同步的规定：</p>
<ul>
<li>线程解锁前，必须把共享变量的值刷新回主内存</li>
<li>线程加锁前，必须读取主内存的最新值，到自己的工作内存</li>
<li>加锁和解锁是同一把锁</li>
</ul>
<blockquote>
<p>Java内存模型三大特性</p>
</blockquote>
<p>JMM的三大特性，volatile只保证了两个，即可见性和有序性，不满足原子性</p>
<ul>
<li>可见性</li>
<li>原子性</li>
<li>有序性</li>
</ul>
<h3 id="为什么需要内存模型"><a href="#为什么需要内存模型" class="headerlink" title="为什么需要内存模型"></a>为什么需要内存模型</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>多核计算机，每个核心都会有高速缓存。高速缓存的为了解决CPU与内存（主存）直接的速度差异，L1，L2缓存一般是【每个核心独占】一份的。L3缓存一般是多核共享的。</p>
<p>为了让CPU提高运算效率，处理器可能会对代码进行【乱序执行】，即指令重排序，可以会议下计算机组成原理的流水线执行。</p>
<p>计算机中的一些操作往往是非原子性的，如 i++ 在执行的时候需要多个指令才能完成 i++ 这个操作。在单线程下，是不会存在什么问题的，因为单线程意味着无法并发。且在单线程下，编译器 /runtime/ 处理器 必须遵守 as-if-serial 语义，即它们不会对数据<strong>依赖关系的操作</strong>做重排序</p>
<blockquote>
<p>缓存数据不一致</p>
</blockquote>
<p>多个线程同时修改 【共享变量】，CPU核心下的高速缓存是 【不共享】的，多个 cache 与内存直接的数据同部如何进行的？</p>
<ul>
<li>锁总线，锁数据传输</li>
<li>缓存一致性协议（如MESI协议，M（Modified）E（Exclusive）S（Share）I（Invalid））</li>
<li>锁总线开销太大了，一般是用缓存一致性协议，没办法的时候才会用锁总线。</li>
</ul>
<h4 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h4><p>MESI协议，M（Modified）E（Exclusive）S（Share）I（Invalid）</p>
<p>缓存一致性协议锁的是==缓存行==进行加锁。<strong>缓存行是高速缓存存储的最小单位。</strong></p>
<blockquote>
<p>MESI原理（计组那块的知识）</p>
</blockquote>
<p>当每个 CPU 读取共享变量之前，会先识别数据的对象状态（修改、共享、独占、无效）。</p>
<p>==独占==：说明 CPU 将要得到的变量数据是最新的，没有被其他 CPU 同时读取。</p>
<p>==共享==：说明 CPU 将要得到的变量数据还是最新的，有其他 CPU 在读取，但是还没被修改。</p>
<p>==修改==：说明当前 CPU 正在修改该变量的值，同时会向其他 CPU 发送该数据状态为 invalid（无效）的通知，得到其他 CPU 响应后（其他 CPU 将数据状态从共享（share）变成invilid（无效）），会当前 CPU 将高速缓存的数据写到主存，并把自己的状态从 modify 变成 exclusive。如果 CPU 发现数据是 invilid 则需要从主存重新读取最新的数据。</p>
<p>MESI 协议做的就是判判断<strong>对象状态</strong>， 根据对象状态来采取不同的策略。在某个 CPU 在对数据进行修改时，需要<strong>同步</strong>通知其他 CPU ，表示这个数据被我修改了，你们不能用了。<strong>对比锁总线，MESI协议的“锁粒度”更小，性能更高</strong>。</p>
<blockquote>
<p>CPU 优化</p>
</blockquote>
<p>同步，意味着等待，什么都做不了，浪费 CPU 资源。解决方案是把 同步 变成 异步。修改时同步告诉其他 CPU ，而现在则把最新修改的值写到 store buffer 中，并通知其他 CPU 记得要修改状态，随后 CPU 就直接返回做其他事了。等收到其他 CPU 发过来的响应消息，再将数据更新到高速缓存中。</p>
<p>其他 CPU 接收到 invalid 通知时，也会把接收到的消息放入 invalid queue 中，只要写到 invalid queue 就会直接返回告诉修改数据的 CPU 已将状态置为 invalid。</p>
<p>异步的问题在于：现在 CPU 修改为 A 值，写到 store buffer 了，CPU 可以做其他事，如果该 CPU 又 接收指令需要修改 A 值，但上一次修改的值 还在 store buffer 中，未修改至高速缓存。 所以 CPU 在读取的时候，需要去 store buffer 看看存不存在，存在则直接取，不存在才读主存的数据。</p>
<blockquote>
<p>CPU 乱序执行</p>
</blockquote>
<p>如果是不同核心的CPU读它们共享的高速缓存，还是可能出现读旧值的问题。CPU1 修改了A值，把修改后值写到 store buffer 并通知CPU2 对该值 进行 invalid 操作，而 CPU2 可能还没收到 invalid 通知，就去做其他操作了，导致 CPU2 读到的还是旧值。这称之为 CPU 乱序执行。为了解决乱序问题，引出了<strong>内存屏障</strong></p>
<blockquote>
<p>内存屏障</p>
</blockquote>
<p>内存屏障实际上是为了解决<strong>异步优化</strong>导致 <strong>CPU乱序执行/缓存不及时可见</strong> 的问题，解决方案就是把<strong>异步优化禁用</strong>了。</p>
<p>内存屏障可分为：</p>
<ul>
<li>写屏障</li>
<li>读屏障</li>
<li>读写屏障</li>
</ul>
<p>屏障：操作数据时，往数据插入一条“特殊的指令”。只要遇见这条指令，那前面的操作都得【完成】。</p>
<p>==写屏障==：CPU当发现写屏障指令时，会把该指令<strong>之前</strong>存在于 store Buffer 所有写指令<strong>刷入高速缓存</strong>。通过这种方式就<strong>可以让CPU修改的数据可以马上暴露给其他 CPU</strong>，达到写操作可见性的效果。</p>
<p>==读屏障==：CPU 当发现读屏障指令时，会把该指令之前存在于 invalid queue 所有的指令都处理掉，通过这种方式就<strong>可以确保当前CPU的缓存状态是准确的</strong>，达到读操作一定是读取最新的效果。</p>
<p>深入Linux内核架构一书中，读、写屏障的解释：</p>
<ul>
<li>==读屏障==：是读访问内存屏障。它保证 在屏障之后发出的任何读取操作执行之前，屏障之前发出的所有读取操作都已经完成。（<strong>屏障内的所有操作完成了！然后才会执行屏障后的操作！</strong>）</li>
<li>==写屏障==：是写访问内存屏障。它保证 在屏障之后发出的任何写操作执行之前，屏障之前发出的所有写操作都已经完成。</li>
<li>编译器在屏障之前发出的读写请求完 成之前，不会处理屏障之后的任何读写请求</li>
</ul>
<h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><p>由于不同 CPU 架构的缓存体系不一样，缓存一致性协议不一样、重排序的策略不一样、所提供的内存屏障指令也有差异，为了简化 Java 开发人员的工作，==Java 封装了一套规范：Java内存模型==</p>
<p>Java内存模型希望屏蔽各种硬件和操作系统的访问差异，保证了Java程序在各种平台下对内存的访问都能得到一致的效果。目的是解决多线程存在的原子性、可见性（缓存一致性）以及有序性的问题。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li><p>并发问题产生的三大根源是「可见性」「有序性」「原子性」</p>
</li>
<li><p>可见性：CPU架构下存在高速缓存，每个核心下的L1/L2高速缓存不共享（不可见）</p>
</li>
<li><p>有序性：主要有三部分可能导致打破（编译器和处理器可以在不改变「单线程」程序语义的情况下，可以对代码语句顺序进行调整重新排序</p>
</li>
<li><ul>
<li>编译器优化导致重排序（编译器重排）<ul>
<li>指令集并行重排序（CPU原生重排）</li>
<li>内存系统重排序（CPU架构下很可能有store buffer /invalid queue 缓冲区，这种「异步」很可能会导致指令重排）</li>
</ul>
</li>
</ul>
</li>
<li><p>原子性：Java的一条语句往往需要多条 CPU 指令完成(i++)，由于操作系统的线程切换很可能导致 i++ 操作未完成，其他线程“中途”操作了共享变量  i ，导致最终结果并非我们所期待的。</p>
</li>
<li><p>在CPU层级下，为了解决「缓存一致性」问题，有相关的“锁”来保证，比如“总线锁”和“缓存锁”。</p>
</li>
<li><ul>
<li>总线锁是锁总线，对共享变量的修改在相同的时刻只允许一个CPU操作。<ul>
<li>缓存锁是锁缓存行(cache line)，其中比较出名的是MESI协议，对缓存行标记状态，通过“同步通知”的方式，来实现(缓存行)数据的可见性和有序性</li>
<li>但“同步通知”会影响性能，所以会有内存缓冲区(store buffer/invalid queue)来实现「异步」进而提高CPU的工作效率</li>
<li>引入了内存缓冲区后，又会存在「可见性」和「有序性」的问题，平日大多数情况下是可以享受「异步」带来的好处的，但少数情况下，需要强「可见性」和「有序性」，只能”禁用”缓存的优化。</li>
<li>“禁用”缓存优化在CPU层面下有「内存屏障」，读屏障/写屏障/全能屏障，本质上是插入一条”屏障指令”，使得缓冲区(store buffer/invalid queue)在屏障指令之前的操作均已被处理，进而达到 读写 在CPU层面上是可见和有序的。</li>
</ul>
</li>
</ul>
</li>
<li><p>不同的CPU实现的架构不一样，Java为了屏蔽硬件和操作系统访问内存的各种差异，提出了「Java内存模型」的规范，保证了Java程序在各种平台下对内存的访问都能得到一致效果。</p>
</li>
</ul>
<h3 id="从源码到执行"><a href="#从源码到执行" class="headerlink" title="从源码到执行"></a>从源码到执行</h3><blockquote>
<p>流程概述</p>
</blockquote>
<p>编译—&gt;加载—&gt;解释—&gt;执行</p>
<ul>
<li>编译：将源码文件编译成JVM可解释的class文件。会对程序做语法分析、语义分析、注解处理等操作，最后才生成字节码文件。<ul>
<li>典型的处理有：泛型擦出，Java的泛型擦出就是在 编译 阶段执行的。</li>
</ul>
</li>
<li>加载：将编译后的class文件加载到JVM中。<ul>
<li>加载步骤：装载—&gt;连接—&gt;初始化</li>
</ul>
</li>
</ul>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><blockquote>
<p>装载</p>
</blockquote>
<ul>
<li><strong>装载时机</strong>：为了节省内存的开销，不会一次把所有的类都装载到JVM，而是等到 有需要 的时候才进行装载。（如new 反射）</li>
<li><strong>装载发生</strong>：class文件是通过 类加载器 加载到 JVM中，为防止内存中出现多分相同的字节码，使用了双亲委派机制（不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上）</li>
<li><strong>装载规则</strong>：JDK中的本地犯法类一般由根加载器（Bootstrao loader）装载，JDK中内部实现的扩展类一般由扩展加载器（ExtClassLoader）实现装载，而程序中的类文件则由系统加载器（AppClassLoader）实现装载。</li>
</ul>
<p>查找并加载类的二进制数据，在JVM堆中创建一个java.lang.Class类的对象，并将类相关的信息存储在JVM方法区中。</p>
<p>装载后，class文件就装载到了JVM中，并创建出了对应的Class对象和类信息，并这Class对象和类信息存储到了方法区中。</p>
<blockquote>
<p>连接</p>
</blockquote>
<p>对class的信息进行验证、为类变量分配内存空间并对其赋默认值。</p>
<p>连接的细化步骤为：验证—&gt;准备—&gt;解析</p>
<ul>
<li>验证：验证类是否符合 Java 规范 和 JVM 规范。</li>
<li>准备：为类的静态变量分配内存，初始化为系统的初始值。</li>
<li>解析：将<strong>符号引用</strong>转为直接引用的过程。（什么是符号引用？）</li>
</ul>
<p>通过连接，对class信息做了校验并分配了内存空间和默认值。</p>
<blockquote>
<p>初始化</p>
</blockquote>
<p>为类的静态变量赋予正确的初始值。</p>
<p>过程：收集 class 的静态变量、静态代码块、静态方法至clinit() 方法，随后从上往下开始执行（clinit()方法？）</p>
<p>如果 <strong>实例化对象</strong> 则会调用方法对实例变量进行初始化，并执行对应的构造方法内的代码。（==这块感觉写到有问题，查查资料==）</p>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>初始化完成后，执行某个类的方法时，会找到对应方法的字节码信息。然后交由解释器去将这些字节码信息解释成系统可以识别的指令。</p>
<p>字节码变成机器码的方式</p>
<ul>
<li>解释器</li>
<li>JIT</li>
</ul>
<p>JVM对热点代码做编译，非热点代码直接进行解释。运行频繁的数据会被解释为热点代码。</p>
<p>热点代码使用热点探测来检测是否为热点代码。热点探测一般两种方式：</p>
<ul>
<li>计数器 </li>
<li>抽样</li>
</ul>
<p>HotSpot使用的是 计数器 的方式进行探测，为每个方法准备了两类计数器：方法调用计数器和回边计数器。这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。即时编译器把热点方法的指令码保存起来，下次执行的时候就无需重复的进行解释，直接执行缓存的机器语言。</p>
<p><strong>执行次数大于100万次的代码会被编译成热点代码</strong></p>
<h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><p>操作系统把解释器解析出来的指令码，调用系统的硬件执行最终的程序指令。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul>
<li><p>Java跨平台因为有JVM屏蔽了底层操作系统</p>
</li>
<li><p>Java源码到执行的过程，从JVM的角度看可以总结为四个步骤：编译-&gt;加载-&gt;解释-&gt;执行</p>
</li>
<li><ul>
<li>「编译」经过 语法分析、语义分析、注解处理 最后才生成会class文件<ul>
<li>「加载」又可以细分步骤为：装载-&gt;连接-&gt;初始化。装载则把class文件装载至JVM，连接则校验class信息、分配内存空间及赋默认值，初始化则为变量赋值为正确的初始值。连接里又可以细化为：验证、准备、解析</li>
<li>「解释」则是把字节码转换成操作系统可识别的执行指令，在JVM中会有字节码解释器和即时编译器。在解释时会对代码进行分析，查看是否为「热点代码」，如果为「热点代码」则触发JIT编译，下次执行时就无需重复进行解释，提高解释速度</li>
<li>「执行」调用系统的硬件执行最终的程序指令</li>
</ul>
</li>
</ul>
</li>
<li><img src="D:/note/JavaEE-Study/pics/JavaStrengthen/jvm/From_Java2Class.jpg"></li>
</ul>
<h3 id="Java内存模型-1"><a href="#Java内存模型-1" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>ava内存模型希望屏蔽各种硬件和操作系统的访问差异，保证了Java程序在各种平台下对内存的访问都能得到一致的效果。目的是解决多线程存在的原子性、可见性（缓存一致性）以及有序性的问题。==Java 内存模型时一种规范，JVM会实现这种规范。==</p>
<blockquote>
<p>主要内容概述</p>
</blockquote>
<ul>
<li>Java 内存模型的抽象结构</li>
<li>happen-before 规则</li>
<li>对 volatile 内存语义的探讨</li>
</ul>
<blockquote>
<p>Java 内存模型的抽象结构</p>
</blockquote>
<p>Java 内存模型定义了：Java 线程对内存数据进行交互的规范。</p>
<p>线程之间的 共享变量 存储在 主内存 中，每个线程都有自己私有的 本地内存，本地内存 存储了该线程以 读\写 共享变量的副本。</p>
<p>本地内存是 Java 内存模型的抽象概念，并不是真实存在的。</p>
<img src="D:/note/JavaEE-Study/pics/JavaStrengthen/jvm/JMM.jpg">

<p>Java 内存模型规定了：线程对变量的所有操作都必须在 <strong>本地内存</strong> 进行，<strong>不能直接读写主内存</strong> 的变量。</p>
<p>Java内存模型定义了 8 种 操作来完成 变量如何从主内存到本地内存，以及变量如何从本地内存到主内存。分别是 read/load/use/assign/store/writer/lock/unlock操作。</p>
<img src="D:/note/JavaEE-Study/pics/JavaStrengthen/jvm/eight_op.jpg">

<blockquote>
<p>happen-before</p>
</blockquote>
<p>happen-before也是一套规则。目的是阐述“操作之间”的内存“可见性”。在happen-before规则下，我们写的代码只要前一个操作的结果对后续操作是可见的，是不会发生重排序的。</p>
<blockquote>
<p>volatile</p>
</blockquote>
<ul>
<li>有序性</li>
<li>可见性</li>
</ul>
<p>在volatile前后加了内存屏障，使得编译器和CPU无法进行重排序，并且写 volatile 变量对其他线程可见。</p>
<p>在汇编层面，是通过 lock 前缀指令来实现的（<strong>实现什么？没讲清楚，黄俊说的是实现的内存屏障？</strong>），而不是各种 fence 指令（因为大部分平台都支持 lock 指令，而 fence 指令 是 x86 平台的）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存屏障的实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movq 0(%%rsp), %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (local_dummy) : : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movl 0(%%esp),%0&quot;</span> : <span class="string">&quot;=r&quot;</span> (local_dummy) : : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// AMD64</span></span></span><br></pre></td></tr></table></figure>

<p>lock指令能保证：禁止 CPU 和 编译器 的重排序（保证了有序性）、保证 CPU 写核心的指令可以立即生效且其他核心的缓存数据失效（保证了可见性）</p>
<h2 id="第十二章-JVM内存结构"><a href="#第十二章-JVM内存结构" class="headerlink" title="第十二章 JVM内存结构"></a>第十二章 JVM内存结构</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>JVM的内存结构，往往指的就是 JVM 定义的 运行时数据区域。</p>
<p>==JVM内存结构分为5块：==方法区、堆、程序计数器、虚拟机栈、本地方法栈。=</p>
<img src="D:/note/JavaEE-Study/pics/JavaStrengthen/jvm/JVM_Memory.jpg">

<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>一块较小的内存空间，当前线程所执行字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。程序计数器时程序控制流的指示器，分支、循环、跳转、异常处理、线程回复等基础功能都依赖于程序计数器完成。</p>
<p>可以理解为计算机组成原理中的程序计数器。指向下一条需要执行的指令。<strong>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址</strong>；<strong>如果正在执行的是本地方法，这个计数器值则应为空。</strong></p>
<p>每个线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。程序计数器这块区域为线程私有，是线程安全的。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>描述的是 Java 方法执行的线程内存模型。每一条 Java 虚拟机线程都有自己私有的 Java 虚拟机栈，这个栈与线程同时创建，<strong>每次方法调用都会创建一个 栈帧</strong>。</p>
<p>==每个栈帧会包含几块内容：局部变量表、操作时栈、动态连接和返回地址==</p>
<p>Java 虚拟机栈的作用与传统语言中的栈非常类似，用于存储局部变量与一些尚未算好的结果。</p>
<img src="D:/note/JavaEE-Study/pics/JavaStrengthen/jvm/JVM_Stack.jpg">

<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到本地方法服务。</p>
<p>==HotSpot VM 直接把虚拟机栈和本地方法栈合二为一了。==</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote>
<p><strong>Java虚拟机规范中的解释：</strong></p>
</blockquote>
<p>方法区是可供各个线程共享的运行时内存区域。<strong>存储了每一个类的结构信息，如：运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。</strong>虚拟机可以自行选在在不在方法区实现垃圾回收算法。</p>
<blockquote>
<p><strong>HotSpot虚拟机</strong></p>
</blockquote>
<p>在HotSpot虚拟机，会常常提到 <strong>永久代</strong> 这个词。==HotSpot虚拟在 JDK8前 用 <strong>永久代</strong>实现了<strong>方法区</strong>==，而很多其他厂商的虚拟机其实是没有永久代的概念的。Java 虚拟机把方法区描述为堆的一个逻辑部分，但是它有一个别名叫作“非堆”，目的是为了与 Java 堆区分开来。</p>
<p>采用 <strong>永久代</strong> 实现 <strong>方法区</strong> 这种设计导致了 Java 应用 更容易遇到内存溢出的问题（永久代有 -XX:MaxPermSize 的上限，即使不设置也有默认大小，而J9 和 JRockit 只要没有触碰到进程可用内存的上限，如32位系统位4GB，就不会出现问题。）在JDK6 的时候 HotSpot 开发团队就有放弃永久代，逐步改为本地内存来实现方法区的计划了。</p>
<p>方法区主要用来存放已被虚拟机加载的“类相关信息”：包括类信息、常量池。</p>
<ul>
<li>类信息：类的版本、字段、方法、接口和父类等信息</li>
<li>常量池：静态常量池 和 运行时常量池（这块不熟悉）</li>
</ul>
<p>常量池：</p>
<ul>
<li>静态常量池：存储的是 <strong>字面量</strong> 以及 <strong>符号引用</strong> 等信息，静态常量池也包括了我们说的 <strong>字符串常量池</strong></li>
<li>运行时常量池：存储的是 <strong>类加载</strong> 时生成的 <strong>直接引用</strong> 等信息</li>
</ul>
<p>但自从在 <strong>JDK7</strong> 以后，就已经把 <strong>运行时常量池</strong> 和 <strong>静态常量池</strong> 转移到了 <strong>堆</strong> 内存中进行存储。<strong>到了JDK 8，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的元空间（Meta-space）来代替，把 JDK 7 中永久代还剩余的内容（主要是类型信息）全部移到元空间中。</strong>对于 <strong>物理分区</strong> 来说 <strong>运行时常量池</strong> 和 <strong>静态常量池</strong> 就属于堆。==（逻辑分区和物理实际存储的位置是不一样的）==</p>
<p>元空间存储不在虚拟机中，而是使用本地内存，JVM 不会再出现方法区的内存溢出，以往永久代经常因为内存不够用导致OOM异常。</p>
<img src="D:/note/JavaEE-Study/pics/JavaStrengthen/jvm/Method_Area.jpg">

<blockquote>
<p><strong>小结</strong></p>
</blockquote>
<p>HotSpot VM：HotSpot VM JDK7 以前永久代实现的方法区。JDK7 以前常量池在永久代（方法区）中，永久代容易OOM，JDK7 把常量池从 永久代（方法区） 移动到了 JVM 堆中。 ==JDK8开始，不在用永久代实现方法区了，而是用元空间实现方法区，永久代中剩余的内容（主要是类型信息）被移到了元空间。==</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。</p>
<p>堆涉及到了垃圾回收。以往的垃圾回收多数是基于“经典分代”来设计，需要新生代、老年代收集器搭配才能工作；HotSpot里面也出现了不采用分代设计的新垃圾收集器。现在以传统的 分代 思想介绍下堆的划分。</p>
<p><strong>堆</strong>被划分为新时代和老年代，新时代又被进一步划分为Eden和Survivor区，Surivivor由From Survivor和To Survivor组成。</p>
<img src="D:/note/JavaEE-Study/pics/JavaStrengthen/jvm/Heap_Split.jpg">

<p><strong>一般情况下 Eden：from：to = 8：1：1</strong></p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p><strong>JVM内存结构组成</strong>：JVM内存结构又称为「运行时数据区域」。主要有五部分组成：虚拟机栈、本地方法栈、程序计数器、方法区和堆。其中方法区和堆是线程共享的。虚拟机栈、本地方法栈以及程序计数器是线程隔离的。</p>
<h1 id="第四部分-源码阅读"><a href="#第四部分-源码阅读" class="headerlink" title="第四部分 源码阅读"></a>第四部分 源码阅读</h1><ul>
<li><p>修改idea配置</p>
<ul>
<li>Build，Execution，Deployment –&gt; Debugger –&gt; Stepping 的Do not step into the classes不要勾选</li>
</ul>
</li>
<li><p>把jdk的源码，解压，然后放在项目的目录下，不要放在src下就行，非项目目录也可以，然后idea源码关联改成我们解压后的那些文件，这样就可以修改源码注释了。</p>
</li>
</ul>
<hr>
<p><span style="color:red"><strong>JDK8核心源码目录说明</strong></span></p>
<ul>
<li><p>java.applet：applet所必须的类</p>
</li>
<li><p>java.awt：创建用户界面和绘制图形图像的所有类</p>
</li>
<li><p>java.beans：包含与开发javabeans有关的类</p>
</li>
<li><p><span style="color:red"><strong>java.lang：</strong></span>Java基础类【类装载（Class等）】、反射、字符串、线程类</p>
</li>
<li><p>java.math：主要是BigInteger、BigDecimal这两个的源码</p>
</li>
<li><p>java.net：网络应用出现提供类（阻塞式）</p>
</li>
<li><p><span style="color:red"><strong>java.nio：</strong></span>多路的、无阻塞的I/O</p>
</li>
<li><p>java.rmi：远程方法调用相关</p>
</li>
<li><p>java.security：安全框架类和接口</p>
</li>
<li><p>java.sql：操作数据库，闲得无聊可以看看</p>
</li>
<li><p><span style="color:red"><strong>java.util：</strong></span>重要的有：集合、JUC（Atomic、Lock、concurrent）、Stream（函数式操作）、工具类</p>
</li>
<li><p>java.text：处理文本、日期、数字和消息的类和接口（常见DataFormat、SimpleDataFormat）</p>
</li>
<li><p>java.time：日期时间工具库</p>
</li>
<li><p>javax.java：java扩展包，为了保持版本兼容，但有了更好的解决方案。如swing</p>
</li>
<li><p>launcher：和底层交互的c代码</p>
</li>
<li><p>org：其他企业组织提供的java类库，大部分不是oracle公司提供的。如w3c提供的对xml解析类和接口</p>
</li>
<li><p>com.sun：hotspot虚拟机中java.* 和javax.*的实现类，其他jdk中没有，这些类可能不向后兼容。</p>
</li>
</ul>
<p>Java native方法是用c c++实现的，无法查看到代码~要看的话去下open jdk的源码</p>
<p><span style="color:red"><strong>用open jdk的源码。</strong></span></p>
<ul>
<li>corba：不流行的多语言、分布式通讯接口</li>
<li>hotspot：Java虚拟机</li>
<li>hotspot-cpu：CPU相关代码（汇编器、模版解释器、部分runtime函数）</li>
<li>hotspot-os：操作系统相关代码</li>
<li>hotspot-os_cpu：操作系统+CPU的代码</li>
<li>hotspot-share：平台无关的通用代码</li>
<li>jaxp：xml处理</li>
<li>jaxws：一组XML web services的Java API</li>
<li><span style="color:green"><strong>jdk</strong></span>：Java开发工具包（share\class Java的实现 share\native目录里的是C++的实现）</li>
<li>langtools：Java语言工具</li>
<li>nashorn：JVM上的JavaScript运行时</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/2yke6e-bfEYGtTHxH-31HQ">https://mp.weixin.qq.com/s/2yke6e-bfEYGtTHxH-31HQ</a></p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/blog/blog/tags#JavaSE" >
    <span class="tag-code">JavaSE</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/blog/2021/07/24/test/">
        <span class="nav-arrow">← </span>
        
          test
        
      </a>
    
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%85%A5%E9%97%A8"><span class="toc-nav-text">第一部分 入门</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="toc-nav-text">第二章 开发环境</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-Java%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-nav-text">2.1 Java虚拟机</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-JRE%E5%92%8CJDK"><span class="toc-nav-text">2.2 JRE和JDK</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F"><span class="toc-nav-text">第三章 入门程序</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-1-%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%E8%AF%B4%E6%98%8E"><span class="toc-nav-text">3.1 程序开发步骤说明</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%B8%B8%E9%87%8F"><span class="toc-nav-text">第四章 常量</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%8F%98%E9%87%8F-amp-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-nav-text">第五章 变量&amp;数据类型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-nav-text">5.1 数据类型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-1-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-nav-text">5.1.1 基本数据类型</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-1-2-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-nav-text">5.1.2 引用数据类型</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-2-%E5%8F%98%E9%87%8F"><span class="toc-nav-text">5.2 变量</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-3-%E5%BC%BA%E5%88%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E2%96%B2"><span class="toc-nav-text">5.3 强制数据类型转换 ▲</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-4-ASCII%E7%A0%81%E8%A1%A8"><span class="toc-nav-text">5.4 ASCII码表</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-5-%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AF%B9%E7%85%A7%E5%85%B3%E7%B3%BB%E8%A1%A8%EF%BC%88%E7%BC%96%E7%A0%81%E8%A1%A8%EF%BC%89"><span class="toc-nav-text">5.5 数字和字符的对照关系表（编码表）</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%B8%B8%E7%94%A8%E8%BF%90%E7%AE%97"><span class="toc-nav-text">第六章 常用运算</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-nav-text">第七章 基本语法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-1-switch%E8%AF%AD%E5%8F%A5%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-nav-text">7.1 switch语句使用的注意事项</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-2-%E5%BE%AA%E7%8E%AF%E6%A6%82%E8%BF%B0"><span class="toc-nav-text">7.2 循环概述</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-3-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99"><span class="toc-nav-text">7.3 方法重载与重写</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#7-3-1-%E9%87%8D%E8%BD%BD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E2%96%B2"><span class="toc-nav-text">7.3.1 重载的注意事项▲</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-4-%E6%95%B0%E7%BB%84"><span class="toc-nav-text">7.4 数组</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#7-4-1-%E6%95%B0%E7%BB%84%E5%BE%97%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-nav-text">7.4.1 数组得初始化</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#7-4-2-%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-nav-text">7.4.2 数组作为参数，返回值</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-5-Java%E5%86%85%E5%AD%98%E5%88%92%E5%88%86"><span class="toc-nav-text">7.5 Java内存划分</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-6-%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="toc-nav-text">7.6 常见异常</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80"><span class="toc-nav-text">第二部分 基础</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0"><span class="toc-nav-text">第一章 面向对象概述</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%B1%BB%E4%B8%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-nav-text">类与类之间的关系</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-nav-text">1.1 面向对象</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-2-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-nav-text">1.2 类和对象</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-3-%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-nav-text">1.3 一个对象的内存图</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-4-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-nav-text">1.4 成员变量和局部变量</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-5-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-nav-text">1.5 访问修饰符</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-5-1-private%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7"><span class="toc-nav-text">1.5.1 private访问属性</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-6-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-nav-text">1.6 this关键字</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-6-1-this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-nav-text">1.6.1 this关键字的一些概念</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-6-2-this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%9C%E7%94%A8"><span class="toc-nav-text">1.6.2 this关键字的一些作用</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-6-%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="toc-nav-text">1.6 匿名对象</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-API"><span class="toc-nav-text">第二章 API</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-nav-text">概述</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#API%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-nav-text">API使用步骤</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-nav-text">第三章 字符串</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-1-%E6%A6%82%E8%BF%B0"><span class="toc-nav-text">3.1 概述</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-nav-text">3.1.1 字符串的特点</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-nav-text">3.1.2 字符串常量池</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8API"><span class="toc-nav-text">3.2 字符串常用API</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83%E2%96%B2"><span class="toc-nav-text">3.2.1 字符串的比较▲</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%8E%B7%E5%8F%96%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-nav-text">3.2.2 字符串获取相关方法</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96%E3%80%81%E8%BD%AC%E6%8D%A2%E3%80%81%E5%88%86%E5%89%B2"><span class="toc-nav-text">3.2.3 字符串截取、转换、分割</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E9%9D%99%E6%80%81%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-nav-text">第四章 静态关键字</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-1-%E9%9D%99%E6%80%81%E6%A6%82%E8%BF%B0"><span class="toc-nav-text">4.1 静态概述</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-1-1-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-nav-text">4.1.1 静态代码块的注意事项</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-1-2-%E9%9D%99%E6%80%81%E5%B7%A5%E5%85%B7%E7%B1%BBArrays"><span class="toc-nav-text">4.1.2 静态工具类Arrays</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-1-3-%E9%9D%99%E6%80%81%E5%B7%A5%E5%85%B7%E7%B1%BBMath"><span class="toc-nav-text">4.1.3 静态工具类Math</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BB%A7%E6%89%BF"><span class="toc-nav-text">第五章 继承</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-1-%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-nav-text">5.1 继承中成员变量的访问特点</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-2-%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="toc-nav-text">5.2 重写和重载</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-3-%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-nav-text">5.3 继承中构造方法的访问特点</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-4-%E7%BB%A7%E6%89%BF%E4%B8%AD-this%E5%92%8Csuper%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-nav-text">5.4 继承中 this和super的内存图</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%8A%BD%E8%B1%A1"><span class="toc-nav-text">第六章 抽象</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-1-%E6%8A%BD%E8%B1%A1%E6%A6%82%E8%BF%B0"><span class="toc-nav-text">6.1 抽象概述</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-2-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-nav-text">6.2 如何使用抽象类和抽象方法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%8E%A5%E5%8F%A3"><span class="toc-nav-text">第七章 接口</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-1-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-nav-text">7.1 代码示例</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-2-%E6%80%BB%E7%BB%93"><span class="toc-nav-text">7.2 总结</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-3-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-nav-text">7.3 接口的注意事项</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%A4%9A%E6%80%81"><span class="toc-nav-text">第八章 多态</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8-1-%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-nav-text">8.1 访问成员变量的两种方式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8-2-%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-nav-text">8.2 多态的好处</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%91%E4%B8%8A%E3%80%81%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-nav-text">8.3 对象的向上、下转型</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-final"><span class="toc-nav-text">第九章 final</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#9-1-final%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="toc-nav-text">9.1 final修饰类</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#9-2-final%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="toc-nav-text">9.2 final修饰方法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#9-3-final%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-nav-text">9.3 final修饰局部变量</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#9-4-final%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-nav-text">9.4 final修饰成员变量</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#PS-%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-nav-text">PS 权限修饰符</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-nav-text">第十章 内部类</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#10-1-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-nav-text">10.1 如何使用成员内部类</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#10-2-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-nav-text">10.2 如何使用局部内部类</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#10-3-%E5%B0%8F%E7%BB%93"><span class="toc-nav-text">10.3 小结</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#10-4-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-nav-text">10.4 匿名内部类</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#10-5-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-nav-text">10.5 内部类的继承</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0"><span class="toc-nav-text">第十一章</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#11-1-Object"><span class="toc-nav-text">11.1 Object</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#11-2-%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%85%B3"><span class="toc-nav-text">11.2 日期相关</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-nav-text">第十二章 集合框架</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#0-%E5%BC%95%E8%A8%80%EF%BC%88Think-in-Java-%E7%AC%AC11%E7%AB%A0-%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-nav-text">0 引言（Think in Java 第11章 持有对象）</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#12-1-List%E9%9B%86%E5%90%88"><span class="toc-nav-text">12.1 List集合</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#12-2-Set%E9%9B%86%E5%90%88"><span class="toc-nav-text">12.2 Set集合</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#12-3-Map%E9%9B%86%E5%90%88"><span class="toc-nav-text">12.3 Map集合</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#12-4-%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-nav-text">12.4 集合工具类</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#12-5-%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-nav-text">12.5 比较器</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%BC%82%E5%B8%B8"><span class="toc-nav-text">第十三章 异常</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E6%B3%A8%E8%A7%A3"><span class="toc-nav-text">第十四章 注解</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-IO%E6%B5%81"><span class="toc-nav-text">第十五章 IO流</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#15-1-%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-nav-text">15.1 字节流</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#15-1-1-%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%EF%BC%88%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%EF%BC%89"><span class="toc-nav-text">15.1.1 文件的输入（读取文件）</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#15-1-2-%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%87%BA%EF%BC%88%E5%86%99%E5%85%A5%EF%BC%89"><span class="toc-nav-text">15.1.2 文件的输出（写入）</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#15-1-3-%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-nav-text">15.1.3 文件的复制</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#15-1-4-%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-nav-text">15.1.4 字节缓冲流</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#15-2-%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-nav-text">15.2 字符流</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#15-2-1-%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E8%BE%93%E5%87%BA%EF%BC%88%E5%86%99%E5%85%A5%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%EF%BC%89"><span class="toc-nav-text">15.2.1 字符流的输出（写入文本文件）</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#15-2-2-%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E8%BE%93%E5%85%A5%EF%BC%88%E8%AF%BB%E5%8F%96%E5%88%B0%E5%86%85%E5%AD%98%EF%BC%89"><span class="toc-nav-text">15.2.2 字符流的输入（读取到内存）</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#15-3-%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-nav-text">15.3 字符缓冲流的使用</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#15-3-File%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="toc-nav-text">15.3 File类概述</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#15-3-1-%E6%A6%82%E8%BF%B0"><span class="toc-nav-text">15.3.1 概述</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#15-4-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-nav-text">15.4 标准输入输出流</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#15-4-1-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-nav-text">15.4.1 标准输入流</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#15-4-2-%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-nav-text">15.4.2 标准输出流</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#15-4-%E6%89%93%E5%8D%B0%E6%B5%81-%E7%94%A8%E4%BA%8E%E5%86%99%E5%85%A5%E6%95%B0%E5%AD%97%EF%BC%8C%E5%86%99%E5%85%A5%E5%AF%B9%E8%B1%A1%E5%93%88%E5%B8%8C%E5%80%BC%E4%BB%80%E4%B9%88%E7%9A%84"><span class="toc-nav-text">15.4 打印流&#x3D;&#x3D;&#x3D;&#x3D;用于写入数字，写入对象哈希值什么的</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#15-4-1-%E5%AD%97%E8%8A%82%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-nav-text">15.4.1 字节打印流</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#15-4-2-%E5%AD%97%E7%AC%A6%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-nav-text">15.4.2 字符打印流</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#15-5-%E5%85%B6%E4%BB%96%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="toc-nav-text">15.5 其他流对象</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#15-5-1-%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-nav-text">15.5.1 对象序列化</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#15-5-2-Properties%E4%B8%8EIO%E6%B5%81%E7%9A%84%E7%BB%93%E5%90%88"><span class="toc-nav-text">15.5.2 Properties与IO流的结合</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E7%BA%BF%E7%A8%8B"><span class="toc-nav-text">第十六章 线程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#16-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="toc-nav-text">16.1 线程的运行</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#16-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-nav-text">16.2 线程的控制</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#16-2-1-join"><span class="toc-nav-text">16.2.1 join()</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#16-2-2-daemon"><span class="toc-nav-text">16.2.2 daemon()</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#16-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-nav-text">16.3 线程的同步</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#16-3-1-%E4%BD%BF%E7%94%A8synchronized"><span class="toc-nav-text">16.3.1 使用synchronized</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#16-3-2-%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-nav-text">16.3.2 同步代码块与同步方法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#16-4-Lock%E9%94%81"><span class="toc-nav-text">16.4 Lock锁</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#16-5-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-nav-text">16.5 生产者 消费者</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-nav-text">第十七章 网络编程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#17-1-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8"><span class="toc-nav-text">17.1 网络编程入门</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#17-2-IP%E5%9C%B0%E5%9D%80"><span class="toc-nav-text">17.2 IP地址</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#17-2-1-InetAddress"><span class="toc-nav-text">17.2.1 InetAddress</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#17-3-%E7%AB%AF%E5%8F%A3"><span class="toc-nav-text">17.3 端口</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#17-4-%E5%8D%8F%E8%AE%AE%EF%BC%88UDP%EF%BC%89"><span class="toc-nav-text">17.4 协议（UDP）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#17-4-1-UDP%E5%8D%8F%E8%AE%AE"><span class="toc-nav-text">17.4.1 UDP协议</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#17-4-2-UDP%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-nav-text">17.4.2 UDP通信原理</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#17-4-3-UDP%E5%8F%91%E9%80%81%EF%BC%8C%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-nav-text">17.4.3 UDP发送，接收数据的步骤</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#17-5-%E5%8D%8F%E8%AE%AE%EF%BC%88TCP%EF%BC%89"><span class="toc-nav-text">17.5 协议（TCP）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#17-5-1-TCP%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-nav-text">17.5.1 TCP通信原理</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#17-5-2-TCP%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-nav-text">17.5.2 TCP发送数据</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#17-6-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-nav-text">17.6 上传文件到服务器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%A8%A1%E6%8B%9FTomcat"><span class="toc-nav-text">模拟Tomcat</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-%E5%8F%8D%E5%B0%84"><span class="toc-nav-text">第十八章 反射</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#18-0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E6%A6%82%E8%BF%B0"><span class="toc-nav-text">18.0 类加载器前置知识概述</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#18-0-1-%E5%8A%A0%E8%BD%BD"><span class="toc-nav-text">18.0.1 加载</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#18-0-2-%E8%BF%9E%E6%8E%A5"><span class="toc-nav-text">18.0.2 连接</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#18-2-%E5%8F%8D%E5%B0%84%E6%A6%82%E8%BF%B0"><span class="toc-nav-text">18.2 反射概述</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#18-3-%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C"><span class="toc-nav-text">18.3 反射操作</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#18-3-1-%E8%8E%B7%E5%8F%96Class%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-nav-text">18.3.1 获取Class类的对象</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#18-3-2-%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-nav-text">18.3.2 获取构造方法</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#18-3-3-%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-nav-text">18.3.3  获取成员变量</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#18-3-4-%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-nav-text">18.3.4 获取成员方法</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#18-3-5-%E5%8F%8D%E5%B0%84%E8%B6%8A%E8%BF%87%E6%B3%9B%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-nav-text">18.3.5 反射越过泛型检查</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-nav-text">第十九章 函数式编程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#19-1-%E4%BD%93%E9%AA%8CLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-nav-text">19.1 体验Lambda表达式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#19-2-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F"><span class="toc-nav-text">19.2 Lambda表达式的标准格式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#19-3-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BB%83%E4%B9%A0"><span class="toc-nav-text">19.3 Lambda表达式的练习</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#19-4-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%9C%81%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-nav-text">19.4 Lambda表达式的省略模式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#19-5-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-nav-text">19.5 Lambda 表达式的注意事项</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#19-6-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E4%BD%A0%E4%BB%AC%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-nav-text">19.6 Lambda表达式和你们内部类的区别</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0-%E6%8E%A5%E5%8F%A3%E7%BB%84%E6%88%90%E6%9B%B4%E6%96%B0"><span class="toc-nav-text">第二十章 接口组成更新</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%A6%82%E8%BF%B0%EF%BC%9A%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-nav-text">概述：接口的组成</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-nav-text">静态方法引用</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E7%B1%BB%E7%9A%84%E4%BB%BB%E6%84%8F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-nav-text">类的任意对象的实例方法引用</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-nav-text">构造器引用</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#20-1-1-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-nav-text">20.1.1 函数式接口作为返回值</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#20-1-2-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-nav-text">20.1.2 常用的函数式接口</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#20-3-%E4%BD%93%E9%AA%8CStream%E6%B5%81"><span class="toc-nav-text">20.3 体验Stream流</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#20-4-Stream%E6%B5%81%E7%9A%84%E7%AE%80%E5%8D%95Demo"><span class="toc-nav-text">20.4 Stream流的简单Demo</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#20-5-2-%E4%B8%AD%E9%97%B4%E6%B5%81%E6%93%8D%E4%BD%9C"><span class="toc-nav-text">20.5.2 中间流操作</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#20-5-3-Stream%E6%B5%81%E7%9A%84%E6%94%B6%E9%9B%86%E6%93%8D%E4%BD%9C"><span class="toc-nav-text">20.5.3 Stream流的收集操作</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%80-JDBC"><span class="toc-nav-text">二十一 JDBC</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#C3P0"><span class="toc-nav-text">C3P0</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BD%BF%E7%94%A8-Druid"><span class="toc-nav-text">使用 Druid</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Spring-JDBC"><span class="toc-nav-text">Spring JDBC</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E5%8A%A0%E5%BC%BA"><span class="toc-nav-text">第三部分 加强</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9E%9A%E4%B8%BE"><span class="toc-nav-text">第一章 枚举</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-1-%E6%9E%9A%E4%B8%BE%E7%9A%84%E4%BD%BF%E7%94%A8Demo"><span class="toc-nav-text">1.1 枚举的使用Demo</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-2-%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-nav-text">1.2 枚举的常用方法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%AF%94%E8%BE%83%E5%AF%B9%E8%B1%A1"><span class="toc-nav-text">第二章 比较对象</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-nav-text">第三章 单元测试</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-1-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-nav-text">3.1 单元测试的优点</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-2%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-nav-text">3.2单元测试的使用</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-3-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%8E%9F%E7%90%86"><span class="toc-nav-text">3.3 单元测试原理</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%8D%E5%B0%84"><span class="toc-nav-text">第四章 反射</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-1-%E5%8F%8D%E5%B0%84%E6%A6%82%E8%BF%B0"><span class="toc-nav-text">4.1 反射概述</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-2-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-nav-text">4.2 反射的基本操作</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-2-1-%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-nav-text">4.2.1 获取成员变量</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-2-2-%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-nav-text">4.2.2 获取构造方法</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-2-3-%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-nav-text">4.2.3 获取成员方法</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-2-4-%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%90%8D"><span class="toc-nav-text">4.2.4 获取类名</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-2-5-%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E7%B1%BB"><span class="toc-nav-text">4.2.5 几个重要的类</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-3-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-nav-text">4.3 动态代理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-3-1-%E4%BD%9C%E7%94%A8"><span class="toc-nav-text">4.3.1 作用</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-3-2-%E5%9F%BA%E6%9C%ACDemo"><span class="toc-nav-text">4.3.2 基本Demo</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-3-3-invoke%E8%A7%A3%E9%87%8A"><span class="toc-nav-text">4.3.3 invoke解释</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-4-%E6%A8%A1%E6%8B%9FAOP"><span class="toc-nav-text">4.4 模拟AOP</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%B3%A8%E8%A7%A3"><span class="toc-nav-text">第五章 注解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-1-%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3"><span class="toc-nav-text">5.1 内置注解</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-nav-text">5.2 自定义注解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-2-1-%E5%B1%9E%E6%80%A7%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-nav-text">5.2.1 属性的返回值</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-2-2-%E8%B5%8B%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-nav-text">5.2.2 赋值问题</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-3-%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-nav-text">5.3 元注解</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-4-%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%A7%A3%E6%9E%90"><span class="toc-nav-text">5.4 注解的解析</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-nav-text">第六章 类加载器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-1-%E5%88%86%E7%B1%BB"><span class="toc-nav-text">6.1 分类</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-nav-text">6.2 类加载的顺序</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-3-%E6%B5%81%E7%A8%8B"><span class="toc-nav-text">6.3 流程</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-nav-text">6.4 自定义类加载器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-5-Tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-nav-text">6.5 Tomcat类加载器</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%B9%B6%E5%8F%91"><span class="toc-nav-text">第七章 并发</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-1-%E6%B3%A8%E6%84%8F"><span class="toc-nav-text">7.1 注意</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-nav-text">第八章 网络编程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8-1-%E5%85%A5%E9%97%A8"><span class="toc-nav-text">8.1 入门</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-Servlet3-0"><span class="toc-nav-text">第九章 Servlet3.0</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#9-1-%E6%B3%A8%E8%A7%A3%E6%9B%BF%E4%BB%A3xml"><span class="toc-nav-text">9.1 注解替代xml</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#9-2-%E5%BC%82%E6%AD%A5%E5%93%8D%E5%BA%94"><span class="toc-nav-text">9.2 异步响应</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#9-3-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-nav-text">9.3 文件上传</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE"><span class="toc-nav-text">第十章 双亲委派</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-nav-text">基本概念</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-nav-text">打破双亲委派机制</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-nav-text">小结</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-nav-text">第十一章 Java内存模型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-nav-text">为什么需要内存模型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-nav-text">背景</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#MESI%E5%8D%8F%E8%AE%AE"><span class="toc-nav-text">MESI协议</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-nav-text">Java内存模型</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-nav-text">小结</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E6%89%A7%E8%A1%8C"><span class="toc-nav-text">从源码到执行</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-nav-text">加载</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-nav-text">解释</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%89%A7%E8%A1%8C"><span class="toc-nav-text">执行</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-nav-text">小结</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-1"><span class="toc-nav-text">Java内存模型</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-nav-text">第十二章 JVM内存结构</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-nav-text">概述</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-nav-text">程序计数器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-nav-text">虚拟机栈</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-nav-text">本地方法栈</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-nav-text">方法区</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%A0%86"><span class="toc-nav-text">堆</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-nav-text">小结</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB"><span class="toc-nav-text">第四部分 源码阅读</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://csliujw.github.io/blog/2021/07/24/JavaSE基础/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>






    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2021 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/blog/js/script.js"></script>


  </body>
</html>